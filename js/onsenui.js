/*! onsenui v2.0.0-rc.5 - 2016-05-17 */
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.3
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node) {
    return added(node) || addedSubtree(node);
  }
  function added(node) {
    if (scope.upgrade(node)) {
      return true;
    }
    attached(node);
  }
  function addedSubtree(node) {
    forSubtree(node, function(e) {
      if (added(e)) {
        return true;
      }
    });
  }
  function attachedNode(node) {
    attached(node);
    if (inDocument(node)) {
      forSubtree(node, function(e) {
        attached(e);
      });
    }
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (!element.__attached && inDocument(element)) {
        element.__attached = true;
        if (element.attachedCallback) {
          element.attachedCallback();
        }
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (element.__attached && !inDocument(element)) {
        element.__attached = false;
        if (element.detachedCallback) {
          element.detachedCallback();
        }
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = wrap(node);
    if (!node) {
      node = wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler);
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    addedNode(doc);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attachedNode = attachedNode;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node) {
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(is || node.localName);
      if (definition) {
        if (is && definition.tag == node.localName) {
          return upgradeWithDefinition(node, definition);
        } else if (!is && !definition.extends) {
          return upgradeWithDefinition(node, definition);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    scope.attachedNode(element);
    scope.upgradeSubtree(element);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE11OrOlder = scope.isIE11OrOlder;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      var proto = definition.prototype, ancestor;
      while (proto && proto !== nativePrototype) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
  wrapDomMethodToForceUpgrade(document, "importNode");
  if (isIE11OrOlder) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE11OrOlder = /Trident/.test(navigator.userAgent);
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  function bootstrap() {
    upgradeDocumentTree(wrap(document));
    if (window.HTMLImports) {
      HTMLImports.__importsParsingHook = function(elt) {
        upgradeDocumentTree(wrap(elt.import));
      };
    }
    CustomElements.ready = true;
    setTimeout(function() {
      CustomElements.readyTime = Date.now();
      if (window.HTMLImports) {
        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
      }
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: true
      }));
    });
  }
  if (isIE11OrOlder && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
  scope.isIE11OrOlder = isIE11OrOlder;
})(window.CustomElements);

if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

!function n(t,e,r){function o(u,f){if(!e[u]){if(!t[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var l=e[u]={exports:{}};t[u][0].call(l.exports,function(n){var e=t[u][1][n];return o(e?e:n)},l,l.exports,n,t,e,r)}return e[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)o(r[u]);return o}({1:[function(n,t,e){"use strict";function r(){}function o(n){try{return n.then}catch(t){return d=t,w}}function i(n,t){try{return n(t)}catch(e){return d=e,w}}function u(n,t,e){try{n(t,e)}catch(r){return d=r,w}}function f(n){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof n)throw new TypeError("not a function");this._37=0,this._12=null,this._59=[],n!==r&&v(n,this)}function c(n,t,e){return new n.constructor(function(o,i){var u=new f(r);u.then(o,i),s(n,new p(t,e,u))})}function s(n,t){for(;3===n._37;)n=n._12;return 0===n._37?void n._59.push(t):void y(function(){var e=1===n._37?t.onFulfilled:t.onRejected;if(null===e)return void(1===n._37?l(t.promise,n._12):a(t.promise,n._12));var r=i(e,n._12);r===w?a(t.promise,d):l(t.promise,r)})}function l(n,t){if(t===n)return a(n,new TypeError("A promise cannot be resolved with itself."));if(t&&("object"==typeof t||"function"==typeof t)){var e=o(t);if(e===w)return a(n,d);if(e===n.then&&t instanceof f)return n._37=3,n._12=t,void h(n);if("function"==typeof e)return void v(e.bind(t),n)}n._37=1,n._12=t,h(n)}function a(n,t){n._37=2,n._12=t,h(n)}function h(n){for(var t=0;t<n._59.length;t++)s(n,n._59[t]);n._59=null}function p(n,t,e){this.onFulfilled="function"==typeof n?n:null,this.onRejected="function"==typeof t?t:null,this.promise=e}function v(n,t){var e=!1,r=u(n,function(n){e||(e=!0,l(t,n))},function(n){e||(e=!0,a(t,n))});e||r!==w||(e=!0,a(t,d))}var y=n("asap/raw"),d=null,w={};t.exports=f,f._99=r,f.prototype.then=function(n,t){if(this.constructor!==f)return c(this,n,t);var e=new f(r);return s(this,new p(n,t,e)),e}},{"asap/raw":4}],2:[function(n,t,e){"use strict";function r(n){var t=new o(o._99);return t._37=1,t._12=n,t}var o=n("./core.js");t.exports=o;var i=r(!0),u=r(!1),f=r(null),c=r(void 0),s=r(0),l=r("");o.resolve=function(n){if(n instanceof o)return n;if(null===n)return f;if(void 0===n)return c;if(n===!0)return i;if(n===!1)return u;if(0===n)return s;if(""===n)return l;if("object"==typeof n||"function"==typeof n)try{var t=n.then;if("function"==typeof t)return new o(t.bind(n))}catch(e){return new o(function(n,t){t(e)})}return r(n)},o.all=function(n){var t=Array.prototype.slice.call(n);return new o(function(n,e){function r(u,f){if(f&&("object"==typeof f||"function"==typeof f)){if(f instanceof o&&f.then===o.prototype.then){for(;3===f._37;)f=f._12;return 1===f._37?r(u,f._12):(2===f._37&&e(f._12),void f.then(function(n){r(u,n)},e))}var c=f.then;if("function"==typeof c){var s=new o(c.bind(f));return void s.then(function(n){r(u,n)},e)}}t[u]=f,0===--i&&n(t)}if(0===t.length)return n([]);for(var i=t.length,u=0;u<t.length;u++)r(u,t[u])})},o.reject=function(n){return new o(function(t,e){e(n)})},o.race=function(n){return new o(function(t,e){n.forEach(function(n){o.resolve(n).then(t,e)})})},o.prototype["catch"]=function(n){return this.then(null,n)}},{"./core.js":1}],3:[function(n,t,e){"use strict";function r(){if(c.length)throw c.shift()}function o(n){var t;t=f.length?f.pop():new i,t.task=n,u(t)}function i(){this.task=null}var u=n("./raw"),f=[],c=[],s=u.makeRequestCallFromTimer(r);t.exports=o,i.prototype.call=function(){try{this.task.call()}catch(n){o.onerror?o.onerror(n):(c.push(n),s())}finally{this.task=null,f[f.length]=this}}},{"./raw":4}],4:[function(n,t,e){(function(n){"use strict";function e(n){f.length||(u(),c=!0),f[f.length]=n}function r(){for(;s<f.length;){var n=s;if(s+=1,f[n].call(),s>l){for(var t=0,e=f.length-s;e>t;t++)f[t]=f[t+s];f.length-=s,s=0}}f.length=0,s=0,c=!1}function o(n){var t=1,e=new a(n),r=document.createTextNode("");return e.observe(r,{characterData:!0}),function(){t=-t,r.data=t}}function i(n){return function(){function t(){clearTimeout(e),clearInterval(r),n()}var e=setTimeout(t,0),r=setInterval(t,50)}}t.exports=e;var u,f=[],c=!1,s=0,l=1024,a=n.MutationObserver||n.WebKitMutationObserver;u="function"==typeof a?o(r):i(r),e.requestFlush=u,e.makeRequestCallFromTimer=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],5:[function(n,t,e){"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(n,t){var e=arguments.length?this.then.apply(this,arguments):this;e.then(null,function(n){setTimeout(function(){throw n},0)})})},{}],6:[function(n,t,e){n("asap");"undefined"==typeof Promise&&(Promise=n("./lib/core.js"),n("./lib/es6-extensions.js")),n("./polyfill-done.js")},{"./lib/core.js":1,"./lib/es6-extensions.js":2,"./polyfill-done.js":5,asap:3}]},{},[6]);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, function () { 'use strict';

   var babelHelpers = {};
   babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
     return typeof obj;
   } : function (obj) {
     return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
   };

   babelHelpers.classCallCheck = function (instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   };

   babelHelpers.createClass = function () {
     function defineProperties(target, props) {
       for (var i = 0; i < props.length; i++) {
         var descriptor = props[i];
         descriptor.enumerable = descriptor.enumerable || false;
         descriptor.configurable = true;
         if ("value" in descriptor) descriptor.writable = true;
         Object.defineProperty(target, descriptor.key, descriptor);
       }
     }

     return function (Constructor, protoProps, staticProps) {
       if (protoProps) defineProperties(Constructor.prototype, protoProps);
       if (staticProps) defineProperties(Constructor, staticProps);
       return Constructor;
     };
   }();

   babelHelpers.inherits = function (subClass, superClass) {
     if (typeof superClass !== "function" && superClass !== null) {
       throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
     }

     subClass.prototype = Object.create(superClass && superClass.prototype, {
       constructor: {
         value: subClass,
         enumerable: false,
         writable: true,
         configurable: true
       }
     });
     if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
   };

   babelHelpers.possibleConstructorReturn = function (self, call) {
     if (!self) {
       throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     }

     return call && (typeof call === "object" || typeof call === "function") ? call : self;
   };

   babelHelpers;

   var unwrap = function unwrap(string) {
     return string.slice(1, -1);
   };
   var isObjectString = function isObjectString(string) {
     return string.startsWith('{') && string.endsWith('}');
   };
   var isArrayString = function isArrayString(string) {
     return string.startsWith('[') && string.endsWith(']');
   };
   var isQuotedString = function isQuotedString(string) {
     return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
   };

   var error = function error(token, string, originalString) {
     throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
   };

   var processToken = function processToken(token, string, originalString) {
     if (token === 'true' || token === 'false') {
       return token === 'true';
     } else if (isQuotedString(token)) {
       return unwrap(token);
     } else if (!isNaN(token)) {
       return +token;
     } else if (isObjectString(token)) {
       return parseObject(unwrap(token));
     } else if (isArrayString(token)) {
       return parseArray(unwrap(token));
     } else {
       error(token, string, originalString);
     }
   };

   var nextToken = function nextToken(string) {
     string = string.trimLeft();
     var limit = string.length;

     if (string[0] === ':' || string[0] === ',') {

       limit = 1;
     } else if (string[0] === '{' || string[0] === '[') {

       var c = string.charCodeAt(0);
       var nestedObject = 1;
       for (var i = 1; i < string.length; i++) {
         if (string.charCodeAt(i) === c) {
           nestedObject++;
         } else if (string.charCodeAt(i) === c + 2) {
           nestedObject--;
           if (nestedObject === 0) {
             limit = i + 1;
             break;
           }
         }
       }
     } else if (string[0] === '\'' || string[0] === '\"') {

       for (var i = 1; i < string.length; i++) {
         if (string[i] === string[0]) {
           limit = i + 1;
           break;
         }
       }
     } else {

       for (var i = 1; i < string.length; i++) {
         if ([' ', ',', ':'].indexOf(string[i]) !== -1) {
           limit = i;
           break;
         }
       }
     }

     return string.slice(0, limit);
   };

   var parseObject = function parseObject(string) {
     var isValidKey = function isValidKey(key) {
       return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
       );
     };

     string = string.trim();
     var originalString = string;
     var object = {};
     var readingKey = true,
         key = void 0,
         previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
         error(token, string, originalString);
       } else if (token === ':' && readingKey && previousToken) {
         if (isValidKey(previousToken)) {
           key = previousToken;
           readingKey = false;
         } else {
           throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
         }
       } else if (token === ',' && !readingKey && previousToken) {
         object[key] = processToken(previousToken, string, originalString);
         readingKey = true;
       }
     }

     if (token) {
       object[key] = processToken(token, string, originalString);
     }

     return object;
   };

   var parseArray = function parseArray(string) {
     string = string.trim();
     var originalString = string;
     var array = [];
     var previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ',' && (!previousToken || previousToken === ',')) {
         error(token, string, originalString);
       } else if (token === ',') {
         array.push(processToken(previousToken, string, originalString));
       }
     }

     if (token) {
       if (token !== ',') {
         array.push(processToken(token, string, originalString));
       } else {
         error(token, string, originalString);
       }
     }

     return array;
   };

   var parse = function parse(string) {
     string = string.trim();

     if (isObjectString(string)) {
       return parseObject(unwrap(string));
     } else if (isArrayString(string)) {
       return parseArray(unwrap(string));
     } else {
       throw new Error('Provided string must be object or array like: ' + string);
     }
   };

   var util = {};

   /**
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {Function}
    */
   util.prepareQuery = function (query) {
     return query instanceof Function ? query : function (element) {
       return util.match(element, query);
     };
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name.
    * @return {Boolean}
    */
   util.match = function (element, query) {
     if (query[0] === '.') {
       return element.classList.contains(query.slice(1));
     }
     return element.nodeName.toLowerCase() === query;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findChild = function (element, query) {
     var match = util.prepareQuery(query);

     for (var i = 0; i < element.children.length; i++) {
       var node = element.children[i];
       if (match(node)) {
         return node;
       }
     }
     return null;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findParent = function (element, query) {
     var match = util.prepareQuery(query);

     var parent = element.parentNode;
     for (;;) {
       if (!parent || parent === document) {
         return null;
       }
       if (match(parent)) {
         return parent;
       }
       parent = parent.parentNode;
     }
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.isAttached = function (element) {
     while (document.documentElement !== element) {
       if (!element) {
         return false;
       }
       element = element.parentNode;
     }
     return true;
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.hasAnyComponentAsParent = function (element) {
     while (element && document.documentElement !== element) {
       element = element.parentNode;
       if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-sliding-menu|ons-split-view)/)) {
         return true;
       }
     }
     return false;
   };

   /**
    * @param {Element} element
    * @param {String} action to propagate
    */
   util.propagateAction = function (element, action) {
     for (var i = 0; i < element.childNodes.length; i++) {
       var child = element.childNodes[i];
       if (child[action] instanceof Function) {
         child[action]();
       } else {
         util.propagateAction(child, action);
       }
     }
   };

   /**
    * @param {String} selector - tag and class only
    * @param {Object} style
    * @param {Element}
    */
   util.create = function () {
     var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
     var style = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     var classList = selector.split('.');
     var element = document.createElement(classList.shift() || 'div');

     if (classList.length) {
       element.className = classList.join(' ');
     }

     util.extend(element.style, style);

     return element;
   };

   /**
    * @param {String} html
    * @return {Element}
    */
   util.createElement = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;

     if (wrapper.children.length > 1) {
       throw new Error('"html" must be one wrapper element.');
     }

     return wrapper.children[0];
   };

   /**
    * @param {String} html
    * @return {HTMLFragment}
    */
   util.createFragment = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;
     var fragment = document.createDocumentFragment();

     while (wrapper.firstChild) {
       fragment.appendChild(wrapper.firstChild);
     }

     return fragment;
   };

   /*
    * @param {Object} dst Destination object.
    * @param {...Object} src Source object(s).
    * @returns {Object} Reference to `dst`.
    */
   util.extend = function (dst) {
     for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       args[_key - 1] = arguments[_key];
     }

     for (var i = 0; i < args.length; i++) {
       if (args[i]) {
         var keys = Object.keys(args[i]);
         for (var j = 0; j < keys.length; j++) {
           var key = keys[j];
           dst[key] = args[i][key];
         }
       }
     }

     return dst;
   };

   /**
    * @param {Object} arrayLike
    * @return {Array}
    */
   util.arrayFrom = function (arrayLike) {
     return Array.prototype.slice.apply(arrayLike);
   };

   /**
    * @param {String} jsonString
    * @param {Object} [failSafe]
    * @return {Object}
    */
   util.parseJSONObjectSafely = function (jsonString) {
     var failSafe = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     try {
       var result = JSON.parse('' + jsonString);
       if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
         return result;
       }
     } catch (e) {
       return failSafe;
     }
     return failSafe;
   };

   /**
    * @param {String} path - path such as 'myApp.controllers.data.loadData'
    * @return {Any} - whatever is located at that path
    */
   util.findFromPath = function (path) {
     path = path.split('.');
     var el = window,
         key;
     while (key = path.shift()) {
       // eslint-disable-line no-cond-assign
       el = el[key];
     }
     return el;
   };

   /**
    * @param {Element} element
    * @param {String} eventName
    * @param {Object} [detail]
    * @return {CustomEvent}
    */
   util.triggerElementEvent = function (target, eventName) {
     var detail = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


     var event = new CustomEvent(eventName, {
       bubbles: true,
       cancelable: true,
       detail: detail
     });

     Object.keys(detail).forEach(function (key) {
       event[key] = detail[key];
     });

     target.dispatchEvent(event);

     return event;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean}
    */
   util.hasModifier = function (target, modifierName) {
     if (!target.hasAttribute('modifier')) {
       return false;
     }
     return target.getAttribute('modifier').split(/\s+/).some(function (e) {
       return e === modifierName;
     });
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was added or not.
    */
   util.addModifier = function (target, modifierName) {
     if (util.hasModifier(target, modifierName)) {
       return false;
     }

     modifierName = modifierName.trim();
     var modifierAttribute = target.getAttribute('modifier') || '';
     target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
     return true;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was found or not.
    */
   util.removeModifier = function (target, modifierName) {
     if (!target.getAttribute('modifier')) {
       return false;
     }

     var modifiers = target.getAttribute('modifier').split(/\s+/);

     var newModifiers = modifiers.filter(function (item) {
       return item && item !== modifierName;
     });
     target.setAttribute('modifier', newModifiers.join(' '));

     return modifiers.length !== newModifiers.length;
   };

   util.updateParentPosition = function (el) {
     if (!el._parentUpdated && el.parentElement) {
       if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
         el.parentElement.style.position = 'relative';
       }
       el._parentUpdated = true;
     }
   };

   util.toggleAttribute = function (element, name, enable) {
     if (enable) {
       element.setAttribute(name, '');
     } else {
       element.removeAttribute(name);
     }
   };

   util.bindListeners = function (element, listenerNames) {
     listenerNames.forEach(function (name) {
       var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
       element[boundName] = element[boundName] || element[name].bind(element);
     });
   };

   util.each = function (obj, f) {
     return Object.keys(obj).forEach(function (key) {
       return f(key, obj[key]);
     });
   };

   var safe = function safe(f) {
     return function () {
       if (f instanceof Function) {
         return f.apply(this, arguments);
       }
     };
   };
   util.safeCall = function (object, prop) {
     for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
       rest[_key2 - 2] = arguments[_key2];
     }

     return safe(object[prop]).apply(object, rest);
   };
   util.safeApply = function (object, prop, rest) {
     return safe(object[prop]).apply(object, rest);
   };

   var isOfType = function isOfType(object, type) {
     if (Array.isArray(type)) {
       return type.some(function (type) {
         return isOfType(object, type);
       });
     }
     if (object === null) {
       return type === 'null';
     }

     try {
       return object instanceof type;
     } catch (e) {
       return typeof type === 'string' && (typeof object === 'undefined' ? 'undefined' : babelHelpers.typeof(object)) === type;
     }
   };

   var _printType = function _printType(type) {
     if (Array.isArray(type)) {
       return type.map(_printType).join(' or ');
     }
     return type instanceof Function && 'an instance of ' + type || type === 'null' && 'null' || typeof type === 'string' && 'a ' + type || JSON.stringify(type);
   };

   /**
    * @param {String} name - name which will be used in the error if the validation fails
    * @param {Function|String|Number|Boolean} object - object to be validated
    * @param {Object} options - validation options or type
    * @param {Array|String|Function} options.type - expected type or array of valid types
    * @param {Array|String|Function} options.returns - expected type of return value of the function
    * @param {Boolean} options.safeCall - if this is true then return a function which calls the `object` argument if it's a function. It will not throw an error it it's not.
    * @param {Object} options.dynamicCall - if this is set then all checks will be completed when trying to execute the resulting function. Furthermore instead of using the `object` argument it will use options.dynamicCall's `object[key]`.
    * @param {Object} options.dynamicCall.object - required if dynamicCall is exists
    * @param {String} options.dynamicCall.key - required if dynamicCall is exists
    * @param {Object} options.context - this is still an experimental setting. Context of the function. Used only with dynamicCall and returns. Defaults to dynamicCall.object.
    * @return validated object
    * @throws Error if the validation fails
    * @example
    *    doge = validated('doge', doge, [Doge, 'string']);
    *    foo = validated('foo', foo, {type: ['number', Array, 'null']});
    *    bar = validated('bar', bar, {type: 'function', safeCall: true});
    *    baz = validated('baz', null, {type: 'function', returns: 'string', dynamicCall: {object: obj, key: 'foo'}});
    *
    *    hoge = validated('hoge', obj, {
    *      type: [Doge, Duck],
    *      object: {
    *        name: 'string',
    *        wow: 'boolean',
    *        walk: {type: 'function', returns: 'boolean'},
    *        talk: {type: 'function', dynamicCall: {object: obj, key: 'quack'}, safeCall: true}
    *      }
    *    });
    *
    * @todo Support for functions with options.object - {type: Function, object: obj}
    */

   var validated = util.validated = function (name, object, options) {
     var type = options && options.type || !options.object && options;
     if (type && !isOfType(object, type) && !(options.dynamicCall || options.safeCall)) {
       throw new Error(name + ' must be ' + _printType(type) + '. You provided ' + object);
     }
     if (options && options.object) {
       var _ret = function () {
         name = name ? name + '.' : '';
         var result = {};
         Object.keys(options.object).forEach(function (key) {
           var dynamicCall = options.object[key].dynamicCall;
           if (dynamicCall) {
             dynamicCall.object = dynamicCall.object || object;
             dynamicCall.key = dynamicCall.key || key;
           }
           result[key] = validated(name + key, object[key], options.object[key]);
         });
         return {
           v: result
         };
       }();

       if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
     }
     if (type === Function || type === 'function') {
       var _ret2 = function () {
         var _ref = options.dynamicCall || {};

         var obj = _ref.object;
         var key = _ref.key;

         var context = options.context || obj;
         var test = options.safeCall ? safe : options.dynamicCall ? function (f) {
           return validated(name, f, Function);
         } : function (f) {
           return f;
         };

         object = options.dynamicCall ? function () {
           for (var _len3 = arguments.length, rest = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
             rest[_key3] = arguments[_key3];
           }

           return test(obj[key]).apply(context, rest);
         } : test(object);

         if (options.returns) {
           return {
             v: function v() {
               for (var _len4 = arguments.length, rest = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                 rest[_key4] = arguments[_key4];
               }

               return validated(name + '\'s result', object.apply(context, rest), options.returns);
             }
           };
         }
       }();

       if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
     }
     return object;
   };

   /**
    * @param {Element} target
    */
   util.updateRipple = function (target) {
     var rippleElement = util.findChild(target, 'ons-ripple');

     if (target.hasAttribute('ripple')) {
       if (!rippleElement) {
         target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
       }
     } else if (rippleElement) {
       rippleElement.remove();
     }
   };

   /**
    * @param {String}
    * @return {Object}
    */
   util.animationOptionsParse = parse;

   /**
    * @param {*} value
    */
   util.isInteger = function (value) {
     return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
   };

   var Event$1;
   var Utils;
   var Detection;
   var PointerEvent;
   /**
    * @object ons.GestureDetector
    * @category gesture
    * @description
    *   [en]Utility class for gesture detection.[/en]
    *   [ja][/ja]
    */

   /**
    * @method constructor
    * @signature constructor(element[, options])
    * @description
    *  [en]Create a new GestureDetector instance.[/en]
    *  [ja]GestureDetector[/ja]
    * @param {Element} element
    *   [en]Name of the event.[/en]
    *   [ja]DOM[/ja]
    * @param {Object} [options]
    *   [en]Options object.[/en]
    *   [ja][/ja]
    * @return {ons.GestureDetector.Instance}
    */
   var GestureDetector = function GestureDetector(element, options) {
     return new GestureDetector.Instance(element, options || {});
   };

   /**
    * default settings.
    * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
    * by setting it's name (like `swipe`) to false.
    * You can set the defaults for all instances by changing this object before creating an instance.
    * @example
    * ````
    *  GestureDetector.defaults.drag = false;
    *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
    *  delete GestureDetector.defaults.behavior.userSelect;
    * ````
    * @property defaults
    * @type {Object}
    */
   GestureDetector.defaults = {
     behavior: {
       // userSelect: 'none', // Also disables selection in `input` children
       touchAction: 'pan-y',
       touchCallout: 'none',
       contentZooming: 'none',
       userDrag: 'none',
       tapHighlightColor: 'rgba(0,0,0,0)'
     }
   };

   /**
    * GestureDetector document where the base events are added at
    * @property DOCUMENT
    * @type {HTMLElement}
    * @default window.document
    */
   GestureDetector.DOCUMENT = document;

   /**
    * detect support for pointer events
    * @property HAS_POINTEREVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

   /**
    * detect support for touch events
    * @property HAS_TOUCHEVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

   /**
    * detect mobile browsers
    * @property IS_MOBILE
    * @type {Boolean}
    */
   GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

   /**
    * detect if we want to support mouseevents at all
    * @property NO_MOUSEEVENTS
    * @type {Boolean}
    */
   GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

   /**
    * interval in which GestureDetector recalculates current velocity/direction/angle in ms
    * @property CALCULATE_INTERVAL
    * @type {Number}
    * @default 25
    */
   GestureDetector.CALCULATE_INTERVAL = 25;

   /**
    * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
    * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
    * @property EVENT_TYPES
    * @private
    * @writeOnce
    * @type {Object}
    */
   var EVENT_TYPES = {};

   /**
    * direction strings, for safe comparisons
    * @property DIRECTION_DOWN|LEFT|UP|RIGHT
    * @final
    * @type {String}
    * @default 'down' 'left' 'up' 'right'
    */
   var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
   var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
   var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
   var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

   /**
    * pointertype strings, for safe comparisons
    * @property POINTER_MOUSE|TOUCH|PEN
    * @final
    * @type {String}
    * @default 'mouse' 'touch' 'pen'
    */
   var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
   var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
   var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

   /**
    * eventtypes
    * @property EVENT_START|MOVE|END|RELEASE|TOUCH
    * @final
    * @type {String}
    * @default 'start' 'change' 'move' 'end' 'release' 'touch'
    */
   var EVENT_START = GestureDetector.EVENT_START = 'start';
   var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
   var EVENT_END = GestureDetector.EVENT_END = 'end';
   var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
   var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

   /**
    * if the window events are set...
    * @property READY
    * @writeOnce
    * @type {Boolean}
    * @default false
    */
   GestureDetector.READY = false;

   /**
    * plugins namespace
    * @property plugins
    * @type {Object}
    */
   GestureDetector.plugins = GestureDetector.plugins || {};

   /**
    * gestures namespace
    * see `/gestures` for the definitions
    * @property gestures
    * @type {Object}
    */
   GestureDetector.gestures = GestureDetector.gestures || {};

   /**
    * setup events to detect gestures on the document
    * this function is called when creating an new instance
    * @private
    */
   function setup() {
     if (GestureDetector.READY) {
       return;
     }

     // find what eventtypes we add listeners to
     Event$1.determineEventTypes();

     // Register all gestures inside GestureDetector.gestures
     Utils.each(GestureDetector.gestures, function (gesture) {
       Detection.register(gesture);
     });

     // Add touch events on the document
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

     // GestureDetector is ready...!
     GestureDetector.READY = true;
   }

   /**
    * @module GestureDetector
    *
    * @class Utils
    * @static
    */
   Utils = GestureDetector.utils = {
     /**
      * extend method, could also be used for cloning when `dest` is an empty object.
      * changes the dest object
      * @param {Object} dest
      * @param {Object} src
      * @param {Boolean} [merge=false]  do a merge
      * @return {Object} dest
      */
     extend: function extend(dest, src, merge) {
       for (var key in src) {
         if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
           dest[key] = src[key];
         }
       }
       return dest;
     },

     /**
      * simple addEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     on: function on(element, type, handler) {
       element.addEventListener(type, handler, false);
     },

     /**
      * simple removeEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     off: function off(element, type, handler) {
       element.removeEventListener(type, handler, false);
     },

     /**
      * forEach over arrays and objects
      * @param {Object|Array} obj
      * @param {Function} iterator
      * @param {any} iterator.item
      * @param {Number} iterator.index
      * @param {Object|Array} iterator.obj the source object
      * @param {Object} context value to use as `this` in the iterator
      */
     each: function each(obj, iterator, context) {
       var i, len;

       // native forEach on arrays
       if ('forEach' in obj) {
         obj.forEach(iterator, context);
         // arrays
       } else if (obj.length !== undefined) {
           for (i = 0, len = obj.length; i < len; i++) {
             if (iterator.call(context, obj[i], i, obj) === false) {
               return;
             }
           }
           // objects
         } else {
             for (i in obj) {
               if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                 return;
               }
             }
           }
     },

     /**
      * find if a string contains the string using indexOf
      * @param {String} src
      * @param {String} find
      * @return {Boolean} found
      */
     inStr: function inStr(src, find) {
       return src.indexOf(find) > -1;
     },

     /**
      * find if a array contains the object using indexOf or a simple polyfill
      * @param {String} src
      * @param {String} find
      * @return {Boolean|Number} false when not found, or the index
      */
     inArray: function inArray(src, find) {
       if (src.indexOf) {
         var index = src.indexOf(find);
         return index === -1 ? false : index;
       } else {
         for (var i = 0, len = src.length; i < len; i++) {
           if (src[i] === find) {
             return i;
           }
         }
         return false;
       }
     },

     /**
      * convert an array-like object (`arguments`, `touchlist`) to an array
      * @param {Object} obj
      * @return {Array}
      */
     toArray: function toArray(obj) {
       return Array.prototype.slice.call(obj, 0);
     },

     /**
      * find if a node is in the given parent
      * @param {HTMLElement} node
      * @param {HTMLElement} parent
      * @return {Boolean} found
      */
     hasParent: function hasParent(node, parent) {
       while (node) {
         if (node == parent) {
           return true;
         }
         node = node.parentNode;
       }
       return false;
     },

     /**
      * get the center of all the touches
      * @param {Array} touches
      * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
      */
     getCenter: function getCenter(touches) {
       var pageX = [],
           pageY = [],
           clientX = [],
           clientY = [],
           min = Math.min,
           max = Math.max;

       // no need to loop when only one touch
       if (touches.length === 1) {
         return {
           pageX: touches[0].pageX,
           pageY: touches[0].pageY,
           clientX: touches[0].clientX,
           clientY: touches[0].clientY
         };
       }

       Utils.each(touches, function (touch) {
         pageX.push(touch.pageX);
         pageY.push(touch.pageY);
         clientX.push(touch.clientX);
         clientY.push(touch.clientY);
       });

       return {
         pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
         pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
         clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
         clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
       };
     },

     /**
      * calculate the velocity between two points. unit is in px per ms.
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      * @return {Object} velocity `x` and `y`
      */
     getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
       return {
         x: Math.abs(deltaX / deltaTime) || 0,
         y: Math.abs(deltaY / deltaTime) || 0
       };
     },

     /**
      * calculate the angle between two coordinates
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {Number} angle
      */
     getAngle: function getAngle(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.atan2(y, x) * 180 / Math.PI;
     },

     /**
      * do a small comparison to get the direction between two touches.
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
      */
     getDirection: function getDirection(touch1, touch2) {
       var x = Math.abs(touch1.clientX - touch2.clientX),
           y = Math.abs(touch1.clientY - touch2.clientY);

       if (x >= y) {
         return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
       }
       return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
     },

     /**
      * calculate the distance between two touches
      * @param {Touch}touch1
      * @param {Touch} touch2
      * @return {Number} distance
      */
     getDistance: function getDistance(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.sqrt(x * x + y * y);
     },

     /**
      * calculate the scale factor between two touchLists
      * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} scale
      */
     getScale: function getScale(start, end) {
       // need two fingers...
       if (start.length >= 2 && end.length >= 2) {
         return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
       }
       return 1;
     },

     /**
      * calculate the rotation degrees between two touchLists
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} rotation
      */
     getRotation: function getRotation(start, end) {
       // need two fingers
       if (start.length >= 2 && end.length >= 2) {
         return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
       }
       return 0;
     },

     /**
      * find out if the direction is vertical   *
      * @param {String} direction matches `DIRECTION_UP|DOWN`
      * @return {Boolean} is_vertical
      */
     isVertical: function isVertical(direction) {
       return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
     },

     /**
      * set css properties with their prefixes
      * @param {HTMLElement} element
      * @param {String} prop
      * @param {String} value
      * @param {Boolean} [toggle=true]
      * @return {Boolean}
      */
     setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
       var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
       prop = Utils.toCamelCase(prop);

       for (var i = 0; i < prefixes.length; i++) {
         var p = prop;
         // prefixes
         if (prefixes[i]) {
           p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
         }

         // test the style
         if (p in element.style) {
           element.style[p] = (toggle === null || toggle) && value || '';
           break;
         }
       }
     },

     /**
      * toggle browser default behavior by setting css properties.
      * `userSelect='none'` also sets `element.onselectstart` to false
      * `userDrag='none'` also sets `element.ondragstart` to false
      *
      * @param {HtmlElement} element
      * @param {Object} props
      * @param {Boolean} [toggle=true]
      */
     toggleBehavior: function toggleBehavior(element, props, toggle) {
       if (!props || !element || !element.style) {
         return;
       }

       // set the css properties
       Utils.each(props, function (value, prop) {
         Utils.setPrefixedCss(element, prop, value, toggle);
       });

       var falseFn = toggle && function () {
         return false;
       };

       // also the disable onselectstart
       if (props.userSelect == 'none') {
         element.onselectstart = falseFn;
       }
       // and disable ondragstart
       if (props.userDrag == 'none') {
         element.ondragstart = falseFn;
       }
     },

     /**
      * convert a string with underscores to camelCase
      * so prevent_default becomes preventDefault
      * @param {String} str
      * @return {String} camelCaseStr
      */
     toCamelCase: function toCamelCase(str) {
       return str.replace(/[_-]([a-z])/g, function (s) {
         return s[1].toUpperCase();
       });
     }
   };

   /**
    * @module GestureDetector
    */
   /**
    * @class Event
    * @static
    */
   Event$1 = GestureDetector.event = {
     /**
      * when touch events have been fired, this is true
      * this is used to stop mouse events
      * @property prevent_mouseevents
      * @private
      * @type {Boolean}
      */
     preventMouseEvents: false,

     /**
      * if EVENT_START has been fired
      * @property started
      * @private
      * @type {Boolean}
      */
     started: false,

     /**
      * when the mouse is hold down, this is true
      * @property should_detect
      * @private
      * @type {Boolean}
      */
     shouldDetect: false,

     /**
      * simple event binder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     on: function on(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.on(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * simple event unbinder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     off: function off(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.off(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * the core touch event handler.
      * this finds out if we should to detect gestures
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Function} handler
      * @return onTouchHandler {Function} the core event handler
      */
     onTouch: function onTouch(element, eventType, handler) {
       var self = this;

       var onTouchHandler = function onTouchHandler(ev) {
         var srcType = ev.type.toLowerCase(),
             isPointer = GestureDetector.HAS_POINTEREVENTS,
             isMouse = Utils.inStr(srcType, 'mouse'),
             triggerType;

         // if we are in a mouseevent, but there has been a touchevent triggered in this session
         // we want to do nothing. simply break out of the event.
         if (isMouse && self.preventMouseEvents) {
           return;

           // mousebutton must be down
         } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
             self.preventMouseEvents = false;
             self.shouldDetect = true;
           } else if (isPointer && eventType == EVENT_START) {
             self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
             // just a valid start event, but no mouse
           } else if (!isMouse && eventType == EVENT_START) {
               self.preventMouseEvents = true;
               self.shouldDetect = true;
             }

         // update the pointer event before entering the detection
         if (isPointer && eventType != EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }

         // we are in a touch/down state, so allowed detection of gestures
         if (self.shouldDetect) {
           triggerType = self.doDetect.call(self, ev, eventType, element, handler);
         }

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         if (triggerType == EVENT_END) {
           self.preventMouseEvents = false;
           self.shouldDetect = false;
           PointerEvent.reset();
           // update the pointerevent object after the detection
         }

         if (isPointer && eventType == EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }
       };

       this.on(element, EVENT_TYPES[eventType], onTouchHandler);
       return onTouchHandler;
     },

     /**
      * the core detection method
      * this finds out what GestureDetector-touch-events to trigger
      * @param {Object} ev
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {HTMLElement} element
      * @param {Function} handler
      * @return {String} triggerType matches `EVENT_START|MOVE|END`
      */
     doDetect: function doDetect(ev, eventType, element, handler) {
       var touchList = this.getTouchList(ev, eventType);
       var touchListLength = touchList.length;
       var triggerType = eventType;
       var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
       var changedLength = touchListLength;

       // at each touchstart-like event we want also want to trigger a TOUCH event...
       if (eventType == EVENT_START) {
         triggerChange = EVENT_TOUCH;
         // ...the same for a touchend-like event
       } else if (eventType == EVENT_END) {
           triggerChange = EVENT_RELEASE;

           // keep track of how many touches have been removed
           changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
         }

       // after there are still touches on the screen,
       // we just want to trigger a MOVE event. so change the START or END to a MOVE
       // but only after detection has been started, the first time we actually want a START
       if (changedLength > 0 && this.started) {
         triggerType = EVENT_MOVE;
       }

       // detection has been started, we keep track of this, see above
       this.started = true;

       // generate some event data, some basic information
       var evData = this.collectEventData(element, triggerType, touchList, ev);

       // trigger the triggerType event before the change (TOUCH, RELEASE) events
       // but the END event should be at last
       if (eventType != EVENT_END) {
         handler.call(Detection, evData);
       }

       // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
       if (triggerChange) {
         evData.changedLength = changedLength;
         evData.eventType = triggerChange;

         handler.call(Detection, evData);

         evData.eventType = triggerType;
         delete evData.changedLength;
       }

       // trigger the END event
       if (triggerType == EVENT_END) {
         handler.call(Detection, evData);

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         this.started = false;
       }

       return triggerType;
     },

     /**
      * we have different events for each device/browser
      * determine what we need and set them in the EVENT_TYPES constant
      * the `onTouch` method is bind to these properties.
      * @return {Object} events
      */
     determineEventTypes: function determineEventTypes() {
       var types;
       if (GestureDetector.HAS_POINTEREVENTS) {
         if (window.PointerEvent) {
           types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
         } else {
           types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
         }
       } else if (GestureDetector.NO_MOUSEEVENTS) {
         types = ['touchstart', 'touchmove', 'touchend touchcancel'];
       } else {
         types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
       }

       EVENT_TYPES[EVENT_START] = types[0];
       EVENT_TYPES[EVENT_MOVE] = types[1];
       EVENT_TYPES[EVENT_END] = types[2];
       return EVENT_TYPES;
     },

     /**
      * create touchList depending on the event
      * @param {Object} ev
      * @param {String} eventType
      * @return {Array} touches
      */
     getTouchList: function getTouchList(ev, eventType) {
       // get the fake pointerEvent touchlist
       if (GestureDetector.HAS_POINTEREVENTS) {
         return PointerEvent.getTouchList();
       }

       // get the touchlist
       if (ev.touches) {
         if (eventType == EVENT_MOVE) {
           return ev.touches;
         }

         var identifiers = [];
         var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
         var touchList = [];

         Utils.each(concat, function (touch) {
           if (Utils.inArray(identifiers, touch.identifier) === false) {
             touchList.push(touch);
           }
           identifiers.push(touch.identifier);
         });

         return touchList;
       }

       // make fake touchList from mouse position
       ev.identifier = 1;
       return [ev];
     },

     /**
      * collect basic event data
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Array} touches
      * @param {Object} ev
      * @return {Object} ev
      */
     collectEventData: function collectEventData(element, eventType, touches, ev) {
       // find out pointerType
       var pointerType = POINTER_TOUCH;
       if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
         pointerType = POINTER_MOUSE;
       } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
         pointerType = POINTER_PEN;
       }

       return {
         center: Utils.getCenter(touches),
         timeStamp: Date.now(),
         target: ev.target,
         touches: touches,
         eventType: eventType,
         pointerType: pointerType,
         srcEvent: ev,

         /**
          * prevent the browser default actions
          * mostly used to disable scrolling of the browser
          */
         preventDefault: function preventDefault() {
           var srcEvent = this.srcEvent;
           srcEvent.preventManipulation && srcEvent.preventManipulation();
           srcEvent.preventDefault && srcEvent.preventDefault();
         },

         /**
          * stop bubbling the event up to its parents
          */
         stopPropagation: function stopPropagation() {
           this.srcEvent.stopPropagation();
         },

         /**
          * immediately stop gesture detection
          * might be useful after a swipe was detected
          * @return {*}
          */
         stopDetect: function stopDetect() {
           return Detection.stopDetect();
         }
       };
     }
   };

   /**
    * @module GestureDetector
    *
    * @class PointerEvent
    * @static
    */
   PointerEvent = GestureDetector.PointerEvent = {
     /**
      * holds all pointers, by `identifier`
      * @property pointers
      * @type {Object}
      */
     pointers: {},

     /**
      * get the pointers as an array
      * @return {Array} touchlist
      */
     getTouchList: function getTouchList() {
       var touchlist = [];
       // we can use forEach since pointerEvents only is in IE10
       Utils.each(this.pointers, function (pointer) {
         touchlist.push(pointer);
       });
       return touchlist;
     },

     /**
      * update the position of a pointer
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Object} pointerEvent
      */
     updatePointer: function updatePointer(eventType, pointerEvent) {
       if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
         delete this.pointers[pointerEvent.pointerId];
       } else {
         pointerEvent.identifier = pointerEvent.pointerId;
         this.pointers[pointerEvent.pointerId] = pointerEvent;
       }
     },

     /**
      * check if ev matches pointertype
      * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
      * @param {PointerEvent} ev
      */
     matchType: function matchType(pointerType, ev) {
       if (!ev.pointerType) {
         return false;
       }

       var pt = ev.pointerType,
           types = {};

       types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
       types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
       types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
       return types[pointerType];
     },

     /**
      * reset the stored pointers
      */
     reset: function resetList() {
       this.pointers = {};
     }
   };

   /**
    * @module GestureDetector
    *
    * @class Detection
    * @static
    */
   Detection = GestureDetector.detection = {
     // contains all registered GestureDetector.gestures in the correct order
     gestures: [],

     // data of the current GestureDetector.gesture detection session
     current: null,

     // the previous GestureDetector.gesture session data
     // is a full clone of the previous gesture.current object
     previous: null,

     // when this becomes true, no gestures are fired
     stopped: false,

     /**
      * start GestureDetector.gesture detection
      * @param {GestureDetector.Instance} inst
      * @param {Object} eventData
      */
     startDetect: function startDetect(inst, eventData) {
       // already busy with a GestureDetector.gesture detection on an element
       if (this.current) {
         return;
       }

       this.stopped = false;

       // holds current session
       this.current = {
         inst: inst, // reference to GestureDetectorInstance we're working for
         startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
         lastEvent: false, // last eventData
         lastCalcEvent: false, // last eventData for calculations.
         futureCalcEvent: false, // last eventData for calculations.
         lastCalcData: {}, // last lastCalcData
         name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
       };

       this.detect(eventData);
     },

     /**
      * GestureDetector.gesture detection
      * @param {Object} eventData
      * @return {any}
      */
     detect: function detect(eventData) {
       if (!this.current || this.stopped) {
         return;
       }

       // extend event data with calculations about scale, distance etc
       eventData = this.extendEventData(eventData);

       // GestureDetector instance and instance options
       var inst = this.current.inst,
           instOptions = inst.options;

       // call GestureDetector.gesture handlers
       Utils.each(this.gestures, function triggerGesture(gesture) {
         // only when the instance options have enabled this gesture
         if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
           gesture.handler.call(gesture, eventData, inst);
         }
       }, this);

       // store as previous event event
       if (this.current) {
         this.current.lastEvent = eventData;
       }

       if (eventData.eventType == EVENT_END) {
         this.stopDetect();
       }

       return eventData; // eslint-disable-line consistent-return
     },

     /**
      * clear the GestureDetector.gesture vars
      * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
      * to stop other GestureDetector.gestures from being fired
      */
     stopDetect: function stopDetect() {
       // clone current data to the store as the previous gesture
       // used for the double tap gesture, since this is an other gesture detect session
       this.previous = Utils.extend({}, this.current);

       // reset the current
       this.current = null;
       this.stopped = true;
     },

     /**
      * calculate velocity, angle and direction
      * @param {Object} ev
      * @param {Object} center
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      */
     getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
       var cur = this.current,
           recalc = false,
           calcEv = cur.lastCalcEvent,
           calcData = cur.lastCalcData;

       if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
         center = calcEv.center;
         deltaTime = ev.timeStamp - calcEv.timeStamp;
         deltaX = ev.center.clientX - calcEv.center.clientX;
         deltaY = ev.center.clientY - calcEv.center.clientY;
         recalc = true;
       }

       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         cur.futureCalcEvent = ev;
       }

       if (!cur.lastCalcEvent || recalc) {
         calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
         calcData.angle = Utils.getAngle(center, ev.center);
         calcData.direction = Utils.getDirection(center, ev.center);

         cur.lastCalcEvent = cur.futureCalcEvent || ev;
         cur.futureCalcEvent = ev;
       }

       ev.velocityX = calcData.velocity.x;
       ev.velocityY = calcData.velocity.y;
       ev.interimAngle = calcData.angle;
       ev.interimDirection = calcData.direction;
     },

     /**
      * extend eventData for GestureDetector.gestures
      * @param {Object} ev
      * @return {Object} ev
      */
     extendEventData: function extendEventData(ev) {
       var cur = this.current,
           startEv = cur.startEvent,
           lastEv = cur.lastEvent || startEv;

       // update the start touchlist to calculate the scale/rotation
       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         startEv.touches = [];
         Utils.each(ev.touches, function (touch) {
           startEv.touches.push({
             clientX: touch.clientX,
             clientY: touch.clientY
           });
         });
       }

       var deltaTime = ev.timeStamp - startEv.timeStamp,
           deltaX = ev.center.clientX - startEv.center.clientX,
           deltaY = ev.center.clientY - startEv.center.clientY;

       this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

       Utils.extend(ev, {
         startEvent: startEv,

         deltaTime: deltaTime,
         deltaX: deltaX,
         deltaY: deltaY,

         distance: Utils.getDistance(startEv.center, ev.center),
         angle: Utils.getAngle(startEv.center, ev.center),
         direction: Utils.getDirection(startEv.center, ev.center),
         scale: Utils.getScale(startEv.touches, ev.touches),
         rotation: Utils.getRotation(startEv.touches, ev.touches)
       });

       return ev;
     },

     /**
      * register new gesture
      * @param {Object} gesture object, see `gestures/` for documentation
      * @return {Array} gestures
      */
     register: function register(gesture) {
       // add an enable gesture options if there is no given
       var options = gesture.defaults || {};
       if (options[gesture.name] === undefined) {
         options[gesture.name] = true;
       }

       // extend GestureDetector default options with the GestureDetector.gesture options
       Utils.extend(GestureDetector.defaults, options, true);

       // set its index
       gesture.index = gesture.index || 1000;

       // add GestureDetector.gesture to the list
       this.gestures.push(gesture);

       // sort the list by index
       this.gestures.sort(function (a, b) {
         if (a.index < b.index) {
           return -1;
         }
         if (a.index > b.index) {
           return 1;
         }
         return 0;
       });

       return this.gestures;
     }
   };

   /**
    * @module GestureDetector
    */

   /**
    * create new GestureDetector instance
    * all methods should return the instance itself, so it is chainable.
    *
    * @class Instance
    * @constructor
    * @param {HTMLElement} element
    * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
    * @return {GestureDetector.Instance}
    */
   GestureDetector.Instance = function (element, options) {
     var self = this;

     // setup GestureDetectorJS window events and register all gestures
     // this also sets up the default options
     setup();

     /**
      * @property element
      * @type {HTMLElement}
      */
     this.element = element;

     /**
      * @property enabled
      * @type {Boolean}
      * @protected
      */
     this.enabled = true;

     /**
      * options, merged with the defaults
      * options with an _ are converted to camelCase
      * @property options
      * @type {Object}
      */
     Utils.each(options, function (value, name) {
       delete options[name];
       options[Utils.toCamelCase(name)] = value;
     });

     this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

     // add some css to the element to prevent the browser from doing its native behavior
     if (this.options.behavior) {
       Utils.toggleBehavior(this.element, this.options.behavior, true);
     }

     /**
      * event start handler on the element to start the detection
      * @property eventStartHandler
      * @type {Object}
      */
     this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
       if (self.enabled && ev.eventType == EVENT_START) {
         Detection.startDetect(self, ev);
       } else if (ev.eventType == EVENT_TOUCH) {
         Detection.detect(ev);
       }
     });

     /**
      * keep a list of user event handlers which needs to be removed when calling 'dispose'
      * @property eventHandlers
      * @type {Array}
      */
     this.eventHandlers = [];
   };

   GestureDetector.Instance.prototype = {
     /**
      * @method on
      * @signature on(gestures, handler)
      * @description
      *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
      *  [ja]drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate [/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     on: function onEvent(gestures, handler) {
       var self = this;
       Event$1.on(self.element, gestures, handler, function (type) {
         self.eventHandlers.push({ gesture: type, handler: handler });
       });
       return self;
     },

     /**
      * @method off
      * @signature off(gestures, handler)
      * @description
      *  [en]Remove an event listener.[/en]
      *  [ja][/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     off: function offEvent(gestures, handler) {
       var self = this;

       Event$1.off(self.element, gestures, handler, function (type) {
         var index = Utils.inArray({ gesture: type, handler: handler });
         if (index !== false) {
           self.eventHandlers.splice(index, 1);
         }
       });
       return self;
     },

     /**
      * trigger gesture event
      * @method trigger
      * @signature trigger(gesture, eventData)
      * @param {String} gesture
      * @param {Object} [eventData]
      */
     trigger: function triggerEvent(gesture, eventData) {
       // optional
       if (!eventData) {
         eventData = {};
       }

       // create DOM event
       var event = GestureDetector.DOCUMENT.createEvent('Event');
       event.initEvent(gesture, true, true);
       event.gesture = eventData;

       // trigger on the target if it is in the instance element,
       // this is for event delegation tricks
       var element = this.element;
       if (Utils.hasParent(eventData.target, element)) {
         element = eventData.target;
       }

       element.dispatchEvent(event);
       return this;
     },

     /**
      * @method enable
      * @signature enable(state)
      * @description
      *  [en]Enable or disable gesture detection.[/en]
      *  [ja]/[/ja]
      * @param {Boolean} state
      *   [en]Specify if it should be enabled or not.[/en]
      *   [ja][/ja]
      */
     enable: function enable(state) {
       this.enabled = state;
       return this;
     },

     /**
      * @method dispose
      * @signature dispose()
      * @description
      *  [en]Remove and destroy all event handlers for this instance.[/en]
      *  [ja][/ja]
      */
     dispose: function dispose() {
       var i, eh;

       // undo all changes made by stop_browser_behavior
       Utils.toggleBehavior(this.element, this.options.behavior, false);

       // unbind all custom event handlers
       for (i = -1; eh = this.eventHandlers[++i];) {
         // eslint-disable-line no-cond-assign
         Utils.off(this.element, eh.gesture, eh.handler);
       }

       this.eventHandlers = [];

       // unbind the start event listener
       Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

       return null;
     }
   };

   /**
    * @module gestures
    */
   /**
    * Move with x fingers (default 1) around on the page.
    * Preventing the default browser behavior is a good way to improve feel and working.
    * ````
    *  GestureDetectortime.on("drag", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Drag
    * @static
    */
   /**
    * @event drag
    * @param {Object} ev
    */
   /**
    * @event dragstart
    * @param {Object} ev
    */
   /**
    * @event dragend
    * @param {Object} ev
    */
   /**
    * @event drapleft
    * @param {Object} ev
    */
   /**
    * @event dragright
    * @param {Object} ev
    */
   /**
    * @event dragup
    * @param {Object} ev
    */
   /**
    * @event dragdown
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function dragGesture(ev, inst) {
       var cur = Detection.current;

       // max touches
       if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
         return;
       }

       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
             return;
           }

           var startCenter = cur.startEvent.center;

           // we are dragging!
           if (cur.name != name) {
             cur.name = name;
             if (inst.options.dragDistanceCorrection && ev.distance > 0) {
               // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
               // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
               // It might be useful to save the original start point somewhere
               var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
               startCenter.pageX += ev.deltaX * factor;
               startCenter.pageY += ev.deltaY * factor;
               startCenter.clientX += ev.deltaX * factor;
               startCenter.clientY += ev.deltaY * factor;

               // recalculate event data using new start point
               ev = Detection.extendEventData(ev);
             }
           }

           // lock drag to axis?
           if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
             ev.dragLockToAxis = true;
           }

           // keep direction on the axis that the drag gesture started on
           var lastDirection = cur.lastEvent.direction;
           if (ev.dragLockToAxis && lastDirection !== ev.direction) {
             if (Utils.isVertical(lastDirection)) {
               ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
             } else {
               ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
             }
           }

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           // trigger events
           inst.trigger(name, ev);
           inst.trigger(name + ev.direction, ev);

           var isVertical = Utils.isVertical(ev.direction);

           // block the browser events
           if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
             ev.preventDefault();
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;

         case EVENT_END:
           triggered = false;
           break;
       }
     }

     GestureDetector.gestures.Drag = {
       name: name,
       index: 50,
       handler: dragGesture,
       defaults: {
         /**
          * minimal movement that have to be made before the drag event gets triggered
          * @property dragMinDistance
          * @type {Number}
          * @default 10
          */
         dragMinDistance: 10,

         /**
          * Set dragDistanceCorrection to true to make the starting point of the drag
          * be calculated from where the drag was triggered, not from where the touch started.
          * Useful to avoid a jerk-starting drag, which can make fine-adjustments
          * through dragging difficult, and be visually unappealing.
          * @property dragDistanceCorrection
          * @type {Boolean}
          * @default true
          */
         dragDistanceCorrection: true,

         /**
          * set 0 for unlimited, but this can conflict with transform
          * @property dragMaxTouches
          * @type {Number}
          * @default 1
          */
         dragMaxTouches: 1,

         /**
          * prevent default browser behavior when dragging occurs
          * be careful with it, it makes the element a blocking element
          * when you are using the drag gesture, it is a good practice to set this true
          * @property dragBlockHorizontal
          * @type {Boolean}
          * @default false
          */
         dragBlockHorizontal: false,

         /**
          * same as `dragBlockHorizontal`, but for vertical movement
          * @property dragBlockVertical
          * @type {Boolean}
          * @default false
          */
         dragBlockVertical: false,

         /**
          * dragLockToAxis keeps the drag gesture on the axis that it started on,
          * It disallows vertical directions if the initial direction was horizontal, and vice versa.
          * @property dragLockToAxis
          * @type {Boolean}
          * @default false
          */
         dragLockToAxis: false,

         /**
          * drag lock only kicks in when distance > dragLockMinDistance
          * This way, locking occurs only when the distance has become large enough to reliably determine the direction
          * @property dragLockMinDistance
          * @type {Number}
          * @default 25
          */
         dragLockMinDistance: 25
       }
     };
   })('drag');

   /**
    * @module gestures
    */
   /**
    * trigger a simple gesture event, so you can do anything in your handler.
    * only usable if you know what your doing...
    *
    * @class Gesture
    * @static
    */
   /**
    * @event gesture
    * @param {Object} ev
    */
   GestureDetector.gestures.Gesture = {
     name: 'gesture',
     index: 1337,
     handler: function releaseGesture(ev, inst) {
       inst.trigger(this.name, ev);
     }
   };

   /**
    * @module gestures
    */
   /**
    * Touch stays at the same place for x time
    *
    * @class Hold
    * @static
    */
   /**
    * @event hold
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var timer;

     function holdGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current;

       switch (ev.eventType) {
         case EVENT_START:
           clearTimeout(timer);

           // set the gesture so we can check in the timeout if it still is
           current.name = name;

           // set timer and if after the timeout it still is hold,
           // we trigger the hold event
           timer = setTimeout(function () {
             if (current && current.name == name) {
               inst.trigger(name, ev);
             }
           }, options.holdTimeout);
           break;

         case EVENT_MOVE:
           if (ev.distance > options.holdThreshold) {
             clearTimeout(timer);
           }
           break;

         case EVENT_RELEASE:
           clearTimeout(timer);
           break;
       }
     }

     GestureDetector.gestures.Hold = {
       name: name,
       index: 10,
       defaults: {
         /**
          * @property holdTimeout
          * @type {Number}
          * @default 500
          */
         holdTimeout: 500,

         /**
          * movement allowed while holding
          * @property holdThreshold
          * @type {Number}
          * @default 2
          */
         holdThreshold: 2
       },
       handler: holdGesture
     };
   })('hold');

   /**
    * @module gestures
    */
   /**
    * when a touch is being released from the page
    *
    * @class Release
    * @static
    */
   /**
    * @event release
    * @param {Object} ev
    */
   GestureDetector.gestures.Release = {
     name: 'release',
     index: Infinity,
     handler: function releaseGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         inst.trigger(this.name, ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * triggers swipe events when the end velocity is above the threshold
    * for best usage, set `preventDefault` (on the drag gesture) to `true`
    * ````
    *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Swipe
    * @static
    */
   /**
    * @event swipe
    * @param {Object} ev
    */
   /**
    * @event swipeleft
    * @param {Object} ev
    */
   /**
    * @event swiperight
    * @param {Object} ev
    */
   /**
    * @event swipeup
    * @param {Object} ev
    */
   /**
    * @event swipedown
    * @param {Object} ev
    */
   GestureDetector.gestures.Swipe = {
     name: 'swipe',
     index: 40,
     defaults: {
       /**
        * @property swipeMinTouches
        * @type {Number}
        * @default 1
        */
       swipeMinTouches: 1,

       /**
        * @property swipeMaxTouches
        * @type {Number}
        * @default 1
        */
       swipeMaxTouches: 1,

       /**
        * horizontal swipe velocity
        * @property swipeVelocityX
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityX: 0.6,

       /**
        * vertical swipe velocity
        * @property swipeVelocityY
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityY: 0.6
     },

     handler: function swipeGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         var touches = ev.touches.length,
             options = inst.options;

         // max touches
         if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
           return;
         }

         // when the distance we moved is too small we skip this gesture
         // or we can be already in dragging
         if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
           // trigger swipe events
           inst.trigger(this.name, ev);
           inst.trigger(this.name + ev.direction, ev);
         }
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * Single tap and a double tap on a place
    *
    * @class Tap
    * @static
    */
   /**
    * @event tap
    * @param {Object} ev
    */
   /**
    * @event doubletap
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var hasMoved = false;

     function tapGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current,
           prev = Detection.previous,
           sincePrev,
           didDoubleTap;

       switch (ev.eventType) {
         case EVENT_START:
           hasMoved = false;
           break;

         case EVENT_MOVE:
           hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
           break;

         case EVENT_END:
           if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
             // previous gesture, for the double tap since these are two different gesture detections
             sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
             didDoubleTap = false;

             // check if double tap
             if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
               inst.trigger('doubletap', ev);
               didDoubleTap = true;
             }

             // do a single tap
             if (!didDoubleTap || options.tapAlways) {
               current.name = name;
               inst.trigger(current.name, ev);
             }
           }
           break;
       }
     }

     GestureDetector.gestures.Tap = {
       name: name,
       index: 100,
       handler: tapGesture,
       defaults: {
         /**
          * max time of a tap, this is for the slow tappers
          * @property tapMaxTime
          * @type {Number}
          * @default 250
          */
         tapMaxTime: 250,

         /**
          * max distance of movement of a tap, this is for the slow tappers
          * @property tapMaxDistance
          * @type {Number}
          * @default 10
          */
         tapMaxDistance: 10,

         /**
          * always trigger the `tap` event, even while double-tapping
          * @property tapAlways
          * @type {Boolean}
          * @default true
          */
         tapAlways: true,

         /**
          * max distance between two taps
          * @property doubleTapDistance
          * @type {Number}
          * @default 20
          */
         doubleTapDistance: 20,

         /**
          * max time between two taps
          * @property doubleTapInterval
          * @type {Number}
          * @default 300
          */
         doubleTapInterval: 300
       }
     };
   })('tap');

   /**
    * @module gestures
    */
   /**
    * when a touch is being touched at the page
    *
    * @class Touch
    * @static
    */
   /**
    * @event touch
    * @param {Object} ev
    */
   GestureDetector.gestures.Touch = {
     name: 'touch',
     index: -Infinity,
     defaults: {
       /**
        * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
        * but it improves gestures like transforming and dragging.
        * be careful with using this, it can be very annoying for users to be stuck on the page
        * @property preventDefault
        * @type {Boolean}
        * @default false
        */
       preventDefault: false,

       /**
        * disable mouse events, so only touch (or pen!) input triggers events
        * @property preventMouse
        * @type {Boolean}
        * @default false
        */
       preventMouse: false
     },
     handler: function touchGesture(ev, inst) {
       if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
         ev.stopDetect();
         return;
       }

       if (inst.options.preventDefault) {
         ev.preventDefault();
       }

       if (ev.eventType == EVENT_TOUCH) {
         inst.trigger('touch', ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * User want to scale or rotate with 2 fingers
    * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
    * `preventDefault` option.
    *
    * @class Transform
    * @static
    */
   /**
    * @event transform
    * @param {Object} ev
    */
   /**
    * @event transformstart
    * @param {Object} ev
    */
   /**
    * @event transformend
    * @param {Object} ev
    */
   /**
    * @event pinchin
    * @param {Object} ev
    */
   /**
    * @event pinchout
    * @param {Object} ev
    */
   /**
    * @event rotate
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function transformGesture(ev, inst) {
       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // at least multitouch
           if (ev.touches.length < 2) {
             return;
           }

           var scaleThreshold = Math.abs(1 - ev.scale);
           var rotationThreshold = Math.abs(ev.rotation);

           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
             return;
           }

           // we are transforming!
           Detection.current.name = name;

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           inst.trigger(name, ev); // basic transform event

           // trigger rotate event
           if (rotationThreshold > inst.options.transformMinRotation) {
             inst.trigger('rotate', ev);
           }

           // trigger pinch event
           if (scaleThreshold > inst.options.transformMinScale) {
             inst.trigger('pinch', ev);
             inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength < 2) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;
       }
     }

     GestureDetector.gestures.Transform = {
       name: name,
       index: 45,
       defaults: {
         /**
          * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
          * @property transformMinScale
          * @type {Number}
          * @default 0.01
          */
         transformMinScale: 0.01,

         /**
          * rotation in degrees
          * @property transformMinRotation
          * @type {Number}
          * @default 1
          */
         transformMinRotation: 1
       },

       handler: transformGesture
     };
   })('transform');

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @object ons.platform
    * @category util
    * @description
    *   [en]Utility methods to detect current platform.[/en]
    *   [ja][/ja]
    */

   var Platform = function () {

     /**
      * All elements will be rendered as if the app was running on this platform.
      * @type {String}
      */

     function Platform() {
       babelHelpers.classCallCheck(this, Platform);

       this._renderPlatform = null;
     }

     /**
      * @method select
      * @signature select(platform)
      * @param  {string} platform Name of the platform.
      *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
      *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"[/ja]
      * @description
      *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
      *   [ja][/ja]
      */


     babelHelpers.createClass(Platform, [{
       key: 'select',
       value: function select(platform) {
         if (typeof platform === 'string') {
           this._renderPlatform = platform.trim().toLowerCase();
         }
       }

       /**
        * @method isWebView
        * @signature isWebView()
        * @description
        *   [en]Returns whether app is running in Cordova.[/en]
        *   [ja]Cordova[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isWebView',
       value: function isWebView() {
         if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
           throw new Error('isWebView() method is available after dom contents loaded.');
         }

         return !!(window.cordova || window.phonegap || window.PhoneGap);
       }

       /**
        * @method isIOS
        * @signature isIOS()
        * @description
        *   [en]Returns whether the OS is iOS.[/en]
        *   [ja]iOS[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS',
       value: function isIOS() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ios';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform)
           );
         } else {
           return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroid
        * @signature isAndroid()
        * @description
        *   [en]Returns whether the OS is Android.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroid',
       value: function isAndroid() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'android';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Android/i.test(device.platform)
           );
         } else {
           return (/Android/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroidPhone
        * @signature isAndroidPhone()
        * @description
        *   [en]Returns whether the device is Android phone.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidPhone',
       value: function isAndroidPhone() {
         return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isAndroidTablet
        * @signature isAndroidTablet()
        * @description
        *   [en]Returns whether the device is Android tablet.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidTablet',
       value: function isAndroidTablet() {
         return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isWP',
       value: function isWP() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'wp';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Win32NT|WinCE/i.test(device.platform)
           );
         } else {
           return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @methos isIPhone
        * @signature isIPhone()
        * @description
        *   [en]Returns whether the device is iPhone.[/en]
        *   [ja]iPhone[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPhone',
       value: function isIPhone() {
         return (/iPhone/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isIPad
        * @signature isIPad()
        * @description
        *   [en]Returns whether the device is iPad.[/en]
        *   [ja]iPad[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPad',
       value: function isIPad() {
         return (/iPad/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isIPod',
       value: function isIPod() {
         return (/iPod/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isBlackBerry
        * @signature isBlackBerry()
        * @description
        *   [en]Returns whether the device is BlackBerry.[/en]
        *   [ja]BlackBerry[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isBlackBerry',
       value: function isBlackBerry() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'blackberry';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/BlackBerry/i.test(device.platform)
           );
         } else {
           return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isOpera
        * @signature isOpera()
        * @description
        *   [en]Returns whether the browser is Opera.[/en]
        *   [ja]Opera[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isOpera',
       value: function isOpera() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'opera';
         } else {
           return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
         }
       }

       /**
        * @method isFirefox
        * @signature isFirefox()
        * @description
        *   [en]Returns whether the browser is Firefox.[/en]
        *   [ja]Firefox[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isFirefox',
       value: function isFirefox() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'firefox';
         } else {
           return typeof InstallTrigger !== 'undefined';
         }
       }

       /**
        * @method isSafari
        * @signature isSafari()
        * @description
        *   [en]Returns whether the browser is Safari.[/en]
        *   [ja]Safari[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isSafari',
       value: function isSafari() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'safari';
         } else {
           return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
         }
       }

       /**
        * @method isChrome
        * @signature isChrome()
        * @description
        *   [en]Returns whether the browser is Chrome.[/en]
        *   [ja]Chrome[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isChrome',
       value: function isChrome() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'chrome';
         } else {
           return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
         }
       }

       /**
        * @method isIE
        * @signature isIE()
        * @description
        *   [en]Returns whether the browser is Internet Explorer.[/en]
        *   [ja]Internet Explorer[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIE',
       value: function isIE() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ie';
         } else {
           return false || !!document.documentMode;
         }
       }

       /**
        * @method isEdge
        * @signature isEdge()
        * @description
        *   [en]Returns whether the browser is Edge.[/en]
        *   [ja]Edge[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isEdge',
       value: function isEdge() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'edge';
         } else {
           return navigator.userAgent.indexOf(' Edge/') >= 0;
         }
       }

       /**
        * @method isIOS7above
        * @signature isIOS7above()
        * @description
        *   [en]Returns whether the iOS version is 7 or above.[/en]
        *   [ja]iOS7[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS7above',
       value: function isIOS7above() {
         if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
           );
         } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
           var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
           return parseInt(ver.split('.')[0]) >= 7;
         }
         return false;
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getMobileOS',
       value: function getMobileOS() {
         if (this.isAndroid()) {
           return 'android';
         } else if (this.isIOS()) {
           return 'ios';
         } else if (this.isWP()) {
           return 'wp';
         } else {
           return 'other';
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getIOSDevice',
       value: function getIOSDevice() {
         if (this.isIPhone()) {
           return 'iphone';
         } else if (this.isIPad()) {
           return 'ipad';
         } else if (this.isIPod()) {
           return 'ipod';
         } else {
           return 'na';
         }
       }
     }]);
     return Platform;
   }();

   var platform = new Platform();

   /**
    * @object ons.notification
    * @category dialog
    * @codepen Qwwxyp
    * @description
    *   [en]
    *     Utility methods to create different kinds of alert dialogs. There are three methods available:
    *
    *     * `ons.notification.alert()`
    *     * `ons.notification.confirm()`
    *     * `ons.notification.prompt()`
    *
    *     It will automatically display a Material Design dialog on Android devices.
    *   [ja][/ja]
    * @example
    * ons.notification.alert('Hello, world!');
    *
    * ons.notification.confirm('Are you ready?')
    *   .then(
    *     function(answer) {
    *       if (answer === 1) {
    *         ons.notification.alert('Let\'s go!');
    *       }
    *     }
    *   );
    *
    * ons.notification.prompt('How old are ?')
    *   .then(
    *     function(age) {
    *       ons.notification.alert('You are ' + age + ' years old.');
    *     }
    *   );
    */
   var notification = {};

   notification._createAlertDialog = function (title, message, buttonLabels, primaryButtonIndex, modifier, animation, id, _callback, messageIsHTML, cancelable, promptDialog, autofocus, placeholder, defaultValue, submitOnEnter, compile) {

     compile = compile || function (object) {
       return object;
     };

     var titleElementHTML = typeof title === 'string' ? '<div class="alert-dialog-title"></div>' : '';

     var dialogElement = util.createElement('\n  <ons-alert-dialog>\n    ' + titleElementHTML + '\n    <div class="alert-dialog-content"></div>\n    <div class="alert-dialog-footer"></div>\n  </ons-alert-dialog>');

     CustomElements.upgrade(dialogElement);

     if (id) {
       dialogElement.setAttribute('id', id);
     }

     var titleElement = dialogElement.querySelector('.alert-dialog-title');
     var messageElement = dialogElement.querySelector('.alert-dialog-content');
     var footerElement = dialogElement.querySelector('.alert-dialog-footer');
     var inputElement = void 0;
     var result = {};

     result.promise = new Promise(function (resolve, reject) {
       result.resolve = resolve;
       result.reject = reject;
     });

     modifier = modifier || dialogElement.getAttribute('modifier');

     if (typeof title === 'string') {
       titleElement.textContent = title;
     }

     titleElement = null;

     dialogElement.setAttribute('animation', animation);

     if (messageIsHTML) {
       messageElement.innerHTML = message;
     } else {
       messageElement.textContent = message;
     }

     if (promptDialog) {
       inputElement = util.createElement('<input class="text-input text-input--underbar" type="text"></input>');

       if (modifier) {
         inputElement.classList.add('text-input--' + modifier);
       }

       inputElement.setAttribute('placeholder', placeholder);
       inputElement.value = defaultValue;
       inputElement.style.width = '100%';
       inputElement.style.marginTop = '10px';

       messageElement.appendChild(inputElement);

       if (submitOnEnter) {
         inputElement.addEventListener('keypress', function (event) {
           if (event.keyCode === 13) {
             dialogElement.hide({
               callback: function callback() {
                 _callback(inputElement.value);
                 result.resolve(inputElement.value);
                 dialogElement.remove();
                 dialogElement = null;
               }
             });
           }
         }, false);
       }
     }

     document.body.appendChild(dialogElement);

     compile(dialogElement);

     if (buttonLabels.length <= 2) {
       footerElement.classList.add('alert-dialog-footer--one');
     }

     var createButton = function createButton(i) {
       var buttonElement = util.createElement('<button class="alert-dialog-button"></button>');
       buttonElement.appendChild(document.createTextNode(buttonLabels[i]));

       if (i == primaryButtonIndex) {
         buttonElement.classList.add('alert-dialog-button--primal');
       }

       if (buttonLabels.length <= 2) {
         buttonElement.classList.add('alert-dialog-button--one');
       }

       var onClick = function onClick() {
         buttonElement.removeEventListener('click', onClick, false);

         dialogElement.hide({
           callback: function callback() {
             if (promptDialog) {
               _callback(inputElement.value);
               result.resolve(inputElement.value);
             } else {
               _callback(i);
               result.resolve(i);
             }
             dialogElement.remove();
             dialogElement = inputElement = buttonElement = null;
           }
         });
       };

       buttonElement.addEventListener('click', onClick, false);
       footerElement.appendChild(buttonElement);
     };

     for (var i = 0; i < buttonLabels.length; i++) {
       createButton(i);
     }

     if (cancelable) {
       dialogElement.cancelable = true;
       dialogElement.addEventListener('cancel', function () {
         if (promptDialog) {
           _callback(null);
           result.reject(null);
         } else {
           _callback(-1);
           result.reject(-1);
         }
         setTimeout(function () {
           dialogElement.remove();
           dialogElement = null;
           inputElement = null;
         });
       }, false);
     }

     dialogElement.show({
       callback: function callback() {
         if (inputElement && promptDialog && autofocus) {
           inputElement.focus();
         }
       }
     });

     messageElement = footerElement = null;

     if (modifier) {
       dialogElement.setAttribute('modifier', '');
       dialogElement.setAttribute('modifier', modifier);
     }

     return result.promise;
   };

   notification._alertOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       callback: function callback() {}
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Alert dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, false, false, false, '', '', false, options.compile);
   };

   /**
    * @method alert
    * @signature alert(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Alert message.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Alert message in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja]"Alert"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]Function that executes after dialog has been closed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Display an alert dialog to show the user a message.
    *
    *     The content of the message can be either simple text or HTML.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.alert(message, options);
    *     ons.notification.alert(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     HTML
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.alert = notification._alertOriginal;

   notification._confirmOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabels: ['Cancel', 'OK'],
       primaryButtonIndex: 1,
       animation: 'default',
       title: 'Confirm',
       callback: function callback() {},
       cancelable: false
     };

     options = util.extend({}, defaults, options);

     if (!options.message && !options.messageHTML) {
       throw new Error('Confirm dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, options.buttonLabels, options.primaryButtonIndex, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, false, false, '', '', false, options.compile);
   };

   /**
    * @method confirm
    * @signature confirm(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve to the index of the button that was pressed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    * @param {String} [options.message]
    *   [en]Confirmation question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {Array} [options.buttonLabels]
    *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
    *   [ja]["Cancel", "OK"][/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
    *   [ja][/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Confirm"`.[/en]
    *   [ja]"Confirm"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the index of the button that was pressed or `-1` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     
    *     -1
    *   [/ja]
    * @description
    *   [en]
    *     Display a dialog to ask the user for confirmation.
    *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.confirm(message, options);
    *     ons.notification.confirm(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     "Cancel""OK"
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.confirm = notification._confirmOriginal;

   notification._promptOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       defaultValue: '',
       placeholder: '',
       callback: function callback() {},
       cancelable: false,
       autofocus: true,
       submitOnEnter: true
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Prompt dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, true, options.autofocus, options.placeholder, options.defaultValue, options.submitOnEnter, options.compile);
   };

   /**
    * @method prompt
    * @signature prompt(message [, options] | options)
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Will resolve to the input value when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Prompt question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is false. When the dialog is cancelable it will be closed if the user taps the background or presses the Android back button.[/en]
    *   [ja] false [/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja] "Alert" [/ja]
    * @param {String} [options.placeholder]
    *   [en]Placeholder for the text input.[/en]
    *   [ja][/ja]
    * @param {String} [options.defaultValue]
    *   [en]Default value for the text input.[/en]
    *   [ja][/ja]
    * @param {Boolean} [options.autofocus]
    *   [en]Autofocus the input element. Default is `true`.[/en]
    *   [ja]inputtrue[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the value of the input field or `null` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     null
    *   [/ja]
    * @param {Boolean} [options.submitOnEnter]
    *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
    *   [ja]Enterformsubmittrue[/ja]
    * @description
    *   [en]
    *     Display a dialog with a prompt to ask the user a question.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.prompt(message, options);
    *     ons.notification.prompt(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.prompt = notification._promptOriginal;

   var pageAttributeExpression = {
     _variables: {},

     /**
      * Define a variable.
      *
      * @param {String} name Name of the variable
      * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
      * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
      */
     defineVariable: function defineVariable(name, value) {
       var overwrite = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

       if (typeof name !== 'string') {
         throw new Error('Variable name must be a string.');
       } else if (typeof value !== 'string' && typeof value !== 'function') {
         throw new Error('Variable value must be a string or a function.');
       } else if (this._variables.hasOwnProperty(name) && !overwrite) {
         throw new Error('"' + name + '" is already defined.');
       }
       this._variables[name] = value;
     },

     /**
      * Get a variable.
      *
      * @param {String} name Name of the variable.
      * @return {String|Function|null}
      */
     getVariable: function getVariable(name) {
       if (!this._variables.hasOwnProperty(name)) {
         return null;
       }

       return this._variables[name];
     },

     /**
      * Remove a variable.
      *
      * @param {String} name Name of the varaible.
      */
     removeVariable: function removeVariable(name) {
       delete this._variables[name];
     },

     /**
      * Get all variables.
      *
      * @return {Object}
      */
     getAllVariables: function getAllVariables() {
       return this._variables;
     },
     _parsePart: function _parsePart(part) {
       var c = void 0,
           inInterpolation = false,
           currentIndex = 0;

       var tokens = [];

       if (part.length === 0) {
         throw new Error('Unable to parse empty string.');
       }

       for (var i = 0; i < part.length; i++) {
         c = part.charAt(i);

         if (c === '$' && part.charAt(i + 1) === '{') {
           if (inInterpolation) {
             throw new Error('Nested interpolation not supported.');
           }

           var token = part.substring(currentIndex, i);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i));
           }

           currentIndex = i;
           inInterpolation = true;
         } else if (c === '}') {
           if (!inInterpolation) {
             throw new Error('} must be preceeded by ${');
           }

           var token = part.substring(currentIndex, i + 1);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i + 1));
           }

           currentIndex = i + 1;
           inInterpolation = false;
         }
       }

       if (inInterpolation) {
         throw new Error('Unterminated interpolation.');
       }

       tokens.push(part.substring(currentIndex, part.length));

       return tokens;
     },
     _replaceToken: function _replaceToken(token) {
       var re = /^\${(.*?)}$/,
           match = token.match(re);

       if (match) {
         var name = match[1].trim();
         var variable = this.getVariable(name);

         if (variable === null) {
           throw new Error('Variable "' + name + '" does not exist.');
         } else if (typeof variable === 'string') {
           return variable;
         } else {
           var rv = variable();

           if (typeof rv !== 'string') {
             throw new Error('Must return a string.');
           }

           return rv;
         }
       } else {
         return token;
       }
     },
     _replaceTokens: function _replaceTokens(tokens) {
       return tokens.map(this._replaceToken.bind(this));
     },
     _parseExpression: function _parseExpression(expression) {
       return expression.split(',').map(function (part) {
         return part.trim();
       }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
         return part.join('');
       });
     },

     /**
      * Evaluate an expression.
      *
      * @param {String} expression An page attribute expression.
      * @return {Array}
      */
     evaluate: function evaluate(expression) {
       if (!expression) {
         return [];
       }

       return this._parseExpression(expression);
     }
   };

   // Define default variables.
   pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
   pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
   pageAttributeExpression.defineVariable('runtime', function () {
     return platform.isWebView() ? 'cordova' : 'browser';
   });

   var internal = {};

   internal.config = {
     autoStatusBarFill: true,
     animationsDisabled: false
   };

   internal.nullElement = window.document.createElement('div');

   /**
    * @return {Boolean}
    */
   internal.isEnabledAutoStatusBarFill = function () {
     return !!internal.config.autoStatusBarFill;
   };

   /**
    * @param {String} html
    * @return {String}
    */
   internal.normalizePageHTML = function (html) {
     html = ('' + html).trim();

     if (!html.match(/^<ons-page/)) {
       html = '<ons-page _muted>' + html + '</ons-page>';
     }

     return html;
   };

   internal.waitDOMContentLoaded = function (callback) {
     if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
       window.document.addEventListener('DOMContentLoaded', callback);
     } else {
       setImmediate(callback);
     }
   };

   internal.autoStatusBarFill = function (action) {
     var onReady = function onReady() {
       if (internal.shouldFillStatusBar()) {
         action();
       }
       document.removeEventListener('deviceready', onReady);
       document.removeEventListener('DOMContentLoaded', onReady);
     };

     if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
       document.addEventListener('deviceready', onReady);
     } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
       document.addEventListener('DOMContentLoaded', function () {
         onReady();
       });
     } else {
       onReady();
     }
   };

   internal.shouldFillStatusBar = function () {
     return internal.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
   };

   internal.templateStore = {
     _storage: {},

     /**
      * @param {String} key
      * @return {String/null} template
      */
     get: function get(key) {
       return internal.templateStore._storage[key] || null;
     },


     /**
      * @param {String} key
      * @param {String} template
      */
     set: function set(key, template) {
       internal.templateStore._storage[key] = template;
     }
   };

   window.document.addEventListener('_templateloaded', function (e) {
     if (e.target.nodeName.toLowerCase() === 'ons-template') {
       internal.templateStore.set(e.templateId, e.template);
     }
   }, false);

   window.document.addEventListener('DOMContentLoaded', function () {
     register('script[type="text/ons-template"]');
     register('script[type="text/template"]');
     register('script[type="text/ng-template"]');

     function register(query) {
       var templates = window.document.querySelectorAll(query);
       for (var i = 0; i < templates.length; i++) {
         internal.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
       }
     }
   }, false);

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getTemplateHTMLAsync = function (page) {
     return new Promise(function (resolve, reject) {
       setImmediate(function () {
         var cache = internal.templateStore.get(page);

         if (cache) {
           var html = typeof cache === 'string' ? cache : cache[1];
           resolve(html);
         } else {
           (function () {
             var xhr = new XMLHttpRequest();
             xhr.open('GET', page, true);
             xhr.onload = function (response) {
               var html = xhr.responseText;
               if (xhr.status >= 400 && xhr.status < 600) {
                 reject(html);
               } else {
                 resolve(html);
               }
             };
             xhr.onerror = function () {
               throw new Error('The page is not found: ' + page);
             };
             xhr.send(null);
           })();
         }
       });
     });
   };

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getPageHTMLAsync = function (page) {
     var pages = pageAttributeExpression.evaluate(page);

     var getPage = function getPage(page) {
       if (typeof page !== 'string') {
         return Promise.reject('Must specify a page.');
       }

       return internal.getTemplateHTMLAsync(page).then(function (html) {
         return internal.normalizePageHTML(html);
       }, function (error) {
         if (pages.length === 0) {
           return Promise.reject(error);
         }

         return getPage(pages.shift());
       }).then(function (html) {
         return internal.normalizePageHTML(html);
       });
     };

     return getPage(pages.shift());
   };

   var AnimatorFactory = function () {

     /**
      * @param {Object} opts
      * @param {Object} opts.animators The dictionary for animator classes
      * @param {Function} opts.baseClass The base class of animators
      * @param {String} [opts.baseClassName] The name of the base class of animators
      * @param {String} [opts.defaultAnimation] The default animation name
      * @param {Object} [opts.defaultAnimationOptions] The default animation options
      */

     function AnimatorFactory(opts) {
       babelHelpers.classCallCheck(this, AnimatorFactory);

       this._animators = opts.animators;
       this._baseClass = opts.baseClass;
       this._baseClassName = opts.baseClassName || opts.baseClass.name;
       this._animation = opts.defaultAnimation || 'default';
       this._animationOptions = opts.defaultAnimationOptions || {};

       if (!this._animators[this._animation]) {
         throw new Error('No such animation: ' + this._animation);
       }
     }

     /**
      * @param {String} jsonString
      * @return {Object/null}
      */


     babelHelpers.createClass(AnimatorFactory, [{
       key: 'setAnimationOptions',


       /**
        * @param {Object} options
        */
       value: function setAnimationOptions(options) {
         this._animationOptions = options;
       }

       /**
        * @param {Object} options
        * @param {String} [options.animation] The animation name
        * @param {Object} [options.animationOptions] The animation options
        * @param {Object} defaultAnimator The default animator instance
        * @return {Object} An animator instance
        */

     }, {
       key: 'newAnimator',
       value: function newAnimator() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var defaultAnimator = arguments[1];


         var animator = null;

         if (options.animation instanceof this._baseClass) {
           return options.animation;
         }

         var Animator = null;

         if (typeof options.animation === 'string') {
           Animator = this._animators[options.animation];
         }

         if (!Animator && defaultAnimator) {
           animator = defaultAnimator;
         } else {
           Animator = Animator || this._animators[this._animation];

           var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

           animator = new Animator(animationOpts);

           if (typeof animator === 'function') {
             animator = new animator(animationOpts); // eslint-disable-line new-cap
           }
         }

         if (!(animator instanceof this._baseClass)) {
           throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
         }

         return animator;
       }
     }], [{
       key: 'parseAnimationOptionsString',
       value: function parseAnimationOptionsString(jsonString) {
         try {
           if (typeof jsonString === 'string') {
             var result = util.animationOptionsParse(jsonString);
             if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
               return result;
             } else {
               console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
             }
           }
           return {};
         } catch (e) {
           console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
           return {};
         }
       }
     }]);
     return AnimatorFactory;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModifierUtil = function () {
     function ModifierUtil() {
       babelHelpers.classCallCheck(this, ModifierUtil);
     }

     babelHelpers.createClass(ModifierUtil, null, [{
       key: 'diff',

       /**
        * @param {String} last
        * @param {String} current
        */
       value: function diff(last, current) {
         last = makeDict(('' + last).trim());
         current = makeDict(('' + current).trim());

         var removed = Object.keys(last).reduce(function (result, token) {
           if (!current[token]) {
             result.push(token);
           }
           return result;
         }, []);

         var added = Object.keys(current).reduce(function (result, token) {
           if (!last[token]) {
             result.push(token);
           }
           return result;
         }, []);

         return { added: added, removed: removed };

         function makeDict(modifier) {
           var dict = {};
           ModifierUtil.split(modifier).forEach(function (token) {
             return dict[token] = token;
           });
           return dict;
         }
       }

       /**
        * @param {Object} diff
        * @param {Object} classList
        * @param {String} template
        */

     }, {
       key: 'applyDiffToClassList',
       value: function applyDiffToClassList(diff, classList, template) {
         diff.added.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.add(klass);
         });

         diff.removed.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.remove(klass);
         });
       }

       /**
        * @param {Object} diff
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'applyDiffToElement',
       value: function applyDiffToElement(diff, element, scheme) {
         var matches = function matches(e, s) {
           return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
         };
         for (var selector in scheme) {
           if (scheme.hasOwnProperty(selector)) {
             var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
             for (var i = 0; i < targetElements.length; i++) {
               ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
             }
           }
         }
       }

       /**
        * @param {String} last
        * @param {String} current
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'onModifierChanged',
       value: function onModifierChanged(last, current, element, scheme) {
         return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
       }

       /**
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'initModifier',
       value: function initModifier(element, scheme) {
         var modifier = element.getAttribute('modifier');
         if (typeof modifier !== 'string') {
           return;
         }

         ModifierUtil.applyDiffToElement({
           removed: [],
           added: ModifierUtil.split(modifier)
         }, element, scheme);
       }
     }, {
       key: 'split',
       value: function split(modifier) {
         if (typeof modifier !== 'string') {
           return [];
         }

         return modifier.trim().split(/ +/).filter(function (token) {
           return token !== '';
         });
       }
     }]);
     return ModifierUtil;
   }();

   /* eslint-disable key-spacing */
   var scheme = {
     createItemContent: { type: 'function', returns: Element },
     countItems: { type: 'function', returns: 'number' },
     calculateItemHeight: { type: 'function', returns: 'number' },
     updateItemContent: { type: 'function', safeCall: true },
     destroy: { type: 'function', safeCall: true },
     destroyItem: { type: 'function', safeCall: true },
     _render: { type: 'function', safeCall: true }
   };
   /* eslint-enable key-spacing */

   var LazyRepeatDelegate = function () {
     function LazyRepeatDelegate(userDelegate) {
       var templateElement = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
       babelHelpers.classCallCheck(this, LazyRepeatDelegate);

       this._userDelegate = util.validated('delegate', userDelegate, 'object');
       this._templateElement = util.validated('templateElement', templateElement, [Element, 'null']);
     }

     babelHelpers.createClass(LazyRepeatDelegate, [{
       key: '_validated',
       value: function _validated(key) {
         var _scheme = arguments.length <= 1 || arguments[1] === undefined ? scheme : arguments[1];

         return util.validated(key, null, util.extend({}, _scheme[key], {
           dynamicCall: { object: this._userDelegate, key: key }
         }));
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'hasRenderFunction',
       value: function hasRenderFunction() {
         return this._userDelegate._render !== undefined;
       }

       /**
        * @return {void}
        */

     }, {
       key: '_render',
       value: function _render(items, height) {
         this._validated('_render')(items, height);
       }

       /**
        * @param {Number}
        * @param {Function} done A function that take item object as parameter.
        */

     }, {
       key: 'prepareItem',
       value: function prepareItem(index, done) {
         return done({
           element: this._validated('createItemContent')(index, this._templateElement)
         });
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'countItems',
       value: function countItems() {
         return this._validated('countItems')();
       }

       /**
        * @param {Number} index
        * @param {Object} item
        * @param {Element} item.element
        */

     }, {
       key: 'updateItem',
       value: function updateItem(index, item) {
         return this._validated('updateItemContent')(index, item);
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'calculateItemHeight',
       value: function calculateItemHeight(index) {
         return this._validated('calculateItemHeight')(index);
       }

       /**
        * @param {Number} index
        * @param {Object} item
        */

     }, {
       key: 'destroyItem',
       value: function destroyItem(index, item) {
         return this._validated('destroyItem')(index, item);
       }

       /**
        * @return {void}
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         this._validated('destroy')();
         this._userDelegate = this._templateElement = null;
       }
     }, {
       key: 'itemHeight',
       get: function get() {
         return this._userDelegate.itemHeight;
       }
     }]);
     return LazyRepeatDelegate;
   }();

   /**
    * This class provide core functions for ons-lazy-repeat.
    */
   var LazyRepeatProvider = function () {

     /**
      * @param {Element} wrapperElement
      * @param {LazyRepeatDelegate} delegate
      */

     function LazyRepeatProvider(wrapperElement, delegate) {
       babelHelpers.classCallCheck(this, LazyRepeatProvider);

       this._wrapperElement = wrapperElement;
       this._delegate = util.validated('delegate', delegate, LazyRepeatDelegate);

       if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
         wrapperElement.classList.add('lazy-list');
       }

       this._pageContent = util.findParent(wrapperElement, '.page__content');

       if (!this._pageContent) {
         throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
       }

       this._topPositions = [];
       this._renderedItems = {};

       try {
         this._delegate.itemHeight || this._delegate.calculateItemHeight(0);
       } catch (e) {
         if (!/must be (a|an instance of) function/.test('' + e)) {
           throw e;
         }
         this._unknownItemHeight = true;
       }
       this._addEventListeners();
       this._onChange();
     }

     babelHelpers.createClass(LazyRepeatProvider, [{
       key: '_checkItemHeight',
       value: function _checkItemHeight(callback) {
         var _this = this;

         this._delegate.prepareItem(0, function (_ref) {
           var element = _ref.element;

           if (_this._unknownItemHeight) {
             _this._wrapperElement.appendChild(element);
             _this._itemHeight = element.offsetHeight;
             _this._wrapperElement.removeChild(element);
             delete _this._unknownItemHeight;
             callback();
           }
         });
       }
     }, {
       key: '_countItems',
       value: function _countItems() {
         return this._delegate.countItems();
       }
     }, {
       key: '_getItemHeight',
       value: function _getItemHeight(i) {
         return this.staticItemHeight || this._delegate.calculateItemHeight(i);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._render();
       }
     }, {
       key: 'refresh',
       value: function refresh() {
         this._removeAllElements();
         this._onChange();
       }
     }, {
       key: '_render',
       value: function _render() {
         var _this2 = this;

         if (this._unknownItemHeight) {
           return this._checkItemHeight(this._render.bind(this));
         }

         var items = this._getItemsInView();

         if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
           this._delegate._render(items, this._listHeight);
           return null;
         }

         var keep = {};

         items.forEach(function (item) {
           _this2._renderElement(item);
           keep[item.index] = true;
         });

         Object.keys(this._renderedItems).forEach(function (key) {
           return keep[key] || _this2._removeElement(key);
         });

         this._wrapperElement.style.height = this._listHeight + 'px';
       }

       /**
        * @param {Object} item
        * @param {Number} item.index
        * @param {Number} item.top
        */

     }, {
       key: '_renderElement',
       value: function _renderElement(_ref2) {
         var _this3 = this;

         var index = _ref2.index;
         var top = _ref2.top;

         var item = this._renderedItems[index];
         if (item) {
           this._delegate.updateItem(index, item); // update if it exists
           item.element.style.top = top + 'px';
           return;
         }

         this._delegate.prepareItem(index, function (item) {
           util.extend(item.element.style, {
             position: 'absolute',
             top: top + 'px',
             left: 0,
             right: 0
           });

           _this3._wrapperElement.appendChild(item.element);
           _this3._renderedItems[index] = item;
         });
       }

       /**
        * @param {Number} index
        */

     }, {
       key: '_removeElement',
       value: function _removeElement(index) {
         var item = this._renderedItems[index];

         this._delegate.destroyItem(index, item);

         if (item.element.parentElement) {
           item.element.parentElement.removeChild(item.element);
         }

         delete this._renderedItems[index];
       }
     }, {
       key: '_removeAllElements',
       value: function _removeAllElements() {
         var _this4 = this;

         Object.keys(this._renderedItems).forEach(function (key) {
           return _this4._removeElement(key);
         });
       }
     }, {
       key: '_calculateStartIndex',
       value: function _calculateStartIndex(current) {
         var start = 0;
         var end = this._itemCount - 1;

         if (this.staticItemHeight) {
           return parseInt(-current / this.staticItemHeight);
         }

         // Binary search for index at top of screen so we can speed up rendering.
         for (;;) {
           var middle = Math.floor((start + end) / 2);
           var value = current + this._topPositions[middle];

           if (end < start) {
             return 0;
           } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
             return middle;
           } else if (isNaN(value) || value >= 0) {
             end = middle - 1;
           } else {
             start = middle + 1;
           }
         }
       }
     }, {
       key: '_recalculateTopPositions',
       value: function _recalculateTopPositions() {
         var l = Math.min(this._topPositions.length, this._itemCount);
         this._topPositions[0] = 0;
         for (var i = 1, _l; i < _l; i++) {
           this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
         }
       }
     }, {
       key: '_getItemsInView',
       value: function _getItemsInView() {
         var offset = this._wrapperElement.getBoundingClientRect().top;
         var limit = 4 * window.innerHeight - offset;
         var count = this._countItems();

         if (count !== this._itemCount) {
           this._itemCount = count;
           this._recalculateTopPositions();
         }

         var i = Math.max(0, this._calculateStartIndex(offset) - 30);

         var items = [];
         for (var top = this._topPositions[i]; i < count && top < limit; i++) {
           if (i >= this._topPositions.length) {
             // perf optimization
             this._topPositions.length += 100;
           }

           this._topPositions[i] = top;
           items.push({ top: top, index: i });
           top += this._getItemHeight(i);
         }
         this._listHeight = top;

         return items;
       }
     }, {
       key: '_debounce',
       value: function _debounce(func, wait, immediate) {
         var timeout = void 0;
         return function () {
           var _this5 = this,
               _arguments = arguments;

           var callNow = immediate && !timeout;
           clearTimeout(timeout);
           if (callNow) {
             func.apply(this, arguments);
           } else {
             timeout = setTimeout(function () {
               timeout = null;
               func.apply(_this5, _arguments);
             }, wait);
           }
         };
       }
     }, {
       key: '_doubleFireOnTouchend',
       value: function _doubleFireOnTouchend() {
         this._render();
         this._debounce(this._render.bind(this), 100);
       }
     }, {
       key: '_addEventListeners',
       value: function _addEventListeners() {
         util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

         if (platform.isIOS()) {
           this._boundOnChange = this._debounce(this._boundOnChange, 30);
         }

         this._pageContent.addEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.addEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.removeEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: 'destroy',
       value: function destroy() {
         this._removeAllElements();
         this._delegate.destroy();
         this._parentElement = this._delegate = this._renderedItems = null;
         this._removeEventListeners();
       }
     }, {
       key: 'staticItemHeight',
       get: function get() {
         return this._delegate.itemHeight || this._itemHeight;
       }
     }]);
     return LazyRepeatProvider;
   }();

   internal.AnimatorFactory = AnimatorFactory;
   internal.ModifierUtil = ModifierUtil;
   internal.LazyRepeatProvider = LazyRepeatProvider;
   internal.LazyRepeatDelegate = LazyRepeatDelegate;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var create = function create() {

     /**
      * @object ons.orientation
      * @category util
      * @description
      *   [en]Utility methods for orientation detection.[/en]
      *   [ja][/ja]
      */
     var obj = {
       /**
        * @event change
        * @description
        *   [en]Fired when the device orientation changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isPortrait
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        */

       /**
        * @method on
        * @signature on(eventName, listener)
        * @description
        *   [en]Add an event listener.[/en]
        *   [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method once
        * @signature once(eventName, listener)
        * @description
        *  [en]Add an event listener that's only triggered once.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method off
        * @signature off(eventName, [listener])
        * @description
        *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       // actual implementation to detect if whether current screen is portrait or not
       _isPortrait: false,

       /**
        * @method isPortrait
        * @signature isPortrait()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is portrait or not.[/en]
        *   [ja]portrait[/ja]
        */
       isPortrait: function isPortrait() {
         return this._isPortrait();
       },

       /**
        * @method isLandscape
        * @signature isLandscape()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is landscape mode.[/en]
        *   [ja]landscapetrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is landscape or not.[/en]
        *   [ja]landscape[/ja]
        */
       isLandscape: function isLandscape() {
         return !this.isPortrait();
       },

       _init: function _init() {
         document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

         if ('orientation' in window) {
           window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
         } else {
           window.addEventListener('resize', this._onResize.bind(this), false);
         }

         this._isPortrait = function () {
           return window.innerHeight > window.innerWidth;
         };

         return this;
       },

       _onDOMContentLoaded: function _onDOMContentLoaded() {
         this._installIsPortraitImplementation();
         this.emit('change', { isPortrait: this.isPortrait() });
       },

       _installIsPortraitImplementation: function _installIsPortraitImplementation() {
         var isPortrait = window.innerWidth < window.innerHeight;

         if (!('orientation' in window)) {
           this._isPortrait = function () {
             return window.innerHeight > window.innerWidth;
           };
         } else if (window.orientation % 180 === 0) {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
           };
         } else {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
           };
         }
       },

       _onOrientationChange: function _onOrientationChange() {
         var _this = this;

         var isPortrait = this._isPortrait();

         // Wait for the dimensions to change because
         // of Android inconsistency.
         var nIter = 0;
         var interval = setInterval(function () {
           nIter++;

           var w = window.innerWidth;
           var h = window.innerHeight;

           if (isPortrait && w <= h || !isPortrait && w >= h) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           } else if (nIter === 50) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           }
         }, 20);
       },

       // Run on not mobile browser.
       _onResize: function _onResize() {
         this.emit('change', { isPortrait: this.isPortrait() });
       }
     };

     MicroEvent.mixin(obj);

     return obj;
   };

   var orientation = create()._init();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var softwareKeyboard = new MicroEvent();
   softwareKeyboard._visible = false;

   var onShow = function onShow() {
     softwareKeyboard._visible = true;
     softwareKeyboard.emit('show');
   };

   var onHide = function onHide() {
     softwareKeyboard._visible = false;
     softwareKeyboard.emit('hide');
   };

   var bindEvents = function bindEvents() {
     if (typeof Keyboard !== 'undefined') {
       // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
       Keyboard.onshow = onShow;
       Keyboard.onhide = onHide;
       softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

       return true;
     } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
       // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
       window.addEventListener('native.keyboardshow', onShow);
       window.addEventListener('native.keyboardhide', onHide);
       softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

       return true;
     }

     return false;
   };

   var noPluginError = function noPluginError() {
     console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
   };

   document.addEventListener('deviceready', function () {
     if (!bindEvents()) {
       if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
         noPluginError();
       }

       softwareKeyboard.on = noPluginError;
     }
   });

   var util$1 = {
     _ready: false,

     _domContentLoaded: false,

     _onDOMContentLoaded: function _onDOMContentLoaded() {
       util$1._domContentLoaded = true;

       if (platform.isWebView()) {
         window.document.addEventListener('deviceready', function () {
           util$1._ready = true;
         }, false);
       } else {
         util$1._ready = true;
       }
     },

     addBackButtonListener: function addBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.addEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.addEventListener('backbutton', fn, false);
         });
       }
     },

     removeBackButtonListener: function removeBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.removeEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.removeEventListener('backbutton', fn, false);
         });
       }
     }
   };
   window.addEventListener('DOMContentLoaded', function () {
     return util$1._onDOMContentLoaded();
   }, false);

   var HandlerRepository = {
     _store: {},

     _genId: function () {
       var i = 0;
       return function () {
         return i++;
       };
     }(),

     set: function set(element, handler) {
       if (element.dataset.deviceBackButtonHandlerId) {
         this.remove(element);
       }
       var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
       this._store[id] = handler;
     },

     remove: function remove(element) {
       if (element.dataset.deviceBackButtonHandlerId) {
         delete this._store[element.dataset.deviceBackButtonHandlerId];
         delete element.dataset.deviceBackButtonHandlerId;
       }
     },

     get: function get(element) {
       if (!element.dataset.deviceBackButtonHandlerId) {
         return undefined;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       if (!this._store[id]) {
         throw new Error();
       }

       return this._store[id];
     },

     has: function has(element) {
       if (!element.dataset) {
         return false;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       return !!this._store[id];
     }
   };

   var DeviceBackButtonDispatcher = function () {
     function DeviceBackButtonDispatcher() {
       babelHelpers.classCallCheck(this, DeviceBackButtonDispatcher);

       this._isEnabled = false;
       this._boundCallback = this._callback.bind(this);
     }

     /**
      * Enable to handle 'backbutton' events.
      */


     babelHelpers.createClass(DeviceBackButtonDispatcher, [{
       key: 'enable',
       value: function enable() {
         if (!this._isEnabled) {
           util$1.addBackButtonListener(this._boundCallback);
           this._isEnabled = true;
         }
       }

       /**
        * Disable to handle 'backbutton' events.
        */

     }, {
       key: 'disable',
       value: function disable() {
         if (this._isEnabled) {
           util$1.removeBackButtonListener(this._boundCallback);
           this._isEnabled = false;
         }
       }

       /**
        * Fire a 'backbutton' event manually.
        */

     }, {
       key: 'fireDeviceBackButtonEvent',
       value: function fireDeviceBackButtonEvent() {
         var event = document.createEvent('Event');
         event.initEvent('backbutton', true, true);
         document.dispatchEvent(event);
       }
     }, {
       key: '_callback',
       value: function _callback() {
         this._dispatchDeviceBackButtonEvent();
       }

       /**
        * @param {HTMLElement} element
        * @param {Function} callback
        */

     }, {
       key: 'createHandler',
       value: function createHandler(element, callback) {
         if (!(element instanceof HTMLElement)) {
           throw new Error('element must be an instance of HTMLElement');
         }

         if (!(callback instanceof Function)) {
           throw new Error('callback must be an instance of Function');
         }

         var handler = {
           _callback: callback,
           _element: element,

           disable: function disable() {
             HandlerRepository.remove(element);
           },

           setListener: function setListener(callback) {
             this._callback = callback;
           },

           enable: function enable() {
             HandlerRepository.set(element, this);
           },

           isEnabled: function isEnabled() {
             return HandlerRepository.get(element) === this;
           },

           destroy: function destroy() {
             HandlerRepository.remove(element);
             this._callback = this._element = null;
           }
         };

         handler.enable();

         return handler;
       }
     }, {
       key: '_dispatchDeviceBackButtonEvent',
       value: function _dispatchDeviceBackButtonEvent() {
         var tree = this._captureTree();

         var element = this._findHandlerLeafElement(tree);

         var handler = HandlerRepository.get(element);
         handler._callback(createEvent(element));

         function createEvent(element) {
           return {
             _element: element,
             callParentHandler: function callParentHandler() {
               var parent = this._element.parentNode;

               while (parent) {
                 handler = HandlerRepository.get(parent);
                 if (handler) {
                   return handler._callback(createEvent(parent));
                 }
                 parent = parent.parentNode;
               }
             }
           };
         }
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_captureTree',
       value: function _captureTree() {
         return createTree(document.body);

         function createTree(element) {
           return {
             element: element,
             children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

               if (childElement.style.display === 'none') {
                 return [];
               }

               if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
                 return [];
               }

               var result = createTree(childElement);

               if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
                 return [];
               }

               return [result];
             }))
           };
         }

         function arrayOf(target) {
           var result = [];
           for (var i = 0; i < target.length; i++) {
             result.push(target[i]);
           }
           return result;
         }
       }

       /**
        * @param {Object} tree
        * @return {HTMLElement}
        */

     }, {
       key: '_findHandlerLeafElement',
       value: function _findHandlerLeafElement(tree) {
         return find(tree);

         function find(node) {
           if (node.children.length === 0) {
             return node.element;
           }

           if (node.children.length === 1) {
             return find(node.children[0]);
           }

           return node.children.map(function (childNode) {
             return childNode.element;
           }).reduce(function (left, right) {
             if (!left) {
               return right;
             }

             var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
             var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

             if (!isNaN(leftZ) && !isNaN(rightZ)) {
               return leftZ > rightZ ? left : right;
             }

             throw new Error('Capturing backbutton-handler is failure.');
           }, null);
         }
       }
     }]);
     return DeviceBackButtonDispatcher;
   }();

   var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

   var autoStyleEnabled = true;

   // Modifiers
   var modifiersMap = {
     'quiet': 'material--flat',
     'light': 'material--flat',
     'outline': 'material--flat',
     'cta': '',
     'large--quiet': 'material--flat large',
     'large--cta': 'large',
     'noborder': '',
     'chevron': '',
     'tappable': ''
   };

   var platforms = {};

   platforms.android = function (element) {

     if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

       var oldModifier = element.getAttribute('modifier') || '';

       var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
         return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
       });
       newModifier.unshift('material');

       element.setAttribute('modifier', newModifier.join(' ').trim());
     }

     // Effects
     if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

       if (element.tagName.toLowerCase() === 'ons-list-item') {
         if (element.hasAttribute('tappable')) {
           element.setAttribute('ripple', '');
           element.removeAttribute('tappable');
         }
       } else {
         element.setAttribute('ripple', '');
       }
     }
   };

   platforms.ios = function (element) {

     // Modifiers
     if (/material/.test(element.getAttribute('modifier'))) {
       util.removeModifier(element, 'material');

       if (util.removeModifier(element, 'material--flat')) {
         util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
       }

       if (!element.getAttribute('modifier')) {
         element.removeAttribute('modifier');
       }
     }

     // Effects
     if (element.hasAttribute('ripple')) {
       if (element.tagName.toLowerCase() === 'ons-list-item') {
         element.setAttribute('tappable', '');
       }

       element.removeAttribute('ripple');
     }
   };

   var unlocked = {
     android: true
   };

   var prepareAutoStyle = function prepareAutoStyle(element, force) {
     if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
       var mobileOS = platform.getMobileOS();
       if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
         platforms[mobileOS](element);
       }
     }
   };

   var autoStyle = {
     isEnabled: function isEnabled() {
       return autoStyleEnabled;
     },
     enable: function enable() {
       return autoStyleEnabled = true;
     },
     disable: function disable() {
       return autoStyleEnabled = false;
     },
     prepare: prepareAutoStyle
   };

   var generateId = function () {
     var i = 0;
     return function () {
       return i++;
     };
   }();

   /**
    * Door locking system.
    *
    * @param {Object} [options]
    * @param {Function} [options.log]
    */

   var DoorLock = function () {
     function DoorLock() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, DoorLock);

       this._lockList = [];
       this._waitList = [];
       this._log = options.log || function () {};
     }

     /**
      * Register a lock.
      *
      * @return {Function} Callback for unlocking.
      */


     babelHelpers.createClass(DoorLock, [{
       key: 'lock',
       value: function lock() {
         var _this = this;

         var unlock = function unlock() {
           _this._unlock(unlock);
         };
         unlock.id = generateId();
         this._lockList.push(unlock);
         this._log('lock: ' + unlock.id);

         return unlock;
       }
     }, {
       key: '_unlock',
       value: function _unlock(fn) {
         var index = this._lockList.indexOf(fn);
         if (index === -1) {
           throw new Error('This function is not registered in the lock list.');
         }

         this._lockList.splice(index, 1);
         this._log('unlock: ' + fn.id);

         this._tryToFreeWaitList();
       }
     }, {
       key: '_tryToFreeWaitList',
       value: function _tryToFreeWaitList() {
         while (!this.isLocked() && this._waitList.length > 0) {
           this._waitList.shift()();
         }
       }

       /**
        * Register a callback for waiting unlocked door.
        *
        * @params {Function} callback Callback on unlocking the door completely.
        */

     }, {
       key: 'waitUnlock',
       value: function waitUnlock(callback) {
         if (!(callback instanceof Function)) {
           throw new Error('The callback param must be a function.');
         }

         if (this.isLocked()) {
           this._waitList.push(callback);
         } else {
           callback();
         }
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLocked',
       value: function isLocked() {
         return this._lockList.length > 0;
       }
     }]);
     return DoorLock;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */
   var readyMap = new WeakMap();
   var queueMap = new WeakMap();

   function isContentReady(element) {
     if (element.childNodes.length > 0) {
       setContentReady(element);
     }
     return readyMap.has(element);
   }

   function setContentReady(element) {
     readyMap.set(element, true);
   }

   function addCallback(element, fn) {
     if (!queueMap.has(element)) {
       queueMap.set(element, []);
     }
     queueMap.get(element).push(fn);
   }

   function consumeQueue(element) {
     var callbacks = queueMap.get(element, []) || [];
     queueMap.delete(element);
     callbacks.forEach(function (callback) {
       return callback();
     });
   }

   function contentReady(element, fn) {
     addCallback(element, fn);

     if (isContentReady(element)) {
       consumeQueue(element);
       return;
     }

     var observer = new MutationObserver(function (changes) {
       setContentReady(element);
       consumeQueue(element);
     });
     observer.observe(element, { childList: true, characterData: true });

     // failback for elements has empty content.
     setImmediate(function () {
       setContentReady(element);
       consumeQueue(element);
     });
   }

   /**
    * @object ons
    * @category util
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]A global object that's used in Onsen UI. [/en]
    */
   var ons$1 = {};

   ons$1._util = util;
   ons$1._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
   ons$1._internal = internal;
   ons$1.GestureDetector = GestureDetector;
   ons$1.platform = platform;
   ons$1.softwareKeyboard = softwareKeyboard;
   ons$1.pageAttributeExpression = pageAttributeExpression;
   ons$1.orientation = orientation;
   ons$1.notification = notification;
   ons$1._animationOptionsParser = parse;
   ons$1._autoStyle = autoStyle;
   ons$1._DoorLock = DoorLock;
   ons$1._contentReady = contentReady;

   ons$1._readyLock = new DoorLock();

   ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

   waitDeviceReady();

   /**
    * @method isReady
    * @signature isReady()
    * @return {Boolean}
    *   [en]Will be true if Onsen UI is initialized.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Returns true if Onsen UI is initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons$1.isReady = function () {
     return !ons$1._readyLock.isLocked();
   };

   /**
    * @method isWebView
    * @signature isWebView()
    * @return {Boolean}
    *   [en]Will be true if the app is running in Cordova.[/en]
    *   [ja]Cordovatrue[/ja]
    * @description
    *   [en]Returns true if running inside Cordova.[/en]
    *   [ja]Cordova[/ja]
    */
   ons$1.isWebView = ons$1.platform.isWebView;

   /**
    * @method ready
    * @signature ready(callback)
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
    * @param {Function} callback
    *   [en]Function that executes after Onsen UI has been initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons$1.ready = function (callback) {
     if (ons$1.isReady()) {
       callback();
     } else {
       ons$1._readyLock.waitUnlock(callback);
     }
   };

   /**
    * @method setDefaultDeviceBackButtonListener
    * @signature setDefaultDeviceBackButtonListener(listener)
    * @param {Function} listener
    *   [en]Function that executes when device back button is pressed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Set default handler for device back button.[/en]
    *   [ja][/ja]
    */
   ons$1.setDefaultDeviceBackButtonListener = function (listener) {
     ons$1._defaultDeviceBackButtonHandler.setListener(listener);
   };

   /**
    * @method disableDeviceBackButtonHandler
    * @signature disableDeviceBackButtonHandler()
    * @description
    * [en]Disable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons$1.disableDeviceBackButtonHandler = function () {
     ons$1._deviceBackButtonDispatcher.disable();
   };

   /**
    * @method enableDeviceBackButtonHandler
    * @signature enableDeviceBackButtonHandler()
    * @description
    * [en]Enable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons$1.enableDeviceBackButtonHandler = function () {
     ons$1._deviceBackButtonDispatcher.enable();
   };

   /**
    * @method enableAutoStatusBarFill
    * @signature enableAutoStatusBarFill()
    * @description
    *   [en]Enable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons$1.enableAutoStatusBarFill = function () {
     if (ons$1.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons$1._internal.config.autoStatusBarFill = true;
   };

   /**
    * @method disableAutoStatusBarFill
    * @signature disableAutoStatusBarFill()
    * @description
    *   [en]Disable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons$1.disableAutoStatusBarFill = function () {
     if (ons$1.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons$1._internal.config.autoStatusBarFill = false;
   };

   /**
    * @method disableAnimations
    * @signature disableAnimations()
    * @description
    *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
    *   [ja][/ja]
    */
   ons$1.disableAnimations = function () {
     ons$1._internal.config.animationsDisabled = true;
   };

   /**
    * @method enableAnimations
    * @signature enableAnimations()
    * @description
    *   [en]Enable animations (default).[/en]
    *   [ja][/ja]
    */
   ons$1.enableAnimations = function () {
     ons$1._internal.config.animationsDisabled = false;
   };

   /**
    * @method disableAutoStyling
    * @signature disableAutoStyling()
    * @description
    *   [en]Disable automatic styling.[/en]
    *   [ja][/ja]
    */
   ons$1.disableAutoStyling = ons$1._autoStyle.disable;

   /**
    * @method enableAutoStyling
    * @signature enableAutoStyling()
    * @description
    *   [en]Enable automatic styling based on OS (default).[/en]
    *   [ja][/ja]
    */
   ons$1.enableAutoStyling = ons$1._autoStyle.enable;

   /**
    * @method forcePlatformStyling
    * @signature forcePlatformStyling(platform)
    * @description
    *   [en]Refresh styling for the given platform.[/en]
    *   [ja][/ja]
    * @param {string} platform New platform to style the elements.
    */
   ons$1.forcePlatformStyling = function (newPlatform) {
     ons$1.enableAutoStyling();
     ons$1.platform.select(newPlatform || 'ios');

     ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
       if (element.tagName.toLowerCase() === 'ons-if') {
         element._platformUpdate();
       } else if (element.tagName.match(/^ons-/i)) {
         ons$1._autoStyle.prepare(element, true);
         if (element.tagName.toLowerCase() === 'ons-tabbar') {
           element._updatePosition();
         }
       }
     });
   };

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons$1._createPopoverOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
       var div = ons$1._util.createElement('<div>' + html + '</div>');

       var popover = div.querySelector('ons-popover');
       CustomElements.upgrade(popover);
       document.body.appendChild(popover);

       if (options.link instanceof Function) {
         options.link(popover);
       }

       return popover;
     });
   };

   /**
    * @method createPopover
    * @signature createPopover(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {Object} [options.parentScope]
    *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
    *   [ja]AngularJS[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the popover component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a popover instance from a template.[/en]
    *   [ja][/ja]
    */
   ons$1.createPopover = ons$1._createPopoverOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons$1._createDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
       var div = ons$1._util.createElement('<div>' + html + '</div>');

       var dialog = div.querySelector('ons-dialog');
       CustomElements.upgrade(dialog);
       document.body.appendChild(dialog);

       if (options.link instanceof Function) {
         options.link(dialog);
       }

       return dialog;
     });
   };

   /**
    * @method createDialog
    * @signature createDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons$1.createDialog = ons$1._createDialogOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons$1._createAlertDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
       var div = ons$1._util.createElement('<div>' + html + '</div>');

       var alertDialog = div.querySelector('ons-alert-dialog');
       CustomElements.upgrade(alertDialog);
       document.body.appendChild(alertDialog);

       if (options.link instanceof Function) {
         options.link(alertDialog);
       }

       return alertDialog;
     });
   };

   /**
    * @method createAlertDialog
    * @signature createAlertDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the alert dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a alert dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons$1.createAlertDialog = ons$1._createAlertDialogOriginal;

   /**
    * @param {String} page
    * @param {Function} link
    */
   ons$1._resolveLoadingPlaceholderOriginal = function (page, link) {
     var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

     if (elements.length > 0) {
       elements.filter(function (element) {
         return !element.getAttribute('page');
       }).forEach(function (element) {
         element.setAttribute('ons-loading-placeholder', page);
         ons$1._resolveLoadingPlaceholder(element, page, link);
       });
     } else {
       throw new Error('No ons-loading-placeholder exists.');
     }
   };

   /**
    * @method resolveLoadingPlaceholder
    * @signature resolveLoadingPlaceholder(page)
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @description
    *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
    *   [ja]ons-loading-placeholderons.resolveLoadingPlaceholder[/ja]
    */
   ons$1.resolveLoadingPlaceholder = ons$1._resolveLoadingPlaceholderOriginal;

   ons$1._setupLoadingPlaceHolders = function () {
     ons$1.ready(function () {
       var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

       elements.forEach(function (element) {
         var page = element.getAttribute('ons-loading-placeholder');
         if (typeof page === 'string') {
           ons$1._resolveLoadingPlaceholder(element, page);
         }
       });
     });
   };

   ons$1._resolveLoadingPlaceholder = function (element, page, link) {
     link = link || function (element, done) {
       done();
     };
     ons$1._internal.getPageHTMLAsync(page).then(function (html) {

       while (element.firstChild) {
         element.removeChild(element.firstChild);
       }

       var contentElement = ons$1._util.createElement('<div>' + html + '</div>');
       contentElement.style.display = 'none';

       element.appendChild(contentElement);

       link(contentElement, function () {
         contentElement.style.display = '';
       });
     }).catch(function (error) {
       throw new Error('Unabled to resolve placeholder: ' + error);
     });
   };

   function waitDeviceReady() {
     var unlockDeviceReady = ons$1._readyLock.lock();
     window.addEventListener('WebComponentsReady', function () {
       if (ons$1.isWebView()) {
         window.document.addEventListener('deviceready', unlockDeviceReady, false);
       } else {
         unlockDeviceReady();
       }
     }, false);
   }

   window._superSecretOns = ons$1;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   function getElementClass() {
     if (typeof HTMLElement !== 'function') {
       var _BaseElement = function _BaseElement() {};
       _BaseElement.prototype = document.createElement('div');
       return _BaseElement;
     } else {
       return HTMLElement;
     }
   }

   var BaseElement = function (_getElementClass) {
     babelHelpers.inherits(BaseElement, _getElementClass);

     function BaseElement() {
       babelHelpers.classCallCheck(this, BaseElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BaseElement).apply(this, arguments));
     }

     return BaseElement;
   }(getElementClass());

   /**
    * @element ons-template
    * @category template
    * @description
    *   [en]
    *     Define a separate HTML fragment and use as a template.
    *
    *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
    *   [/en]
    *   [ja]HTMLHTMLidpageURLons-navigator[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-navigator
    *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-tabbar
    *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-splitter
    *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
    *   [ja][/ja]
    * @example
    * <ons-template id="foobar.html">
    *   <ons-page>
    *     Page content
    *   </ons-page>
    * </ons-template>
    *
    * <ons-navigator page="foobar.html">
    * </ons-navigator>
    */

   var TemplateElement = function (_BaseElement) {
     babelHelpers.inherits(TemplateElement, _BaseElement);

     function TemplateElement() {
       babelHelpers.classCallCheck(this, TemplateElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TemplateElement).apply(this, arguments));
     }

     babelHelpers.createClass(TemplateElement, [{
       key: 'createdCallback',


       /**
        * @property template
        * @type {String}
        * @description
        *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
        *  [ja][/ja]
        */
       value: function createdCallback() {
         this.template = this.innerHTML;

         while (this.firstChild) {
           this.removeChild(this.firstChild);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
         event.template = this.template;
         event.templateId = this.getAttribute('id');

         this.dispatchEvent(event);
       }
     }]);
     return TemplateElement;
   }(BaseElement);

   window.OnsTemplateElement = document.registerElement('ons-template', {
     prototype: TemplateElement.prototype
   });

   /**
    * @element ons-if
    * @category conditional
    * @description
    *   [en]
    *     Conditionally display content depending on the platform, device orientation or both.
    *
    *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
    *   [/en]
    *   [ja][/ja]
    * @guide UtilityAPIs
    *   [en]Other utility APIs[/en]
    *   [ja]API[/ja]
    * @example
    * <ons-page>
    *   <ons-if orientation="landscape">
    *     Landscape view!
    *   </ons-if>
    *   <ons-if platform="android">
    *     This is Android.
    *   </ons-if>
    *   <ons-if platform="ios other">
    *     This is not Android.
    *   </ons-if>
    * </ons-page>
    */

   var ConditionalElement = function (_BaseElement) {
     babelHelpers.inherits(ConditionalElement, _BaseElement);

     function ConditionalElement() {
       babelHelpers.classCallCheck(this, ConditionalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ConditionalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ConditionalElement, [{
       key: 'createdCallback',


       /**
        * @attribute platform
        * @initonly
        * @type {string}
        * @description
        *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute orientation
        * @type {string}
        * @description
        *  [en]Either `"portrait"` or `"landscape"`.[/en]
        *  [ja]portraitlandscape[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (platform._renderPlatform !== null) {
             _this2._platformUpdate();
           } else if (!_this2._isAllowedPlatform()) {
             while (_this2.childNodes[0]) {
               _this2.childNodes[0].remove();
             }
             _this2._platformUpdate();
           }
         });

         this._onOrientationChange();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         orientation.on('change', this._onOrientationChange.bind(this));
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name) {
         if (name === 'orientation') {
           this._onOrientationChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         orientation.off('change', this._onOrientationChange);
       }
     }, {
       key: '_platformUpdate',
       value: function _platformUpdate() {
         this.style.display = this._isAllowedPlatform() ? '' : 'none';
       }
     }, {
       key: '_isAllowedPlatform',
       value: function _isAllowedPlatform() {
         return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
       }
     }, {
       key: '_onOrientationChange',
       value: function _onOrientationChange() {
         if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
           var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
           var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

           this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
         }
       }
     }]);
     return ConditionalElement;
   }(BaseElement);

   window.OnsConditionalElement = document.registerElement('ons-if', {
     prototype: ConditionalElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var AlertDialogAnimator = function () {
     function AlertDialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, AlertDialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(AlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return AlertDialogAnimator;
   }();

   /**
    * Android style animator for alert dialog.
    */
   var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
     babelHelpers.inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

     function AndroidAlertDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.2 : _ref2$duration;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       babelHelpers.classCallCheck(this, AndroidAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidAlertDialogAnimator;
   }(AlertDialogAnimator);

   /**
    * iOS style animator for alert dialog.
    */
   var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
     babelHelpers.inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

     function IOSAlertDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       babelHelpers.classCallCheck(this, IOSAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /*
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSAlertDialogAnimator;
   }(AlertDialogAnimator);

   var scheme$1 = {
     '.alert-dialog': 'alert-dialog--*',
     '.alert-dialog-container': 'alert-dialog-container--*',
     '.alert-dialog-title': 'alert-dialog-title--*',
     '.alert-dialog-content': 'alert-dialog-content--*',
     '.alert-dialog-footer': 'alert-dialog-footer--*',
     '.alert-dialog-button': 'alert-dialog-button--*',
     '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
     '.alert-dialog-button--one': 'alert-dialog-button--one--*',
     '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
     '.alert-dialog-mask': 'alert-dialog-mask--*'
   };

   var _animatorDict = {
     'none': AlertDialogAnimator,
     'default': function _default() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     }
   };

   /**
    * @element ons-alert-dialog
    * @category dialog
    * @description
    *   [en]
    *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
    *   [/en]
    *   [ja][/ja]
    * @codepen Qwwxyp
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @guide UsingAlert
    *   [en]Learn how to use the alert dialog.[/en]
    *   [ja][/ja]
    * @seealso ons-dialog
    *   [en]ons-dialog component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons-popover
    *   [en]ons-popover component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons.notification
    *   [en]Using ons.notification utility functions.[/en]
    *   [ja]ons.notification[/ja]
    * @example
    * <ons-alert-dialog id="alert-dialog">
    *   <div class="alert-dialog-title">Warning!</div>
    *   <div class="alert-dialog-content">
    *     An error has occurred!
    *   </div>
    *   <div class="alert-dialog-footer">
    *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
    *   </div>
    * </ons-alert-dialog>
    * <script>
    *   document.getElementById('alert-dialog').show();
    * </script>
    */

   var AlertDialogElement = function (_BaseElement) {
     babelHelpers.inherits(AlertDialogElement, _BaseElement);

     function AlertDialogElement() {
       babelHelpers.classCallCheck(this, AlertDialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AlertDialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(AlertDialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict,
           baseClass: AlertDialogAnimator,
           baseClassName: 'AlertDialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         /**
          * Expected result after compile:
          *
          * <ons-alert-dialog style="none">
          *   <div class="alert-dialog-mask"></div>
          *   <div class="alert-dialog">
          *     <div class="alert-dialog-container">...</div>
          *   </div>
          * </ons-alert-dialog>
          */

         var content = document.createDocumentFragment();

         if (!this._mask && !this._dialog) {
           while (this.firstChild) {
             content.appendChild(this.firstChild);
           }
         }

         if (!this._mask) {
           var mask = document.createElement('div');
           mask.classList.add('alert-dialog-mask');
           this.insertBefore(mask, this.children[0]);
         }

         if (!this._dialog) {
           var dialog = document.createElement('div');
           dialog.classList.add('alert-dialog');
           this.insertBefore(dialog, null);
         }

         if (!util.findChild(this._dialog, '.alert-dialog-container')) {
           var container = document.createElement('div');
           container.classList.add('alert-dialog-container');
           this._dialog.appendChild(container);
         }

         this._dialog.children[0].appendChild(content);

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         if (this.getAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$1);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]A `Promise` object that resolves to the displayed element.[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this3._doorLock.lock();
               var animator = _this3._animatorFactory.newAnimator(options);

               _this3.style.display = 'block';
               _this3._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this3, function () {
                   animator.show(_this3, function () {
                     _this3._visible = true;
                     unlock();

                     util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                     callback();
                     resolve(_this3);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this3._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.hide(_this4, function () {
                     _this4.style.display = 'none';
                     _this4._visible = false;
                     unlock();

                     util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.cancelable) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this5 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this5._running = false;
               util.triggerElementEvent(_this5, 'cancel');
             }
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from showing.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the alert dialog is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from hiding.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the alert dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       /**
        * @return {Element}
        */
       get: function get() {
         return util.findChild(this, '.alert-dialog-mask');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.alert-dialog');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_titleElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-title');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-content');
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property onDeviceBackButton
        * @readonly
        * @type {Object}
        * @description
        *   [en]Retrieve the back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       }
     }]);
     return AlertDialogElement;
   }(BaseElement);

   var OnsAlertDialogElement = window.OnsAlertDialogElement = document.registerElement('ons-alert-dialog', {
     prototype: AlertDialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsAlertDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof AlertDialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
     }
     _animatorDict[name] = Animator;
   };

   OnsAlertDialogElement.AlertDialogAnimator = AlertDialogAnimator;

   var scheme$2 = {
     '': 'back-button--*',
     '.back-button__icon': 'back-button--*__icon',
     '.back-button__label': 'back-button--*__label'
   };

   /**
    * @element ons-back-button
    * @category toolbar
    * @description
    *   [en]
    *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
    *
    *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-navigator
    *   [en]ons-navigator component[/en]
    *   [ja]ons-navigator[/ja]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @guide Returningfromapage
    *   [en]Returning from a page[/en]
    *   [ja][/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-back-button>Back</ons-back-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   <div>
    * </ons-toolbar>
    */

   var BackButtonElement = function (_BaseElement) {
     babelHelpers.inherits(BackButtonElement, _BaseElement);

     function BackButtonElement() {
       babelHelpers.classCallCheck(this, BackButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BackButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(BackButtonElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the back button.[/en]
        *  [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }
         });

         this._options = {};
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('back-button');

         if (!util.findChild(this, '.back-button__label')) {
           var label = util.create('span.back-button__label');

           while (this.childNodes[0]) {
             label.appendChild(this.childNodes[0]);
           }

           this.appendChild(label);
         }

         if (!util.findChild(this, '.back-button__icon')) {
           var icon = util.create('span.back-button__icon');

           this.insertBefore(icon, this.children[0]);
         }

         ModifierUtil.initModifier(this, scheme$2);

         this.setAttribute('_compiled', '');
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Options object.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
        *     These are platform based animations. For fixed animations, add "-ios" or "-md"
        *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @description
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: '_onClick',


       /**
        * @property onClick
        * @type {Function}
        * @description
        *   [en]Used to override the default back button behavior.[/en]
        *   [ja][/ja]
        */
       value: function _onClick() {
         if (this.onClick) {
           this.onClick.apply(this);
         } else {
           var navigator = util.findParent(this, 'ons-navigator');
           if (navigator) {
             navigator.popPage(this.options);
           }
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$2);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'show',
       value: function show() {
         this.style.display = 'inline-block';
       }
     }, {
       key: 'hide',
       value: function hide() {
         this.style.display = 'none';
       }
     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }]);
     return BackButtonElement;
   }(BaseElement);

   window.OnsBackButtonElement = document.registerElement('ons-back-button', {
     prototype: BackButtonElement.prototype
   });

   var scheme$3 = { '': 'bottom-bar--*' };

   /**
    * @element ons-bottom-toolbar
    * @category toolbar
    * @description
    *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Make the toolbar transparent.[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbar[/ja]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @example
    * <ons-bottom-toolbar>
    *   Content
    * </ons-bottom-toolbar>
    */

   var BottomToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(BottomToolbarElement, _BaseElement);

     function BottomToolbarElement() {
       babelHelpers.classCallCheck(this, BottomToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BottomToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(BottomToolbarElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         this.classList.add('bottom-bar');

         ModifierUtil.initModifier(this, scheme$3);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var page = util.findParent(this, 'ons-page');
         if (this.parentNode != page) {
           page._registerBottomToolbar(this);
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$3);
         }
       }
     }]);
     return BottomToolbarElement;
   }(BaseElement);

   window.OnsBottomToolbarElement = document.registerElement('ons-bottom-toolbar', {
     prototype: BottomToolbarElement.prototype
   });

   var scheme$4 = { '': 'button--*' };

   /**
    * @element ons-button
    * @category button
    * @modifier outline
    *   [en]Button with outline and transparent background[/en]
    *   [ja][/ja]
    * @modifier light
    *   [en]Button that doesn't stand out.[/en]
    *   [ja][/ja]
    * @modifier quiet
    *   [en]Button with no outline and or background..[/en]
    *   [ja][/ja]
    * @modifier cta
    *   [en]Button that really stands out.[/en]
    *   [ja][/ja]
    * @modifier large
    *   [en]Large button that covers the width of the screen.[/en]
    *   [ja][/ja]
    * @modifier large--quiet
    *   [en]Large quiet button.[/en]
    *   [ja]quiet[/ja]
    * @modifier large--cta
    *   [en]Large call to action button.[/en]
    *   [ja]cta[/ja]
    * @modifier material
    *   [en]Material Design button[/en]
    *   [ja][/ja]
    * @modifier material--flat
    *   [en]Material Design flat button[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
    *
    *     Will automatically display as a Material Design button with a ripple effect on Android.
    *   [/en]
    *   [ja]ons-toolbar-buttonons-back-button[/ja]
    * @codepen hLayx
    * @guide Button [en]Guide for `<ons-button>`[/en][ja]<ons-button>[/ja]
    * @guide OverridingCSSstyles [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @example
    * <ons-button modifier="large--cta">
    *   Tap Me
    * </ons-button>
    */

   var ButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ButtonElement, _BaseElement);

     function ButtonElement() {
       babelHelpers.classCallCheck(this, ButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ButtonElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$4);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the button is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('button');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$4);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return ButtonElement;
   }(BaseElement);

   window.OnsButtonElement = document.registerElement('ons-button', {
     prototype: ButtonElement.prototype
   });

   var scheme$5 = { '': 'carousel-item--*' };

   /**
    * @element ons-carousel-item
    * @category carousel
    * @description
    *   [en]
    *     Carousel item component. Used as a child of the `<ons-carousel>` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @seealso ons-carousel
    *   [en]`<ons-carousel>` components[/en]
    *   [ja]<ons-carousel>[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselItemElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselItemElement, _BaseElement);

     function CarouselItemElement() {
       babelHelpers.classCallCheck(this, CarouselItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselItemElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.style.width = '100%';
         ModifierUtil.initModifier(this, scheme$5);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
         }
       }
     }]);
     return CarouselItemElement;
   }(BaseElement);

   window.OnsCarouselItemElement = document.registerElement('ons-carousel-item', {
     prototype: CarouselItemElement.prototype
   });

   var VerticalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaY;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityY;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().height;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(0px, ' + -scroll + 'px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
         this._offset = -(height - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.height = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   var HorizontalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaX;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityX;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().width;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(' + -scroll + 'px, 0px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
         this._offset = -(width - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.width = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   /**
    * @element ons-carousel
    * @category carousel
    * @description
    *   [en]
    *     Carousel component. A carousel can be used to display several items in the same space.
    *
    *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @seealso ons-carousel-item
    *   [en]`<ons-carousel-item>` component[/en]
    *   [ja]ons-carousel-item[/ja]
    * @guide UsingCarousel
    *   [en]Learn how to use the carousel component.[/en]
    *   [ja]carousel[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselElement, _BaseElement);

     function CarouselElement() {
       babelHelpers.classCallCheck(this, CarouselElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselElement, [{
       key: 'createdCallback',


       /**
        * @event postchange
        * @description
        *   [en]Fired just after the current carousel item has changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {Number} event.lastActiveIndex
        *   [en]Previous active index.[/en]
        *   [ja][/ja]
        */

       /**
        * @event refresh
        * @description
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        */

       /**
        * @event overscroll
        * @description
        *   [en]Fired when the carousel has been overscrolled.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {String} event.direction
        *   [en]Can be one of either "up", "down", "left" or "right".[/en]
        *   [ja]"up", "down", "left", "right"[/ja]
        * @param {Function} event.waitToReturn
        *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
        *   [ja]PromisePromiseresolvereject[/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
        *   [ja]"horizontal""vertical""horizontal"[/ja]
        */

       /**
        * @attribute fullscreen
        * @description
        *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
        *   [ja]absolute[/ja]
        */

       /**
        * @attribute overscrollable
        * @description
        *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute centered
        * @description
        *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
        *   [ja]ons-carousel-item[/ja]
        */

       /**
        * @attribute item-width
        * @type {String}
        * @description
        *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
        *    [ja]ons-carousel-itemdirection"horizontal"[/ja]
        */

       /**
        * @attribute item-height
        * @type {String}
        * @description
        *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
        *   [ja]ons-carousel-itemdirection"vertical"[/ja]
        */

       /**
        * @attribute auto-scroll
        * @description
        *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
        *   [ja]carousel-item[/ja]
        */

       /**
        * @attribute auto-scroll-ratio
        * @type {Number}
        * @description
        *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
        *    [ja]0.01.0[/ja]
        */

       /**
        * @attribute swipeable
        * @description
        *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the carousel is disabled.[/en]
        *   [ja]dragtouchswipe[/ja]
        */

       /**
        * @attribute initial-index
        * @initonly
        * @type {Number}
        * @description
        *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
        *   [ja]ons-carousel-item0 0 [/ja]
        */

       /**
        * @attribute auto-refresh
        * @description
        *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *   [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       value: function createdCallback() {
         this._doorLock = new DoorLock();
         this._scroll = 0;
         this._offset = 0;
         this._lastActiveIndex = 0;

         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnResize = this._onResize.bind(this);

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();
       }
     }, {
       key: '_onResize',
       value: function _onResize() {
         this.refresh();
       }
     }, {
       key: '_onDirectionChange',
       value: function _onDirectionChange() {
         if (this._isVertical()) {
           this.style.overflowX = 'auto';
           this.style.overflowY = '';
         } else {
           this.style.overflowX = '';
           this.style.overflowY = 'auto';
         }

         this.refresh();
       }
     }, {
       key: '_saveLastState',
       value: function _saveLastState() {
         this._lastState = {
           elementSize: this._getCarouselItemSize(),
           carouselElementCount: this.itemCount,
           width: this._getCarouselItemSize() * this.itemCount
         };
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getCarouselItemSize',
       value: function _getCarouselItemSize() {
         var sizeAttr = this._getCarouselItemSizeAttr();
         var sizeInfo = this._decomposeSizeString(sizeAttr);
         var elementSize = this._getElementSize();

         if (sizeInfo.unit === '%') {
           return Math.round(sizeInfo.number / 100 * elementSize);
         } else if (sizeInfo.unit === 'px') {
           return sizeInfo.number;
         } else {
           throw new Error('Invalid state');
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getInitialIndex',
       value: function _getInitialIndex() {
         var index = parseInt(this.getAttribute('initial-index'), 10);

         if (typeof index === 'number' && !isNaN(index)) {
           return Math.max(Math.min(index, this.itemCount - 1), 0);
         } else {
           return 0;
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: '_getCarouselItemSizeAttr',
       value: function _getCarouselItemSizeAttr() {
         var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
         var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

         return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_decomposeSizeString',
       value: function _decomposeSizeString(size) {
         var matches = size.match(/^(\d+)(px|%)/);

         return {
           number: parseInt(matches[1], 10),
           unit: matches[2]
         };
       }
     }, {
       key: '_setupInitialIndex',
       value: function _setupInitialIndex() {
         this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
         this._lastActiveIndex = this._getInitialIndex();
         this._scrollTo(this._scroll);
       }

       /**
        * @method setActiveIndex
        * @signature setActiveIndex(index, [options])
        * @param {Number} index
        *   [en]The index that the carousel should be set to.[/en]
        *   [ja]carousel[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be called after the animation is finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
        *   [ja]ons-carousel-itemindex[/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveIndex',
       value: function setActiveIndex(index) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

         index = Math.max(0, Math.min(index, this.itemCount - 1));
         var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
         var max = this._calculateMaxScroll();

         this._scroll = Math.max(0, Math.min(max, scroll));
         return this._scrollTo(this._scroll, options).then(function () {
           _this2._tryFirePostChangeEvent();
           return _this2;
         });
       }

       /**
        * @method getActiveIndex
        * @signature getActiveIndex()
        * @return {Number}
        *   [en]The current carousel item index.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'getActiveIndex',
       value: function getActiveIndex() {
         var scroll = this._scroll - (this._offset || 0);
         var count = this.itemCount;
         var size = this._getCarouselItemSize();

         if (scroll < 0) {
           return 0;
         }

         var i = void 0;
         for (i = 0; i < count; i++) {
           if (size * i <= scroll && size * (i + 1) > scroll) {
             return i;
           }
         }

         // max carousel index
         return i;
       }

       /**
        * @method next
        * @signature next([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show next `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'next',
       value: function next(options) {
         return this.setActiveIndex(this.getActiveIndex() + 1, options);
       }

       /**
        * @method prev
        * @signature prev([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show previous `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'prev',
       value: function prev(options) {
         return this.setActiveIndex(this.getActiveIndex() - 1, options);
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isEnabledChangeEvent',
       value: function _isEnabledChangeEvent() {
         var elementSize = this._getElementSize();
         var carouselItemSize = this._getCarouselItemSize();

         return this.autoScroll && elementSize === carouselItemSize;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isVertical',
       value: function _isVertical() {
         return this.getAttribute('direction') === 'vertical';
       }
     }, {
       key: '_prepareEventListeners',
       value: function _prepareEventListeners() {
         var _this3 = this;

         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1 });
         this._mutationObserver = new MutationObserver(function () {
           return _this3.refresh();
         });

         this._updateSwipeable();
         this._updateAutoRefresh();

         window.addEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._gestureDetector.dispose();
         this._gestureDetector = null;

         this._mutationObserver.disconnect();
         this._mutationObserver = null;

         window.removeEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         if (this._gestureDetector) {
           if (this.swipeable) {
             this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.on('dragend', this._boundOnDragEnd);
           } else {
             this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.off('dragend', this._boundOnDragEnd);
           }
         }
       }
     }, {
       key: '_updateAutoRefresh',
       value: function _updateAutoRefresh() {
         if (this._mutationObserver) {
           if (this.hasAttribute('auto-refresh')) {
             this._mutationObserver.observe(this, { childList: true });
           } else {
             this._mutationObserver.disconnect();
           }
         }
       }
     }, {
       key: '_tryFirePostChangeEvent',
       value: function _tryFirePostChangeEvent() {
         var currentIndex = this.getActiveIndex();

         if (this._lastActiveIndex !== currentIndex) {
           var lastActiveIndex = this._lastActiveIndex;
           this._lastActiveIndex = currentIndex;

           util.triggerElementEvent(this, 'postchange', {
             carousel: this,
             activeIndex: currentIndex,
             lastActiveIndex: lastActiveIndex
           });
         }
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var direction = event.gesture.direction;
         if (this._isVertical() && (direction === 'left' || direction === 'right') || !this._isVertical() && (direction === 'up' || direction === 'down')) {
           return;
         }

         event.stopPropagation();

         this._lastDragEvent = event;

         var scroll = this._scroll - this._getScrollDelta(event);
         this._scrollTo(scroll);
         event.gesture.preventDefault();

         this._tryFirePostChangeEvent();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var _this4 = this;

         this._currentElementSize = undefined;

         this._scroll = this._scroll - this._getScrollDelta(event);

         if (this._getScrollDelta(event) !== 0) {
           event.stopPropagation();
         }

         if (this._isOverScroll(this._scroll)) {
           var waitForAction = false;
           util.triggerElementEvent(this, 'overscroll', {
             carousel: this,
             activeIndex: this.getActiveIndex(),
             direction: this._getOverScrollDirection(),
             waitToReturn: function waitToReturn(promise) {
               waitForAction = true;
               promise.then(function () {
                 return _this4._scrollToKillOverScroll();
               });
             }
           });

           if (!waitForAction) {
             this._scrollToKillOverScroll();
           }
         } else {
           this._startMomentumScroll();
         }
         this._lastDragEvent = null;

         event.gesture.preventDefault();
       }

       /**
        * @param {Object} trait
        */

     }, {
       key: '_mixin',
       value: function _mixin(trait) {
         Object.keys(trait).forEach(function (key) {
           this[key] = trait[key];
         }.bind(this));
       }
     }, {
       key: '_startMomentumScroll',
       value: function _startMomentumScroll() {
         if (this._lastDragEvent) {
           var velocity = this._getScrollVelocity(this._lastDragEvent);
           var duration = 0.3;
           var scrollDelta = duration * 100 * velocity;
           var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

           this._scroll = scroll;

           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(this._scroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
         }
       }
     }, {
       key: '_normalizeScrollPosition',
       value: function _normalizeScrollPosition(scroll) {
         var max = this._calculateMaxScroll();

         if (!this.autoScroll) {
           return Math.max(0, Math.min(max, scroll));
         }
         var arr = [];
         var size = this._getCarouselItemSize();
         var nbrOfItems = this.itemCount;

         for (var i = 0; i < nbrOfItems; i++) {
           if (i * size + this._offset < max) {
             arr.push(i * size + this._offset);
           }
         }
         arr.push(max);

         arr.sort(function (left, right) {
           left = Math.abs(left - scroll);
           right = Math.abs(right - scroll);

           return left - right;
         });

         arr = arr.filter(function (item, pos) {
           return !pos || item != arr[pos - 1];
         });

         var lastScroll = this._lastActiveIndex * size + this._offset;
         var scrollRatio = Math.abs(scroll - lastScroll) / size;
         var result = arr[0];

         if (scrollRatio <= this.autoScrollRatio) {
           result = lastScroll;
         } else if (scrollRatio < 1.0) {
           if (arr[0] === lastScroll && arr.length > 1) {
             result = arr[1];
           }
         }

         return Math.max(0, Math.min(max, result));
       }

       /**
        * @return {Array}
        */

     }, {
       key: '_getCarouselItemElements',
       value: function _getCarouselItemElements() {
         return util.arrayFrom(this.children).filter(function (child) {
           return child.nodeName.toLowerCase() === 'ons-carousel-item';
         });
       }

       /**
        * @param {Number} scroll
        * @param {Object} [options]
        * @return {Promise} Resolves to the carousel element
        */

     }, {
       key: '_scrollTo',
       value: function _scrollTo(scroll) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isOverscrollable = this.overscrollable;

         var normalizeScroll = function normalizeScroll(scroll) {
           var ratio = 0.35;

           if (scroll < 0) {
             return isOverscrollable ? Math.round(scroll * ratio) : 0;
           }

           var maxScroll = _this5._calculateMaxScroll();
           if (maxScroll < scroll) {
             return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
           }

           return scroll;
         };

         return new Promise(function (resolve) {
           animit(_this5._getCarouselItemElements()).queue({
             transform: _this5._generateScrollTransform(normalizeScroll(scroll))
           }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
             if (options.callback instanceof Function) {
               options.callback();
             }
             resolve();
           });
         });
       }
     }, {
       key: '_calculateMaxScroll',
       value: function _calculateMaxScroll() {
         var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
         return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
       }
     }, {
       key: '_isOverScroll',
       value: function _isOverScroll(scroll) {
         if (scroll < 0 || scroll > this._calculateMaxScroll()) {
           return true;
         }
         return false;
       }
     }, {
       key: '_getOverScrollDirection',
       value: function _getOverScrollDirection() {
         if (this._isVertical()) {
           return this._scroll <= 0 ? 'up' : 'down';
         } else {
           return this._scroll <= 0 ? 'left' : 'right';
         }
       }
     }, {
       key: '_scrollToKillOverScroll',
       value: function _scrollToKillOverScroll() {
         var duration = 0.4;

         if (this._scroll < 0) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(0)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = 0;
           return;
         }

         var maxScroll = this._calculateMaxScroll();

         if (maxScroll < this._scroll) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(maxScroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = maxScroll;
           return;
         }

         return;
       }

       /**
        * @property itemCount
        * @readonly
        * @type {Number}
        * @description
        *   [en]The number of carousel items.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
        *   [ja]ons-carousel-itemons-carousel[/ja]
        */
       value: function refresh() {
         // Bug fix
         if (this._getCarouselItemSize() === 0) {
           return;
         }

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
         this._setup();

         if (this._lastState && this._lastState.width > 0) {
           var scroll = this._scroll; // - this._offset;

           if (this._isOverScroll(scroll)) {
             this._scrollToKillOverScroll();
           } else {
             if (this.autoScroll) {
               scroll = this._normalizeScrollPosition(scroll);
             }

             this._scrollTo(scroll);
           }
         }

         this._saveLastState();

         util.triggerElementEvent(this, 'refresh', { carousel: this });
       }

       /**
        * @method first
        * @signature first()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show first `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'first',
       value: function first(options) {
         return this.setActiveIndex(0, options);
       }

       /**
        * @method last
        * @signature last()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja]Resolves to the carousel element[/ja]
        * @description
        *   [en]Show last ons-carousel item.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'last',
       value: function last(options) {
         this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this._prepareEventListeners();

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();

         // Fix rendering glitch on Android 4.1
         if (this.offsetHeight === 0) {
           setImmediate(function () {
             return _this6.refresh();
           });
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'swipeable':
             this._updateSwipeable();
             break;
           case 'auto-refresh':
             this._updateAutoRefresh();
             break;
           case 'direction':
             this._onDirectionChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._removeEventListeners();
       }

       /**
        * @property autoScrollRatio
        * @type {Number}
        * @description
        *   [en]The current auto scroll ratio. [/en]
        *   [ja]ratio[/ja]
        */

     }, {
       key: 'itemCount',
       get: function get() {
         return this._getCarouselItemElements().length;
       }
     }, {
       key: 'autoScrollRatio',
       get: function get() {
         var attr = this.getAttribute('auto-scroll-ratio');

         if (!attr) {
           return 0.5;
         }

         var scrollRatio = parseFloat(attr);
         if (scrollRatio < 0.0 || scrollRatio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         return isNaN(scrollRatio) ? 0.5 : scrollRatio;
       },
       set: function set(ratio) {
         if (ratio < 0.0 || ratio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         this.setAttribute('auto-scroll-ratio', ratio);
       }

       /**
        * @property swipeable
        * @type {Boolean}
        * @description
        *   [en]true if the carousel is swipeable.[/en]
        *   [ja]swipeabletrue[/ja]
        */

     }, {
       key: 'swipeable',
       get: function get() {
         return this.hasAttribute('swipeable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'swipeable', value);
       }

       /**
        * @property autoScroll
        * @type {Boolean}
        * @description
        *   [en]true if auto scroll is enabled.[/en]
        *   [ja]true[/ja]
        */

     }, {
       key: 'autoScroll',
       get: function get() {
         return this.hasAttribute('auto-scroll');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'auto-scroll', value);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this.hasAttribute('disabled');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       }

       /**
        * @property overscrollable
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is overscrollable or not.[/en]
        *   [ja]overscrolltrue[/ja]
        */

     }, {
       key: 'overscrollable',
       get: function get() {
         return this.hasAttribute('overscrollable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'overscrollable', value);
       }

       /**
        * @property centered
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is centered or not.[/en]
        *   [ja]centeredtrue[/ja]
        */

     }, {
       key: 'centered',
       get: function get() {
         return this.hasAttribute('centered');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'centered', value);
       }
     }]);
     return CarouselElement;
   }(BaseElement);

   window.OnsCarouselElement = document.registerElement('ons-carousel', {
     prototype: CarouselElement.prototype
   });

   /**
    * @element ons-col
    * @category grid
    * @description
    *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
    *   [ja]ons-row[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-column[/ja]
    * @codepen GgujC {wide}
    * @guide layouting [en]Layouting guide[/en][ja][/ja]
    * @seealso ons-row
    *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
    *   [ja]ons-row[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
    *   [ja]"top", "center", "bottom"[/ja]
    */

   /**
    * @attribute width
    * @type {String}
    * @description
    *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
    *   [ja]10%50px[/ja]
    */

   var ColumnElement = function (_BaseElement) {
     babelHelpers.inherits(ColumnElement, _BaseElement);

     function ColumnElement() {
       babelHelpers.classCallCheck(this, ColumnElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ColumnElement).apply(this, arguments));
     }

     babelHelpers.createClass(ColumnElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (this.getAttribute('width')) {
           this._updateWidth();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'width') {
           this._updateWidth();
         }
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         var width = this.getAttribute('width');
         if (typeof width === 'string') {
           width = ('' + width).trim();
           width = width.match(/^\d+$/) ? width + '%' : width;

           this.style.webkitBoxFlex = '0';
           this.style.webkitFlex = '0 0 ' + width;
           this.style.mozBoxFlex = '0';
           this.style.mozFlex = '0 0 ' + width;
           this.style.msFlex = '0 0 ' + width;
           this.style.flex = '0 0 ' + width;
           this.style.maxWidth = width;
         }
       }
     }]);
     return ColumnElement;
   }(BaseElement);

   window.OnsColElement = document.registerElement('ons-col', {
     prototype: ColumnElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var DialogAnimator = function () {
     function DialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, DialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(DialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return DialogAnimator;
   }();

   /**
    * Android style animator for dialog.
    */
   var AndroidDialogAnimator = function (_DialogAnimator) {
     babelHelpers.inherits(AndroidDialogAnimator, _DialogAnimator);

     function AndroidDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
       babelHelpers.classCallCheck(this, AndroidDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidDialogAnimator;
   }(DialogAnimator);

   /**
    * iOS style animator for dialog.
    */
   var IOSDialogAnimator = function (_DialogAnimator2) {
     babelHelpers.inherits(IOSDialogAnimator, _DialogAnimator2);

     function IOSDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
       babelHelpers.classCallCheck(this, IOSDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSDialogAnimator;
   }(DialogAnimator);

   /**
    * Slide animator for dialog.
    */
   var SlideDialogAnimator = function (_DialogAnimator3) {
     babelHelpers.inherits(SlideDialogAnimator, _DialogAnimator3);

     function SlideDialogAnimator() {
       var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref4$timing = _ref4.timing;
       var timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing;
       var _ref4$delay = _ref4.delay;
       var delay = _ref4$delay === undefined ? 0 : _ref4$delay;
       var _ref4$duration = _ref4.duration;
       var duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
       babelHelpers.classCallCheck(this, SlideDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SlideDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(SlideDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return SlideDialogAnimator;
   }(DialogAnimator);

   var scheme$6 = {
     '.dialog': 'dialog--*',
     '.dialog-container': 'dialog-container--*',
     '.dialog-mask': 'dialog-mask--*'
   };

   var templateSource = util.createElement('\n  <div>\n    <div class="dialog-mask"></div>\n    <div class="dialog">\n      <div class="dialog-container"></div>\n    </div>\n  </div>\n');

   var _animatorDict$1 = {
     'default': function _default() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'slide': SlideDialogAnimator,
     'none': DialogAnimator
   };

   /**
    * @element ons-dialog
    * @category dialog
    * @description
    *   [en]
    *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `<ons.createDialog(template)` utility function and the `<ons-template>` tag.
    *
    *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
    *
    *     It will automatically be displayed as Material Design when running on an Android device.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design dialog.[/en]
    *   [ja][/ja]
    * @codepen zxxaGa
    * @guide UsingDialog
    *   [en]Learn how to use the dialog component.[/en]
    *   [ja][/ja]
    * @seealso ons-alert-dialog
    *   [en]`<ons-alert-dialog>` component[/en]
    *   [ja]ons-alert-dialog[/ja]
    * @seealso ons-popover
    *   [en]`<ons-popover>` component[/en]
    *   [ja]ons-popover[/ja]
    * @example
    * <ons-dialog id="dialog">
    *   <p>This is a dialog!</p>
    * </ons-dialog>
    *
    * <script>
    *   document.getElementById('dialog').show();
    * </script>
    */

   var DialogElement = function (_BaseElement) {
     babelHelpers.inherits(DialogElement, _BaseElement);

     function DialogElement() {
       babelHelpers.classCallCheck(this, DialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(DialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(DialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$1,
           baseClass: DialogAnimator,
           baseClassName: 'DialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         if (this._dialog) {
           return;
         }

         var template = templateSource.cloneNode(true);
         var dialog = template.children[1];

         while (this.firstChild) {
           dialog.children[0].appendChild(this.firstChild);
         }

         while (template.firstChild) {
           this.appendChild(template.firstChild);
         }

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         this.setAttribute('status-bar-fill', '');

         ModifierUtil.initModifier(this, scheme$6);
       }

       /**
        * @property onDeviceBackButton
        * @readonly
        * @type {Object}
        * @description
        *   [en]Retrieve the back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.cancelable) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this3 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this3._running = false;
               util.triggerElementEvent(_this3, 'cancel');
             }
           });
         }
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
        *   [ja]"none", "fade", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *  [en]Show the dialog.[/en]
        *  [ja][/ja]
        * @return {Promise} Resolves to the displayed element.
        */

     }, {
       key: 'show',
       value: function show() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           dialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               _this4.style.display = 'block';
               _this4._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.show(_this4, function () {
                     _this4._visible = true;
                     unlock();

                     util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
        *   [ja]"none", "fade", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this5 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           dialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this5._doorLock.lock();
               var animator = _this5._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this5, function () {
                   animator.hide(_this5, function () {
                     _this5.style.display = 'none';
                     _this5._visible = false;
                     unlock();

                     util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                     callback();
                     resolve(_this5);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this5._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$6);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        * [en]Fired just before the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        * [en]Fired just after the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        * [en]Fired just before the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.dialog-mask');
       }
     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.dialog');
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }]);
     return DialogElement;
   }(BaseElement);

   var OnsDialogElement = window.OnsDialogElement = document.registerElement('ons-dialog', {
     prototype: DialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof DialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
     }
     _animatorDict$1[name] = Animator;
   };

   OnsDialogElement.DialogAnimator = DialogAnimator;

   var scheme$7 = {
     '': 'fab--*'
   };

   /**
    * @element ons-fab
    * @category fab
    * @description
    *   [en]
    *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
    *
    *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
    *   [/en]
    *   [ja][/ja]
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
    *   [ja][/ja]
    */

   var FabElement = function (_BaseElement) {
     babelHelpers.inherits(FabElement, _BaseElement);

     function FabElement() {
       babelHelpers.classCallCheck(this, FabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FabElement).apply(this, arguments));
     }

     babelHelpers.createClass(FabElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.classList.contains('fab')) {
           return;
         }

         this.classList.add('fab');

         var content = document.createElement('span');
         content.classList.add('fab__icon');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
             content.appendChild(element);
           }
         });

         this.appendChild(content);

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$7);

         this._updatePosition();

         this.hide();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$7);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'position':
             this._updatePosition();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         this.show();
       }
     }, {
       key: '_hide',
       value: function _hide() {
         this.hide();
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *  [en]Show the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(1)';
         this.style.webkitTransform = 'scale(1)';
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *  [en]Hide the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(0)';
         this.style.webkitTransform = 'scale(0)';
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'toggle',


       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle the visibility of the button.[/en]
        *   [ja][/ja]
        */
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this.style.transform === 'scale(1)' && this.style.display !== 'none';
       }
     }]);
     return FabElement;
   }(BaseElement);

   window.OnsFabElement = document.registerElement('ons-fab', {
     prototype: FabElement.prototype
   });

   /**
    * @element ons-gesture-detector
    * @category gesture
    * @description
    *   [en]Component to detect finger gestures within the wrapped element. See the guide for more details.[/en]
    *   [ja][/ja]
    * @guide DetectingFingerGestures
    *   [en]Detecting finger gestures[/en]
    *   [ja][/ja]
    * @example
    * <ons-gesture-detector style="height: 100%; width: 100%;">
    *   ...
    * </ons-gesture-detector>
    */

   var GestureDetectorElement = function (_BaseElement) {
     babelHelpers.inherits(GestureDetectorElement, _BaseElement);

     function GestureDetectorElement() {
       babelHelpers.classCallCheck(this, GestureDetectorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(GestureDetectorElement).apply(this, arguments));
     }

     babelHelpers.createClass(GestureDetectorElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._gestureDetector = new GestureDetector(this);
       }
     }]);
     return GestureDetectorElement;
   }(BaseElement);

   window.OnsGestureDetectorElement = document.registerElement('ons-gesture-detector', {
     prototype: GestureDetectorElement.prototype
   });

   /**
    * @element ons-icon
    * @category icon
    * @description
    *   [en]
    *     Displays an icon. The following icon suites are available:
    *
    *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
    *     * [Ionicons](http://ionicons.com/)
    *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
    *   [/en]
    *   [ja][/ja]
    * @codepen xAhvg
    * @guide UsingIcons [en]Using icons[/en][ja][/ja]
    * @example
    * <ons-icon
    *   icon="md-car"
    *   size="20px"
    *   style="color: red">
    * </ons-icon>
    *
    * <ons-button>
    *   <ons-icon icon="md-car"></ons-icon>
    *   Car
    * </ons-button>
    */

   var IconElement = function (_BaseElement) {
     babelHelpers.inherits(IconElement, _BaseElement);

     function IconElement() {
       babelHelpers.classCallCheck(this, IconElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IconElement).apply(this, arguments));
     }

     babelHelpers.createClass(IconElement, [{
       key: 'createdCallback',


       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
        *
        *     See all available icons on their respective sites:
        *
        *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
        *     * [Ionicons](http://ionicons.com)
        *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
        *
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit, material:md-edit">
        *     </ons-icon>
        *     ```
        *
        *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute size
        * @type {String}
        * @description
        *   [en]
        *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit"
        *       size="32px, material:24px">
        *     </ons-icon>
        *     ```
        *
        *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute rotate
        * @type {Number}
        * @description
        *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
        *   [ja]90, 180, 270[/ja]
        */

       /**
        * @attribute fixed-width
        * @type {Boolean}
        * @default false
        * @description
        *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute spin
        * @description
        *   [en]Specify whether the icon should be spinning.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
           this._update();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this._update();
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_update',
       value: function _update() {
         var _this2 = this;

         this._cleanClassAttribute();

         var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size'));

         var classList = _buildClassAndStyle2.classList;
         var style = _buildClassAndStyle2.style;

         util.extend(this.style, style);

         classList.forEach(function (className) {
           return _this2.classList.add(className);
         });
       }
     }, {
       key: '_getAttribute',
       value: function _getAttribute(attr) {
         var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
         var def = parts[0];
         var md = parts[1];
         md = (md || '').split(/\s*:\s*/);
         return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
       }

       /**
        * Remove unneeded class value.
        */

     }, {
       key: '_cleanClassAttribute',
       value: function _cleanClassAttribute() {
         var _this3 = this;

         util.arrayFrom(this.classList).filter(function (className) {
           return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
           );
         }).forEach(function (className) {
           return _this3.classList.remove(className);
         });

         this.classList.remove('zmdi');
         this.classList.remove('ons-icon--ion');
       }
     }, {
       key: '_buildClassAndStyle',
       value: function _buildClassAndStyle(iconName, size) {
         var classList = ['ons-icon'];
         var style = {};

         // Icon
         if (iconName.indexOf('ion-') === 0) {
           classList.push(iconName);
           classList.push('ons-icon--ion');
         } else if (iconName.indexOf('fa-') === 0) {
           classList.push(iconName);
           classList.push('fa');
         } else if (iconName.indexOf('md-') === 0) {
           classList.push('zmdi');
           classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
         } else {
           classList.push('fa');
           classList.push('fa-' + iconName);
         }

         // Size
         if (size.match(/^[1-5]x|lg$/)) {
           classList.push('fa-' + size);
           this.style.removeProperty('font-size');
         } else {
           style.fontSize = size;
         }

         return {
           classList: classList,
           style: style
         };
       }
     }]);
     return IconElement;
   }(BaseElement);

   window.OnsIconElement = document.registerElement('ons-icon', {
     prototype: IconElement.prototype
   });

   /**
    * @element ons-lazy-repeat
    * @category lazy-repeat
    * @description
    *   [en]
    *     Using this component a list with millions of items can be rendered without a drop in performance.
    *     It does that by "lazily" loading elements into the DOM when they come into view and
    *     removing items from the DOM when they are not visible.
    *   [/en]
    *   [ja]
    *     DOM
    *     
    *     
    *   [/ja]
    * @codepen QwrGBm
    * @seealso ons-list
    *   [en]The `<ons-list>` element is used to render a list.[/en]
    *   [ja][/ja]
    * @guide UsingLazyRepeat
    *   [en]How to use Lazy Repeat[/en]
    *   [ja][/ja]
    * @example
    * <script>
    *   window.addEventListener('load', function() {
    *     var lazyRepeat = document.querySelector('#list');
    *     lazyRepeat.delegate = {
    *      createItemContent: function(i, template) {
    *        var dom = template.cloneNode(true);
    *        dom.innerText = i;
    *
    *        return dom;
    *      },
    *      countItems: function() {
    *        return 10000000;
    *      },
    *      destroyItem: function(index, item) {
    *        console.log('Destroyed item with index: ' + index);
    *      }
    *     };
    *   });
    * </script>
    *
    * <ons-list id="list">
    *   <ons-lazy-repeat>
    *     <ons-list-item></ons-list-item>
    *   </ons-lazy-repeat>
    * </ons-list>
    */

   var LazyRepeatElement = function (_BaseElement) {
     babelHelpers.inherits(LazyRepeatElement, _BaseElement);

     function LazyRepeatElement() {
       babelHelpers.classCallCheck(this, LazyRepeatElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LazyRepeatElement).apply(this, arguments));
     }

     babelHelpers.createClass(LazyRepeatElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.style.display = 'none';
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         util.updateParentPosition(this);

         // not very good idea and also not documented
         if (this.hasAttribute('delegate')) {
           this.delegate = window[this.getAttribute('delegate')];
         }
       }

       /**
        * @property delegate
        * @type {Object}
        * @description
        *  [en]Specify a delegate object to load and unload item elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property delegate.createItemContent
        * @type {Function}
        * @description
        *   [en]
        *     This function should return a `HTMLElement`.
        *
        *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property delegate.countItems
        * @type {Function}
        * @description
        *   [en]Should return the number of items in the list.[/en]
        *   [ja][/ja]
        */

       /**
        * @property delegate.calculateItemHeight
        * @type {Function}
        * @description
        *   [en]
        *     Should return the height of an item. The index is provided as an argument.
        *
        *     This is important when rendering lists where the items have different height.
        *
        *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property delegate.destroyItem
        * @type {Function}
        * @description
        *   [en]
        *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
        *
        *     The function is optional but may be important in order to avoid memory leaks.
        *   [/en]
        *   [ja][/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Refresh the list. Use this method when the data has changed.[/en]
        *   [ja][/ja]
        */
       value: function refresh() {
         this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._lazyRepeatProvider) {
           this._lazyRepeatProvider.destroy();
           this._lazyRepeatProvider = null;
         }
       }
     }, {
       key: 'delegate',
       set: function set(userDelegate) {
         this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

         if (!this._templateElement && this.children[0]) {
           this._templateElement = this.removeChild(this.children[0]);
         }

         var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
         this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
       },
       get: function get() {
         throw new Error('This property can only be used to set the delegate object.');
       }
     }]);
     return LazyRepeatElement;
   }(BaseElement);

   window.OnsLazyRepeatElement = document.registerElement('ons-lazy-repeat', {
     prototype: LazyRepeatElement.prototype
   });

   var scheme$8 = { '': 'list__header--*' };

   /**
    * @element ons-list-header
    * @category list
    * @description
    *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list
    *   [en]The `<ons-list>` component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-item
    *   [en]The `<ons-list-item>` component[/en]
    *   [ja]ons-list-item[/ja]
    * @guide UsingList [en]Using lists[/en][ja][/ja]
    * @codepen yxcCt
    * @modifier material
    *   [en]Display a Material Design list header.[/en]
    *   [ja][/ja]
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListHeaderElement = function (_BaseElement) {
     babelHelpers.inherits(ListHeaderElement, _BaseElement);

     function ListHeaderElement() {
       babelHelpers.classCallCheck(this, ListHeaderElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListHeaderElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListHeaderElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list header.[/en]
        *   [ja][/ja]
        */
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list__header');
         ModifierUtil.initModifier(this, scheme$8);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$8);
         }
       }
     }]);
     return ListHeaderElement;
   }(BaseElement);

   window.OnsListHeaderElement = document.registerElement('ons-list-header', {
     prototype: ListHeaderElement.prototype
   });

   var scheme$9 = {
     '.list__item': 'list__item--*',
     '.list__item__left': 'list__item--*__left',
     '.list__item__center': 'list__item--*__center',
     '.list__item__right': 'list__item--*__right',
     '.list__item__label': 'list__item--*__label',
     '.list__item__title': 'list__item--*__title',
     '.list__item__subtitle': 'list__item--*__subtitle',
     '.list__item__thumbnail': 'list__item--*__thumbnail',
     '.list__item__icon': 'list__item--*__icon'
   };

   /**
    * @element ons-list-item
    * @category list
    * @modifier tappable
    *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
    *   [ja][/ja]
    * @modifier chevron
    *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
    *   [ja][/ja]
    * @modifier longdivider
    *   [en]Displays a long horizontal divider between items.[/en]
    *   [ja][/ja]
    * @modifier nodivider
    *   [en]Removes the divider between list items.[/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design list item.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
    *
    *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
    *
    *     ```
    *     <ons-list-item>
    *       <div class="left">Left</div>
    *       <div class="center">Center</div>
    *       <div class="right">Right</div>
    *     </ons-list-item>
    *     ```
    *
    *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
    *   [/en]
    *   [ja][/ja]
    * @seealso ons-list
    *   [en]ons-list component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @codepen yxcCt
    * @example
    * <ons-list-item>
    *   <div class="left">
    *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
    *   </div>
    *   <div class="center">
    *     <div class="list__item__title">Title</div>
    *     <div class="list__item__subtitle">Subtitle</div>
    *   </div>
    *   <div class="right">
    *     <ons-switch></ons-switch>
    *   </div>
    * </ons-list-item>
    */

   var ListItemElement = function (_BaseElement) {
     babelHelpers.inherits(ListItemElement, _BaseElement);

     function ListItemElement() {
       babelHelpers.classCallCheck(this, ListItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListItemElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute lock-on-drag
        * @type {String}
        * @description
        *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tappable
        * @type {Boolean}
        * @description
        *   [en]Makes the element react to taps.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tap-background-color
        * @type {Color}
        * @description
        *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('list__item');

         var left = void 0,
             center = void 0,
             right = void 0;

         for (var i = 0; i < this.children.length; i++) {
           var el = this.children[i];

           if (el.classList.contains('left')) {
             el.classList.add('list__item__left');
             left = el;
           } else if (el.classList.contains('center')) {
             center = el;
           } else if (el.classList.contains('right')) {
             el.classList.add('list__item__right');
             right = el;
           }
         }

         if (!center) {
           center = document.createElement('div');

           if (!left && !right) {
             while (this.childNodes[0]) {
               center.appendChild(this.childNodes[0]);
             }
           } else {
             for (var i = this.childNodes.length - 1; i >= 0; i--) {
               var el = this.childNodes[i];
               if (el !== left && el !== right) {
                 center.insertBefore(el, center.firstChild);
               }
             }
           }

           this.insertBefore(center, right || null);
         }

         center.classList.add('center');
         center.classList.add('list__item__center');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$9);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$9);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('drag', this._onDrag);
         this.addEventListener('touchstart', this._onTouch);
         this.addEventListener('mousedown', this._onTouch);
         this.addEventListener('touchend', this._onRelease);
         this.addEventListener('touchmove', this._onRelease);
         this.addEventListener('touchcancel', this._onRelease);
         this.addEventListener('mouseup', this._onRelease);
         this.addEventListener('mouseout', this._onRelease);
         this.addEventListener('touchleave', this._onRelease);

         this._originalBackgroundColor = this.style.backgroundColor;

         this.tapped = false;
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('drag', this._onDrag);
         this.removeEventListener('touchstart', this._onTouch);
         this.removeEventListener('mousedown', this._onTouch);
         this.removeEventListener('touchend', this._onRelease);
         this.removeEventListener('touchmove', this._onRelease);
         this.removeEventListener('touchcancel', this._onRelease);
         this.removeEventListener('mouseup', this._onRelease);
         this.removeEventListener('mouseout', this._onRelease);
         this.removeEventListener('touchleave', this._onRelease);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var gesture = event.gesture;
         // Prevent vertical scrolling if the users pans left or right.
         if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
           gesture.preventDefault();
         }
       }
     }, {
       key: '_onTouch',
       value: function _onTouch() {
         if (this.tapped) {
           return;
         }

         this.tapped = true;

         this.style.transition = this._transition;
         this.style.webkitTransition = this._transition;
         this.style.MozTransition = this._transition;

         if (this._tappable) {
           if (this.style.backgroundColor) {
             this._originalBackgroundColor = this.style.backgroundColor;
           }

           this.style.backgroundColor = this._tapBackgroundColor;
           this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease() {
         this.tapped = false;

         this.style.transition = '';
         this.style.webkitTransition = '';
         this.style.MozTransition = '';

         this.style.backgroundColor = this._originalBackgroundColor || '';
         this.style.boxShadow = '';
       }
     }, {
       key: '_shouldLockOnDrag',
       value: function _shouldLockOnDrag() {
         return this.hasAttribute('lock-on-drag');
       }
     }, {
       key: '_transition',
       get: function get() {
         return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
       }
     }, {
       key: '_tappable',
       get: function get() {
         return this.hasAttribute('tappable');
       }
     }, {
       key: '_tapBackgroundColor',
       get: function get() {
         return this.getAttribute('tap-background-color') || '#d9d9d9';
       }
     }]);
     return ListItemElement;
   }(BaseElement);

   window.OnsListItemElement = document.registerElement('ons-list-item', {
     prototype: ListItemElement.prototype
   });

   var scheme$10 = { '': 'list--*' };

   /**
    * @element ons-list
    * @category list
    * @modifier inset
    *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
    *   [ja][/ja]
    * @modifier noborder
    *   [en]A list with no borders at the top and bottom.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-item
    *   [en]ons-list-item component[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @codepen yxcCt
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListElement = function (_BaseElement) {
     babelHelpers.inherits(ListElement, _BaseElement);

     function ListElement() {
       babelHelpers.classCallCheck(this, ListElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list');
         ModifierUtil.initModifier(this, scheme$10);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$10);
         }
       }
     }]);
     return ListElement;
   }(BaseElement);

   window.OnsListElement = document.registerElement('ons-list', {
     prototype: ListElement.prototype
   });

   var scheme$11 = {
     '.text-input': 'text-input--*',
     '.text-input__label': 'text-input--*__label',
     '.radio-button': 'radio-button--*',
     '.radio-button__input': 'radio-button--*__input',
     '.radio-button__checkmark': 'radio-button--*__checkmark',
     '.checkbox': 'checkbox--*',
     '.checkbox__input': 'checkbox--*__input',
     '.checkbox__checkmark': 'checkbox--*__checkmark'
   };

   var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

   /**
    * @element ons-input
    * @category input
    * @modifier material
    *  [en]Displays a Material Design input.[/en]
    *  [ja][/ja]
    * @modifier underbar
    *  [en]Displays a horizontal line underneath a text input.[/en]
    *  [ja][/ja]
    * @description
    *  [en]
    *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
    *
    *    The component will automatically render as a Material Design input on Android devices.
    *
    *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element..
    *  [/en]
    *  [ja][/ja]
    * @codepen ojQxLj
    * @seealso ons-range
    *   [en]The `<ons-range>` element is used to display a range slider.[/en]
    *   [ja][/ja]
    * @seealso ons-switch
    *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
    *   [ja][/ja]
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @example
    * <ons-input placeholder="Username" float></ons-input>
    * <ons-input type="checkbox" checked></ons-input>
    */

   var InputElement = function (_BaseElement) {
     babelHelpers.inherits(InputElement, _BaseElement);

     function InputElement() {
       babelHelpers.classCallCheck(this, InputElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(InputElement).apply(this, arguments));
     }

     babelHelpers.createClass(InputElement, [{
       key: 'createdCallback',


       /**
        * @attribute placeholder
        * @type {String}
        * @description
        *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute float
        * @description
        *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute type
        * @type {String}
        * @description
        *  [en]
        *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
        *
        *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
        *  [/en]
        *  [ja][/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the "id" attribute of the inner <input> element. This is useful when using <label for="..."> elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute content-left
        * @description
        *  [en]The HTML content of `<ons-input>` is placed before the actual input as a label. Omit this to display it after the input.[/en]
        *  [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
         });

         this._boundOnInput = this._onInput.bind(this);
         this._boundOnFocusin = this._onFocusin.bind(this);
         this._boundOnFocusout = this._onFocusout.bind(this);
         this._boundDelegateEvent = this._delegateEvent.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.children.length !== 0) {
           return;
         }

         var helper = document.createElement('span');
         helper.classList.add('_helper');

         var container = document.createElement('label');
         container.appendChild(document.createElement('input'));
         container.appendChild(helper);

         var label = document.createElement('span');
         label.classList.add('input-label');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           return label.appendChild(element);
         });
         this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

         this.appendChild(container);

         switch (this.getAttribute('type')) {
           case 'checkbox':
             this.classList.add('checkbox');
             this._input.classList.add('checkbox__input');
             this._helper.classList.add('checkbox__checkmark');
             this._updateBoundAttributes();
             break;

           case 'radio':
             this.classList.add('radio-button');
             this._input.classList.add('radio-button__input');
             this._helper.classList.add('radio-button__checkmark');
             this._updateBoundAttributes();
             break;

           default:
             this._input.classList.add('text-input');
             this._helper.classList.add('text-input__label');
             this._input.parentElement.classList.add('text-input__container');

             this._updateLabel();
             this._updateLabelColor();
             this._updateBoundAttributes();
             this._updateLabelClass();
             break;
         }

         if (this.hasAttribute('input-id')) {
           this._input.id = this.getAttribute('input-id');
         }

         ModifierUtil.initModifier(this, scheme$11);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           return contentReady(this, function () {
             return ModifierUtil.onModifierChanged(last, current, _this3, scheme$11);
           });
         } else if (name === 'placeholder') {
           return contentReady(this, function () {
             return _this3._updateLabel();
           });
         }if (name === 'input-id') {
           contentReady(this, function () {
             return _this3._input.id = current;
           });
         }if (name === 'checked') {
           this.checked = current !== null;
         } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
           return contentReady(this, function () {
             return _this3._updateBoundAttributes();
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
             _this4._input.addEventListener('input', _this4._boundOnInput);
             _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
             _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
           }

           _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
           _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.removeEventListener('input', _this5._boundOnInput);
           _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
           _this5._input.removeEventListener('focusout', _this5._boundOnFocusout);
           _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
           _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
         });
       }
     }, {
       key: '_setLabel',
       value: function _setLabel(value) {
         if (typeof this._helper.textContent !== 'undefined') {
           this._helper.textContent = value;
         } else {
           this._helper.innerText = value;
         }
       }
     }, {
       key: '_updateLabel',
       value: function _updateLabel() {
         this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this6 = this;

         INPUT_ATTRIBUTES.forEach(function (attr) {
           if (_this6.hasAttribute(attr)) {
             _this6._input.setAttribute(attr, _this6.getAttribute(attr));
           } else {
             _this6._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_updateLabelColor',
       value: function _updateLabelColor() {
         if (this.value.length > 0 && this._input === document.activeElement) {
           this._helper.style.color = '';
         } else {
           this._helper.style.color = 'rgba(0, 0, 0, 0.5)';
         }
       }
     }, {
       key: '_updateLabelClass',
       value: function _updateLabelClass() {
         if (this.value === '') {
           this._helper.classList.remove('text-input__label--active');
         } else {
           this._helper.classList.add('text-input__label--active');
         }
       }
     }, {
       key: '_delegateEvent',
       value: function _delegateEvent(event) {
         var e = new CustomEvent(event.type, {
           bubbles: false,
           cancelable: true
         });

         return this.dispatchEvent(e);
       }
     }, {
       key: '_onInput',
       value: function _onInput(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusin',
       value: function _onFocusin(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusout',
       value: function _onFocusout(event) {
         this._updateLabelColor();
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_helper',
       get: function get() {
         return this.querySelector('._helper');
       }

       /**
        * @property value
        * @type {String}
        * @description
        *   [en]The current value of the input.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input === null ? this.getAttribute('value') : this._input.value;
       },
       set: function set(val) {
         var _this7 = this;

         this.setAttribute('value', val);

         contentReady(this, function () {
           _this7._input.value = val;
           _this7._onInput();
         });

         return val;
       }

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'checked',
       get: function get() {
         return this._input.checked;
       },
       set: function set(val) {
         var _this8 = this;

         contentReady(this, function () {
           _this8._input.checked = val;
         });
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the input is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }, {
       key: '_isTextInput',
       get: function get() {
         return this.type !== 'radio' && this.type !== 'checkbox';
       }
     }, {
       key: 'type',
       get: function get() {
         return this.getAttribute('type');
       }
     }]);
     return InputElement;
   }(BaseElement);

   window.OnsInputElement = document.registerElement('ons-input', {
     prototype: InputElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModalAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function ModalAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, ModalAnimator);

       this.delay = 0;
       this.duration = 0.2;

       this.timing = options.timing || this.timing;
       this.duration = options.duration !== undefined ? options.duration : this.duration;
       this.delay = options.delay !== undefined ? options.delay : this.delay;
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(ModalAnimator, [{
       key: "show",
       value: function show(modal, callback) {
         callback();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: "hide",
       value: function hide(modal, callback) {
         callback();
       }
     }]);
     return ModalAnimator;
   }();

   /**
    * iOS style animator for dialog.
    */

   var FadeModalAnimator = function (_ModalAnimator) {
     babelHelpers.inherits(FadeModalAnimator, _ModalAnimator);

     function FadeModalAnimator(options) {
       babelHelpers.classCallCheck(this, FadeModalAnimator);

       options.timing = options.timing || 'linear';
       options.duration = options.duration || '0.3';
       options.delay = options.delay || 0;

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FadeModalAnimator).call(this, options));
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(FadeModalAnimator, [{
       key: 'show',
       value: function show(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 1
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }
     }]);
     return FadeModalAnimator;
   }(ModalAnimator);

   var scheme$12 = {
     '': 'modal--*',
     'modal__content': 'modal--*__content'
   };

   var _animatorDict$2 = {
     'default': ModalAnimator,
     'fade': FadeModalAnimator,
     'none': ModalAnimator
   };

   /**
    * @element ons-modal
    * @category modal
    * @description
    *   [en]
    *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
    *
    *     This component can be used to block user input while some operation is running or to show some information to the user.
    *   [/en]
    *   [ja]
    *     
    *     
    *   [/ja]
    * @guide UsingModal
    *   [en]Using ons-modal component[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @seealso ons-dialog
    *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
    *   [ja][/ja]
    * @codepen devIg
    * @example
    * <ons-modal id="modal">
    *   Modal content
    * </ons-modal>
    * <script>
    *   var modal = document.getElementById('modal');
    *   modal.show();
    * </script>
    */

   var ModalElement = function (_BaseElement) {
     babelHelpers.inherits(ModalElement, _BaseElement);

     function ModalElement() {
       babelHelpers.classCallCheck(this, ModalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ModalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ModalElement, [{
       key: 'createdCallback',


       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
        *  [ja]"none""fade"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._doorLock = new DoorLock();

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$2,
           baseClass: ModalAnimator,
           baseClassName: 'ModalAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton() {
         // Do nothing and stop device-backbutton handler chain.
         return;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this.style.display = 'none';
         this.classList.add('modal');

         if (!util.findChild(this, '.modal__content')) {
           var content = document.createElement('div');
           content.classList.add('modal__content');

           while (this.childNodes[0]) {
             var node = this.childNodes[0];
             this.removeChild(node);
             content.insertBefore(node, null);
           }

           this.appendChild(content);
         }

         ModifierUtil.initModifier(this, scheme$12);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         setImmediate(this._ensureNodePosition.bind(this));
         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));
       }
     }, {
       key: '_ensureNodePosition',
       value: function _ensureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }

         if (this.parentNode.nodeName.toLowerCase() !== 'ons-page') {
           var page = this;
           for (;;) {
             page = page.parentNode;

             if (!page) {
               return;
             }

             if (page.nodeName.toLowerCase() === 'ons-page') {
               break;
             }
           }
           page._registerExtraElement(this);
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryShow = function tryShow() {
           var unlock = _this3._doorLock.lock();
           var animator = _this3._animatorFactory.newAnimator(options);

           _this3.style.display = 'table';
           return new Promise(function (resolve) {
             animator.show(_this3, function () {
               unlock();

               callback();
               resolve(_this3);
             });
           });
         };

         return new Promise(function (resolve) {
           _this3._doorLock.waitUnlock(function () {
             return resolve(tryShow());
           });
         });
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Toggle modal visibility.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.visible) {
           return this.hide.apply(this, arguments);
         } else {
           return this.show.apply(this, arguments);
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Hide modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryHide = function tryHide() {
           var unlock = _this4._doorLock.lock();
           var animator = _this4._animatorFactory.newAnimator(options);

           return new Promise(function (resolve) {
             animator.hide(_this4, function () {
               _this4.style.display = 'none';
               unlock();

               callback();
               resolve(_this4);
             });
           });
         };

         return new Promise(function (resolve) {
           _this4._doorLock.waitUnlock(function () {
             return resolve(tryHide());
           });
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
         }
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(handler) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
         this._onDeviceBackButton = handler;
       }
     }, {
       key: 'visible',
       get: function get() {
         return this.style.display !== 'none';
       }
     }]);
     return ModalElement;
   }(BaseElement);

   window.OnsModalElement = document.registerElement('ons-modal', {
     prototype: ModalElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsModalElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof ModalAnimator)) {
       throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
     }
     _animatorDict$2[name] = Animator;
   };

   window.OnsModalElement.ModalAnimator = ModalAnimator;

   var NavigatorTransitionAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function NavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       this.timing = options.timing;
       this.duration = options.duration;
       this.delay = options.delay;
     }

     babelHelpers.createClass(NavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NavigatorTransitionAnimator;
   }();

   /**
    * Slide animator for navigator transition like iOS's screen slide transition.
    */

   var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
       return _this;
     }

     babelHelpers.createClass(IOSSlideNavigatorTransitionAnimator, [{
       key: '_decompose',
       value: function _decompose(page) {
         CustomElements.upgrade(page);
         var toolbar = page._getToolbarElement();
         CustomElements.upgrade(toolbar);
         var left = toolbar._getToolbarLeftItemsElement();
         var right = toolbar._getToolbarRightItemsElement();

         var excludeBackButtonLabel = function excludeBackButtonLabel(elements) {
           var result = [];

           for (var i = 0; i < elements.length; i++) {
             if (elements[i].nodeName.toLowerCase() === 'ons-back-button') {
               var iconElement = elements[i].querySelector('.back-button__icon');
               if (iconElement) {
                 result.push(iconElement);
               }
             } else {
               result.push(elements[i]);
             }
           }

           return result;
         };

         var other = [].concat(left.children.length === 0 ? left : excludeBackButtonLabel(left.children)).concat(right.children.length === 0 ? right : excludeBackButtonLabel(right.children));

         var pageLabels = [toolbar._getToolbarCenterItemsElement(), toolbar._getToolbarBackButtonLabelElement()];

         return {
           pageLabels: pageLabels,
           other: other,
           content: page._getContentElement(),
           background: page._getBackgroundElement(),
           toolbar: toolbar,
           bottomToolbar: page._getBottomToolbarElement()
         };
       }
     }, {
       key: '_shouldAnimateToolbar',
       value: function _shouldAnimateToolbar(enterPage, leavePage) {
         var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

         var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

         return bothPageHasToolbar && noMaterialToolbar;
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         }();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0.1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }), animit(leavePageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
             css: { opacity: 1 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 0 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle());
         } else {

           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }));
         }
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         }();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0.1,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).wait(0).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)), animit(leavePageDecomposition.other).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }), animit(leavePageDecomposition.toolbar).queue({
             css: {
               background: 'none',
               backgroundColor: 'rgba(0, 0, 0, 0)',
               borderColor: 'rgba(0, 0, 0, 0)'
             },
             duration: 0
           }), animit(leavePageDecomposition.pageLabels).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }));
         } else {
           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)));
         }
       }
     }]);
     return IOSSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(0.6).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(0.4).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in screen transition.
    */

   var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(enterPage._getToolbarElement()).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle());
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage._getToolbarElement()).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Slide animator for navigator transition.
    */

   var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.3,
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
       _this.blackMaskOpacity = 0.4;
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDSlideNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: this.blackMaskOpacity
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(100%, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().wait(0.2).queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: this.blackMaskOpacity,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(100%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.2).queue(function (finish) {
           done();
           finish();
         }));
       }
     }]);
     return MDSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0.05
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(0.6).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(0).queue({
           css: {
             opacity: 0.4
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(0.4).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0.4
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in + Lift screen transition.
    */

   var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'ease-out',
         duration: '0.25',
         delay: '0.20'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 42px, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(0.15).queue({
           css: {
             transform: 'translate3D(0, 38px, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1
           },
           duration: 0
         }).wait(0.04).queue({
           css: {
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

     function NoneNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NoneNavigatorTransitionAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NoneNavigatorTransitionAnimator).call(this, options));
     }

     babelHelpers.createClass(NoneNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NoneNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var _animatorDict$3 = {
     'default': function _default() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'slide': function slide() {
       return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'lift': function lift() {
       return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
     },
     'slide-ios': IOSSlideNavigatorTransitionAnimator,
     'slide-md': MDSlideNavigatorTransitionAnimator,
     'lift-ios': IOSLiftNavigatorTransitionAnimator,
     'lift-md': MDLiftNavigatorTransitionAnimator,
     'fade-ios': IOSFadeNavigatorTransitionAnimator,
     'fade-md': MDFadeNavigatorTransitionAnimator,
     'none': NoneNavigatorTransitionAnimator
   };

   var rewritables = {
     /**
      * @param {Element} navigatorSideElement
      * @param {Function} callback
      */

     ready: function ready(navigatorElement, callback) {
       callback();
     },


     /**
      * @param {Element} navigatorElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(navigatorElement, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-navigator
    * @category navigation
    * @description
    *   [en]
    *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
    *
    *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
    *   [/en]
    *   [ja][/ja]
    * @codepen yrhtv
    * @guide PageNavigation
    *   [en]Guide for page navigation[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
    *   [ja][/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-navigator id="navigator">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="center">
    *         Title
    *       </div>
    *     </ons-toolbar>
    *     <p>
    *       <ons-button
    *         onclick="document.getElementById('navigator').pushPage('page.html')">
    *         Push page
    *       </ons-button>
    *     </p>
    *   </ons-page>
    * </ons-navigator>
    *
    * <ons-template id="page.html">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="left">
    *         <ons-back-button>Back</ons-back-button>
    *       </div>
    *       <div class="center">
    *         Another page
    *       </div>
    *     </ons-toolbar>
    *   </ons-page>
    * </ons-template>
    */

   var NavigatorElement = function (_BaseElement) {
     babelHelpers.inherits(NavigatorElement, _BaseElement);

     function NavigatorElement() {
       babelHelpers.classCallCheck(this, NavigatorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NavigatorElement).apply(this, arguments));
     }

     babelHelpers.createClass(NavigatorElement, [{
       key: 'createdCallback',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]First page to show when navigator is initialized.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @event prepush
        * @description
        *   [en]Fired just before a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the push.[/en]
        *   [ja]push[/ja]
        */

       /**
        * @event prepop
        * @description
        *   [en]Fired just before a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the pop.[/en]
        *   [ja]pagepop[/ja]
        */

       /**
        * @event postpush
        * @description
        *   [en]Fired just after a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pushpage[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]page[/ja]
        */

       /**
        * @event postpop
        * @description
        *   [en]Fired just after a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pop[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]pop[/ja]
        */

       value: function createdCallback() {
         this._boundOnDeviceBackButton = this._onDeviceBackButton.bind(this);

         this._isRunning = false;

         this._updateAnimatorFactory();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this2 = this;

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._boundOnDeviceBackButton);

         rewritables.ready(this, function () {
           if (_this2.pages.length === 0 && _this2.hasAttribute('page')) {
             _this2.pushPage(_this2.getAttribute('page'), { animation: 'none' });
           } else {
             for (var i = 0; i < _this2.pages.length; i++) {
               if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
                 throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
               }
             }

             if (_this2.topPage) {
               setTimeout(function () {
                 _this2.topPage._show();
                 _this2._updateLastPageBackButton();
               }, 0);
             }
           }
         });
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$3,
           baseClass: NavigatorTransitionAnimator,
           baseClassName: 'NavigatorTransitionAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }

       /**
        * @method popPage
        * @signature popPage([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Boolean} [options.refresh]
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the revealed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'popPage',
       value: function popPage() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var popUpdate = function popUpdate() {
           return new Promise(function (resolve) {
             _this3.pages[_this3.pages.length - 1]._destroy();
             resolve();
           });
         };
         options = this._prepareOptions(options);

         if (!options.refresh) {
           return this._popPage(options, popUpdate);
         }
         var index = this.pages.length - 2;

         if (!this.pages[index].name) {
           throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
         }

         return new Promise(function (resolve) {
           internal.getPageHTMLAsync(_this3.pages[index].name).then(function (templateHTML) {
             var element = util.extend(_this3._createPageElement(templateHTML), {
               name: _this3.name,
               options: options
             });

             rewritables.link(_this3, element, _this3.pages[index].options, function (element) {
               _this3.insertBefore(element, _this3.pages[index] ? _this3.pages[index] : null);
               _this3.pages[index + 1]._destroy();
               resolve();
             });
           });
         }).then(function () {
           return _this3._popPage(options, popUpdate);
         });
       }
     }, {
       key: '_popPage',
       value: function _popPage(options) {
         var _this4 = this;

         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];
         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

         if (this._isRunning) {
           return Promise.reject('popPage is already running.');
         }

         if (this.pages.length <= 1) {
           return Promise.reject('ons-navigator\'s page stack is empty.');
         }

         if (this._emitPrePopEvent()) {
           return Promise.reject('Canceled in prepop event.');
         }

         var l = this.pages.length;

         this._isRunning = true;

         this.pages[l - 2].updateBackButton(l - 2 > 0);

         return new Promise(function (resolve) {
           var leavePage = _this4.pages[l - 1];
           var enterPage = _this4.pages[l - 2];
           enterPage.style.display = 'block';

           options.animation = leavePage.pushedOptions.animation || options.animation;
           options.animationOptions = util.extend({}, leavePage.pushedOptions.animationOptions, options.animationOptions || {});

           var callback = function callback() {
             pages.pop();
             update(pages, _this4).then(function () {
               _this4._isRunning = false;

               enterPage._show();
               util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             });
           };

           leavePage._hide();
           var animator = _this4._animatorFactory.newAnimator(options);
           animator.pop(_this4.pages[l - 2], _this4.pages[l - 1], callback);
         }).catch(function () {
           return _this4._isRunning = false;
         });
       }

       /**
        * @method pushPage
        * @signature pushPage(page, [options])
        * @param {String} [page]
        *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.page]
        *   [en]Page URL. Only necessary if `page` parameter is omitted.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]pushPage()[/ja]
        * @param {Any} [options.data]
        *   [en]Custom data that will be stored in the new page element.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the pushed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pushes the specified page into the stack.[/en]
        *   [ja]page[/ja]
        */

     }, {
       key: 'pushPage',
       value: function pushPage(page) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);
         var run = function run(templateHTML) {
           return new Promise(function (resolve) {
             _this5.appendChild(_this5._createPageElement(templateHTML));
             resolve();
           });
         };

         if (options.pageHTML) {
           return this._pushPage(options, function () {
             return run(options.pageHTML);
           });
         }
         return this._pushPage(options, function () {
           return internal.getPageHTMLAsync(options.page).then(run);
         });
       }
     }, {
       key: '_pushPage',
       value: function _pushPage() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];

         var _this6 = this;

         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
         var page = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }

         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         this._isRunning = true;

         var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
         options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

         var animator = this._animatorFactory.newAnimator(options);

         pages.push(page);

         return update(pages, this).then(function () {
           var pageLength = _this6.pages.length;

           var enterPage = _this6.pages[pageLength - 1];
           var leavePage = _this6.pages[pageLength - 2];

           if (enterPage.nodeName !== 'ONS-PAGE') {
             throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
           }

           enterPage.updateBackButton(pageLength - 1);

           enterPage.data = options.data;
           enterPage.name = options.page;
           enterPage.pushedOptions = options;

           return new Promise(function (resolve) {
             var done = function done() {
               _this6._isRunning = false;

               if (leavePage) {
                 leavePage.style.display = 'none';
               }

               enterPage._show();
               util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             };

             enterPage.style.display = 'none';

             var push = function push() {
               enterPage.style.display = 'block';
               if (leavePage) {
                 leavePage._hide();
                 animator.push(enterPage, leavePage, done);
               } else {
                 done();
               }
             };

             options._linked ? push() : rewritables.link(_this6, enterPage, options, push);
           });
         }).catch(function (error) {
           _this6._isRunning = false;
           throw error;
         });
       }

       /**
        * @method replacePage
        * @signature replacePage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'replacePage',
       value: function replacePage(page) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);
         var callback = options.callback;

         options.callback = function () {
           if (_this7.pages.length > 1) {
             _this7.pages[_this7.pages.length - 2]._destroy();
           }
           _this7._updateLastPageBackButton();
           callback && callback();
         };

         return this.pushPage(options);
       }

       /**
        * @method insertPage
        * @signature insertPage(index, page, [options])
        * @param {Number} index
        *   [en]The index where it should be inserted.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the inserted page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
        *   [ja]pageindex[/ja]
        */

     }, {
       key: 'insertPage',
       value: function insertPage(index, page) {
         var _this8 = this;

         var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

         options = this._prepareOptions(options, page);
         index = this._normalizeIndex(index);

         if (index >= this.pages.length) {
           return this.pushPage(options);
         }

         var run = function run(templateHTML) {
           var element = util.extend(_this8._createPageElement(templateHTML), {
             name: options.page,
             data: options.data,
             pushedOptions: options
           });

           options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

           return new Promise(function (resolve) {
             element.style.display = 'none';
             _this8.insertBefore(element, _this8.pages[index]);
             _this8.topPage.updateBackButton(true);

             rewritables.link(_this8, element, options, function (element) {
               setTimeout(function () {
                 element = null;
                 resolve(_this8.pages[index]);
               }, 1000 / 60);
             });
           });
         };

         if (options.pageHTML) {
           return run(options.pageHTML);
         } else {
           return internal.getPageHTMLAsync(options.page).then(run);
         }
       }

       /**
        * @method resetToPage
        * @signature resetToPage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'resetToPage',
       value: function resetToPage(page) {
         var _this9 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);

         if (!options.animator && !options.animation) {
           options.animation = 'none';
         }

         var callback = options.callback;

         options.callback = function () {
           while (_this9.pages.length > 1) {
             _this9.pages[0]._destroy();
           }

           _this9.pages[0].updateBackButton(false);
           callback && callback();
         };

         if (!options.page && !options.pageHTML && this.hasAttribute('page')) {
           options.page = this.getAttribute('page');
         }

         return this.pushPage(options);
       }

       /**
        * @method bringPageTop
        * @signature bringPageTop(item, [options])
        * @param {String|Number} item
        *   [en]Page URL or index of an existing page in navigator's stack.[/en]
        *   [ja]URLons-navigator[/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
        *   [ja]push[/ja]
        */

     }, {
       key: 'bringPageTop',
       value: function bringPageTop(item) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === -1) {
           throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
         }
         var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
         var page = this.pages[index];

         if (index < 0) {
           return this.pushPage(item, options);
         }
         options = this._prepareOptions(options);

         if (index === this.pages.length - 1) {
           return Promise.resolve(page);
         }
         if (!page) {
           throw new Error('Failed to find item ' + item);
         }
         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }
         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         util.extend(options, {
           page: page.name,
           _linked: true
         });
         page.style.display = 'block';
         page.setAttribute('_skipinit', '');
         page.parentNode.appendChild(page);
         return this._pushPage(options);
       }
     }, {
       key: '_prepareOptions',
       value: function _prepareOptions() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var page = arguments[1];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
           page = options.page;
         }
         if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }
         page = page || options.page;

         return util.extend({}, this.options || {}, options, { page: page });
       }
     }, {
       key: '_updateLastPageBackButton',
       value: function _updateLastPageBackButton() {
         var index = this.pages.length - 1;
         if (index >= 0) {
           this.pages[index].updateBackButton(index > 0);
         }
       }
     }, {
       key: '_normalizeIndex',
       value: function _normalizeIndex(index) {
         return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.pages.length > 1) {
           this.popPage();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_lastIndexOfPage',
       value: function _lastIndexOfPage(pageName) {
         var index = void 0;
         for (index = this.pages.length - 1; index >= 0; index--) {
           if (this.pages[index].name === pageName) {
             break;
           }
         }
         return index;
       }
     }, {
       key: '_emitPreEvent',
       value: function _emitPreEvent(name) {
         var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isCanceled = false;

         util.triggerElementEvent(this, 'pre' + name, util.extend({
           navigator: this,
           currentPage: this.pages[this.pages.length - 1],
           cancel: function cancel() {
             return isCanceled = true;
           }
         }, data));

         return isCanceled;
       }
     }, {
       key: '_emitPrePushEvent',
       value: function _emitPrePushEvent() {
         return this._emitPreEvent('push');
       }
     }, {
       key: '_emitPrePopEvent',
       value: function _emitPrePopEvent() {
         var l = this.pages.length;
         return this._emitPreEvent('pop', {
           leavePage: this.pages[l - 1],
           enterPage: this.pages[l - 2]
         });
       }
     }, {
       key: '_createPageElement',
       value: function _createPageElement(templateHTML) {
         var pageElement = util.createElement(internal.normalizePageHTML(templateHTML));

         if (pageElement.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('You must supply an "ons-page" element to "ons-navigator".');
         }

         CustomElements.upgrade(pageElement);

         return pageElement;
       }

       /**
        * @property topPage
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
        *   [ja]pushPage()resetToPage()[/ja]
        */

     }, {
       key: '_show',
       value: function _show() {
         if (this.topPage) {
           this.topPage._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this.topPage) {
           this.topPage._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         for (var i = this.pages.length - 1; i >= 0; i--) {
           this.pages[i]._destroy();
         }

         this.remove();
       }
     }, {
       key: 'topPage',
       get: function get() {
         return this.pages[this.pages.length - 1] || null;
       }

       /**
        * @property pages
        * @readonly
        * @type {HTMLCollection}
        * @description
        *   [en]Navigator's page stack.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'pages',
       get: function get() {
         return this.children;
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Default options object. Attributes have priority over this property.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @default  false
        * @type {Boolean}
        * @description
        *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }, {
       key: '_isRunning',
       set: function set(value) {
         this.setAttribute('_is-running', value ? 'true' : 'false');
       },
       get: function get() {
         return JSON.parse(this.getAttribute('_is-running'));
       }
     }]);
     return NavigatorElement;
   }(BaseElement);

   window.OnsNavigatorElement = document.registerElement('ons-navigator', {
     prototype: NavigatorElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsNavigatorElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
       throw new Error('"Animator" param must inherit OnsNavigatorElement.NavigatorTransitionAnimator');
     }

     _animatorDict$3[name] = Animator;
   };

   window.OnsNavigatorElement.rewritables = rewritables;
   window.OnsNavigatorElement.NavigatorTransitionAnimator = NavigatorTransitionAnimator;

   var scheme$13 = {
     '': 'page--*',
     '.page__content': 'page--*__content',
     '.page__background': 'page--*__background'
   };

   var nullToolbarElement = document.createElement('ons-toolbar');

   /**
    * @element ons-page
    * @category page
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     This component defines the root of each page. If the content is large it will become scrollable.
    *
    *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
    *   [/en]
    *   [ja][/ja]
    * @guide ManagingMultiplePages
    *   [en]Managing multiple pages[/en]
    *   [ja][/ja]
    * @guide Pagelifecycle
    *   [en]Page life cycle events[/en]
    *   [ja][/ja]
    * @guide HandlingBackButton
    *   [en]Handling back button[/en]
    *   [ja][/ja]
    * @guide OverridingCSSstyles
    *   [en]Overriding CSS styles[/en]
    *   [ja]CSS[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-toolbar
    *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>Back</ons-back-button>
    *     </div>
    *     <div class="center">Title</div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    *
    *   <p>Page content</p>
    * </ons-page>
    *
    * // Infinite Scroll handler
    * page.onInfiniteScroll = function(done) {
    *   loadMore().then(done);
    * };
    */

   var PageElement = function (_BaseElement) {
     babelHelpers.inherits(PageElement, _BaseElement);

     function PageElement() {
       babelHelpers.classCallCheck(this, PageElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PageElement).apply(this, arguments));
     }

     babelHelpers.createClass(PageElement, [{
       key: 'createdCallback',


       /**
        * @event init
        * @description
        *   [en]Fired right after the page is attached.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event show
        * @description
        *   [en]Fired right after the page is shown.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event hide
        * @description
        *   [en]Fired right after the page is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event destroy
        * @description
        *   [en]Fired right before the page is destroyed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Specify modifier name to specify custom styles.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute on-infinite-scroll
        * @type {String}
        * @description
        *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('page');

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._isShown = false;
           _this2._contentElement = _this2._getContentElement();
           _this2._isMuted = _this2.hasAttribute('_muted');
           _this2._skipInit = _this2.hasAttribute('_skipinit');
           _this2.pushedOptions = {};
         });
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         contentReady(this, function () {
           if (!_this3._isMuted) {
             if (_this3._skipInit) {
               _this3.removeAttribute('_skipinit');
             } else {
               setImmediate(function () {
                 return util.triggerElementEvent(_this3, 'init');
               });
             }
           }

           if (!util.hasAnyComponentAsParent(_this3)) {
             setImmediate(function () {
               return _this3._show();
             });
           }

           _this3._tryToFillStatusBar();

           if (_this3.hasAttribute('on-infinite-scroll')) {
             _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
           }
         });
       }
     }, {
       key: 'updateBackButton',
       value: function updateBackButton(show) {
         if (this.backButton) {
           show ? this.backButton.show() : this.backButton.hide();
         }
       }
     }, {
       key: '_tryToFillStatusBar',
       value: function _tryToFillStatusBar() {
         var _this4 = this;

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this4, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
         });
       }
     }, {
       key: '_hasAPageControlChild',
       value: function _hasAPageControlChild() {
         return util.findChild(this._contentElement, function (e) {
           return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
         });
       }

       /**
        * @property onInfiniteScroll
        * @description
        *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
        *  [ja][/ja]
        */

     }, {
       key: '_onScroll',
       value: function _onScroll() {
         var _this5 = this;

         var c = this._contentElement,
             overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

         if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
           this._loadingContent = true;
           this._onInfiniteScroll(function () {
             return _this5._loadingContent = false;
           });
         }
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getContentElement',


       /**
        * @return {HTMLElement}
        */
       value: function _getContentElement() {
         var result = util.findChild(this, '.page__content');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__content" element.');
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_canAnimateToolbar',
       value: function _canAnimateToolbar() {
         if (util.findChild(this, 'ons-toolbar')) {
           return true;
         }
         return !!util.findChild(this._contentElement, function (el) {
           return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
         });
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBackgroundElement',
       value: function _getBackgroundElement() {
         var result = util.findChild(this, '.page__background');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__background" element.');
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBottomToolbarElement',
       value: function _getBottomToolbarElement() {
         return util.findChild(this, 'ons-bottom-toolbar') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarElement',
       value: function _getToolbarElement() {
         return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerToolbar',
       value: function _registerToolbar(element) {
         this.insertBefore(element, this.children[0]);
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerBottomToolbar',
       value: function _registerBottomToolbar(element) {
         this.classList.add('page-with-bottom-toolbar');
         this.appendChild(element);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this6 = this;

         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
         } else if (name === '_muted') {
           this._isMuted = this.hasAttribute('_muted');
         } else if (name === '_skipinit') {
           this._skipInit = this.hasAttribute('_skipinit');
         } else if (name === 'on-infinite-scroll') {
           if (current === null) {
             this.onInfiniteScroll = null;
           } else {
             this.onInfiniteScroll = function (done) {
               var f = util.findFromPath(current);
               _this6.onInfiniteScroll = f;
               f(done);
             };
           }
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (!util.findChild(this, '.page__background') || !util.findChild(this, '.page__content')) {

           var background = util.create('.page__background');
           var content = util.create('.page__content');

           while (this.firstChild) {
             content.appendChild(this.firstChild);
           }

           this.appendChild(background);
           this.appendChild(content);
         }

         ModifierUtil.initModifier(this, scheme$13);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_registerExtraElement',
       value: function _registerExtraElement(element) {
         var extra = util.findChild(this, '.page__extra');
         if (!extra) {
           extra = util.create('.page__extra', { zIndex: 10001 });
           this.appendChild(extra);
         }

         extra.appendChild(element);
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this._isShown && util.isAttached(this)) {
           this._isShown = true;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'show');
           }

           util.propagateAction(this._contentElement, '_show');
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this._isShown) {
           this._isShown = false;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'hide');
           }

           util.propagateAction(this._contentElement, '_hide');
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         this._hide();

         if (!this._isMuted) {
           util.triggerElementEvent(this, 'destroy');
         }

         if (this.onDeviceBackButton) {
           this.onDeviceBackButton.destroy();
         }

         util.propagateAction(this._contentElement, '_destroy');

         this.remove();
       }

       /**
        * @property data
        * @type {*}
        * @description
        *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'name',
       set: function set(str) {
         this.setAttribute('name', str);
       },
       get: function get() {
         return this.getAttribute('name');
       }
     }, {
       key: 'backButton',
       get: function get() {
         return this.querySelector('ons-back-button');
       }
     }, {
       key: 'onInfiniteScroll',
       set: function set(value) {
         if (value === null) {
           this._onInfiniteScroll = null;
           this._contentElement.removeEventListener('scroll', this._boundOnScroll);
           return;
         }
         if (!(value instanceof Function)) {
           throw new Error('onInfiniteScroll must be a function or null');
         }
         if (!this._onInfiniteScroll) {
           this._infiniteScrollLimit = 0.9;
           this._boundOnScroll = this._onScroll.bind(this);
           this._contentElement.addEventListener('scroll', this._boundOnScroll);
         }
         this._onInfiniteScroll = value;
       },
       get: function get() {
         return this._onInfiniteScroll;
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }]);
     return PageElement;
   }(BaseElement);

   window.OnsPageElement = document.registerElement('ons-page', {
     prototype: PageElement.prototype
   });

   var PopoverAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function PopoverAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, PopoverAnimator);

       this.options = util.extend({
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         duration: 0.2,
         delay: 0
       }, options);
     }

     babelHelpers.createClass(PopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         callback();
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         callback();
       }
     }, {
       key: '_animate',
       value: function _animate(element, _ref) {
         var from = _ref.from;
         var to = _ref.to;
         var options = _ref.options;
         var callback = _ref.callback;
         var _ref$restore = _ref.restore;
         var restore = _ref$restore === undefined ? false : _ref$restore;
         var animation = _ref.animation;

         options = util.extend({}, this.options, options);

         if (animation) {
           from = animation.from;
           to = animation.to;
         }

         animation = animit(element);
         if (restore) {
           animation = animation.saveStyle();
         }
         animation = animation.queue(from).wait(options.delay).queue({
           css: to,
           duration: options.duration,
           timing: options.timing
         });
         if (restore) {
           animation = animation.restoreStyle();
         }
         if (callback) {
           animation = animation.queue(function (done) {
             callback();
             done();
           });
         }
         return animation;
       }
     }, {
       key: '_animateAll',
       value: function _animateAll(element, animations) {
         var _this = this;

         Object.keys(animations).forEach(function (key) {
           return _this._animate(element[key], animations[key]).play();
         });
       }
     }]);
     return PopoverAnimator;
   }();

   var fade = {
     out: {
       from: { opacity: 1.0 },
       to: { opacity: 0 }
     },
     in: {
       from: { opacity: 0 },
       to: { opacity: 1.0 }
     }
   };

   var MDFadePopoverAnimator = function (_PopoverAnimator) {
     babelHelpers.inherits(MDFadePopoverAnimator, _PopoverAnimator);

     function MDFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, MDFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(MDFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: { animation: fade.in, restore: true, callback: callback }
         });
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.out,
           _popover: { animation: fade.out, restore: true, callback: callback }
         });
       }
     }]);
     return MDFadePopoverAnimator;
   }(PopoverAnimator);

   var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
     babelHelpers.inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

     function IOSFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, IOSFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(IOSFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: {
             from: {
               transform: 'scale3d(1.3, 1.3, 1.0)',
               opacity: 0
             },
             to: {
               transform: 'scale3d(1.0, 1.0,  1.0)',
               opacity: 1.0
             },
             restore: true,
             callback: callback
           }
         });
       }
     }]);
     return IOSFadePopoverAnimator;
   }(MDFadePopoverAnimator);

   var animators = { PopoverAnimator: PopoverAnimator, IOSFadePopoverAnimator: IOSFadePopoverAnimator, MDFadePopoverAnimator: MDFadePopoverAnimator };

   var scheme$14 = {
     '.popover': 'popover--*',
     '.popover-mask': 'popover-mask--*',
     '.popover__container': 'popover__container--*',
     '.popover__content': 'popover__content--*',
     '.popover__arrow': 'popover__arrow--*'
   };

   var _animatorDict$4 = {
     'default': function _default() {
       return platform.isAndroid() ? animators.MDFadePopoverAnimator : animators.IOSFadePopoverAnimator;
     },
     'none': animators.PopoverAnimator,
     'fade-ios': animators.IOSFadePopoverAnimator,
     'fade-md': animators.MDFadePopoverAnimator
   };

   var templateSource$1 = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

   var positions = {
     up: 'bottom',
     left: 'right',
     down: 'top',
     right: 'left'
   };

   var directions = Object.keys(positions);
   /**
    * @element ons-popover
    * @category popover
    * @description
    *  [en]
    *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
    *
    *    Another common way to use the popover is to display a menu when a button on the screen is tapped.
    *  [/en]
    *  [ja][/ja]
    * @codepen ZYYRKo
    * @example
    * <ons-button onclick="showPopover(this)">
    *   Click me!
    * </ons-button>
    *
    * <ons-popover direction="down" id="popover">
    *   <p>This is a popover!</p>
    * </ons-popover>
    *
    * <script>
    *   var showPopover = function(element) {
    *     var popover = document.getElementById('popover');
    *     popover.show(element);
    *   };
    * </script>
    */

   var PopoverElement = function (_BaseElement) {
     babelHelpers.inherits(PopoverElement, _BaseElement);

     function PopoverElement() {
       babelHelpers.classCallCheck(this, PopoverElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PopoverElement).apply(this, arguments));
     }

     babelHelpers.createClass(PopoverElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2._initAnimatorFactory();
         });

         this._doorLock = new DoorLock();
         this._boundOnChange = this._onChange.bind(this);
         this._boundCancel = this._cancel.bind(this);
       }
     }, {
       key: '_initAnimatorFactory',
       value: function _initAnimatorFactory() {
         var factory = new AnimatorFactory({
           animators: _animatorDict$4,
           baseClass: animators.PopoverAnimator,
           baseClassName: 'PopoverAnimator',
           defaultAnimation: this.getAttribute('animation') || 'default'
         });
         this._animator = function (options) {
           return factory.newAnimator(options);
         };
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.cancelable) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_positionPopover',
       value: function _positionPopover(target) {
         var radius = this._radius;
         var el = this._content;
         var margin = this._margin;

         var pos = target.getBoundingClientRect();
         var isMD = util.hasModifier(this, 'material');
         var cover = isMD && this.hasAttribute('cover-target');

         var distance = {
           top: pos.top - margin,
           left: pos.left - margin,
           right: window.innerWidth - pos.right - margin,
           bottom: window.innerHeight - pos.bottom - margin
         };

         var _calculateDirections2 = this._calculateDirections(distance);

         var vertical = _calculateDirections2.vertical;
         var primary = _calculateDirections2.primary;
         var secondary = _calculateDirections2.secondary;

         this._popover.classList.add('popover--' + primary);

         var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
         this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
         el.style[primary] = 0;

         var l = vertical ? 'width' : 'height';
         var sizes = function (style) {
           return {
             width: parseInt(style.getPropertyValue('width')),
             height: parseInt(style.getPropertyValue('height'))
           };
         }(window.getComputedStyle(el));

         el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
         this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

         this._setTransformOrigin(distance, sizes, pos, primary);

         // Prevent animit from restoring the style.
         el.removeAttribute('data-animit-orig-style');
       }
     }, {
       key: '_setTransformOrigin',
       value: function _setTransformOrigin(distance, sizes, pos, primary) {
         var calc = function calc(a, o, l) {
           return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
         };
         var x = calc('left', 'right', 'width') + 'px';
         var y = calc('top', 'bottom', 'height') + 'px';

         util.extend(this._popover.style, {
           transformOrigin: x + ' ' + y,
           webkitTransformOriginX: x,
           webkitTransformOriginY: y
         });
       }
     }, {
       key: '_calculateDirections',
       value: function _calculateDirections(distance) {
         var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
           return positions[e];
         });
         var primary = options.sort(function (a, b) {
           return distance[a] - distance[b];
         })[0];
         var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
         var secondary = void 0;

         if (vertical) {
           secondary = distance.left < distance.right ? 'left' : 'right';
         } else {
           secondary = distance.top < distance.bottom ? 'top' : 'bottom';
         }

         return { vertical: vertical, primary: primary, secondary: secondary };
       }
     }, {
       key: '_clearStyles',
       value: function _clearStyles() {
         var _this3 = this;

         ['top', 'bottom', 'left', 'right'].forEach(function (e) {
           _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
           _this3._popover.classList.remove('popover--' + e);
         });
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         var _this4 = this;

         setImmediate(function () {
           if (_this4._currentTarget) {
             _this4._positionPopover(_this4._currentTarget);
           }
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.classList.contains('popover')) {
           return;
         }

         this.classList.add('popover');

         var hasDefaultContainer = this._popover && this._content;

         if (hasDefaultContainer) {

           if (!this._mask) {
             var mask = document.createElement('div');
             mask.classList.add('popover-mask');
             this.insertBefore(mask, this.firstChild);
           }

           if (!this._arrow) {
             var arrow = document.createElement('div');
             arrow.classList.add('popover__arrow');
             this._popover.appendChild(arrow);
           }
         } else {

           var template = templateSource$1.cloneNode(true);
           var content = template.querySelector('.popover__content');

           while (this.childNodes[0]) {
             content.appendChild(this.childNodes[0]);
           }

           this.appendChild(template);
         }

         if (this.hasAttribute('style')) {
           this._popover.setAttribute('style', this.getAttribute('style'));
           this.removeAttribute('style');
         }

         if (this.hasAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$14);
       }
     }, {
       key: '_prepareAnimationOptions',
       value: function _prepareAnimationOptions(options) {
         if (options.animation && !(options.animation in _animatorDict$4)) {
           throw new Error('Animator ' + options.animation + ' is not registered.');
         }

         options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
       }
     }, {
       key: '_executeAction',
       value: function _executeAction(actions) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var callback = options.callback;
         var action = actions.action;
         var before = actions.before;
         var after = actions.after;


         this._prepareAnimationOptions(options);

         var canceled = false;
         util.triggerElementEvent(this, 'pre' + action, { // synchronous
           popover: this,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           return Promise.reject('Canceled in pre' + action + ' event.');
         }

         return new Promise(function (resolve) {
           _this5._doorLock.waitUnlock(function () {
             var unlock = _this5._doorLock.lock();

             before && before();

             contentReady(_this5, function () {
               _this5._animator(options)[action](_this5, function () {
                 after && after();

                 unlock();

                 util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

                 callback && callback();
                 resolve(_this5);
               });
             });
           });
         });
       }

       /**
        * @method show
        * @signature show(target, [options])
        * @param {String|Event|HTMLElement} target
        *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
        *   [ja]CSSeventDOM[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the popover has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
        *   [ja]target$eventDOMCSS[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show(target) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (typeof target === 'string') {
           target = document.querySelector(target);
         } else if (target instanceof Event) {
           target = target.target;
         }
         if (!(target instanceof HTMLElement)) {
           throw new Error('Invalid target');
         }

         return this._executeAction({
           action: 'show',
           before: function before() {
             _this6.style.display = 'block';
             _this6._currentTarget = target;
             _this6._positionPopover(target);
           }
         }, options);
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the popover has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close the popover.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this7 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._executeAction({
           action: 'hide',
           after: function after() {
             _this7.style.display = 'none';
             _this7._clearStyles();
           }
         }, options);
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this8 = this;

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));

         contentReady(this, function () {
           _this8._margin = _this8._margin || parseInt(window.getComputedStyle(_this8).getPropertyValue('top'));
           _this8._radius = parseInt(window.getComputedStyle(_this8._content).getPropertyValue('border-radius'));

           _this8._mask.addEventListener('click', _this8._boundCancel, false);

           _this8._backButtonHandler = deviceBackButtonDispatcher.createHandler(_this8, _this8._onDeviceBackButton.bind(_this8));

           _this8._popover.addEventListener('DOMNodeInserted', _this8._boundOnChange, false);
           _this8._popover.addEventListener('DOMNodeRemoved', _this8._boundOnChange, false);

           window.addEventListener('resize', _this8._boundOnChange, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         var _this9 = this;

         contentReady(this, function () {
           _this9._mask.removeEventListener('click', _this9._boundCancel, false);

           _this9._backButtonHandler.destroy();
           _this9._backButtonHandler = null;

           _this9._popover.removeEventListener('DOMNodeInserted', _this9._boundOnChange, false);
           _this9._popover.removeEventListener('DOMNodeRemoved', _this9._boundOnChange, false);

           window.removeEventListener('resize', _this9._boundOnChange, false);
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
         }
         if (name === 'direction') {
           return this._boundOnChange();
         }
         if (name === 'animation') {
           this._initAnimatorFactory();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this10 = this;

         if (this.cancelable) {
           this.hide({
             callback: function callback() {
               util.triggerElementEvent(_this10, 'cancel');
             }
           });
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        *   [en]Fired just after the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the popover.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *  [en]
        *    A space separated list of directions. If more than one direction is specified,
        *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
        *  [/en]
        *  [ja]
        *    
        *    "up", "down", "left", "right"4
        *    
        *  [/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute cover-target
        * @description
        *   [en]If set the popover will cover the target on the screen.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @description
        *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {Color}
        * @description
        *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *   [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.popover-mask');
       }
     }, {
       key: '_popover',
       get: function get() {
         return util.findChild(this, '.popover__container');
       }
     }, {
       key: '_content',
       get: function get() {
         return util.findChild(this._popover, '.popover__content');
       }
     }, {
       key: '_arrow',
       get: function get() {
         return util.findChild(this._popover, '.popover__arrow');
       }
     }, {
       key: 'visible',
       get: function get() {
         return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]
        *     A boolean value that specifies whether the popover is cancelable or not.
        *
        *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
        *   [/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }

       /**
        * @property onDeviceBackButton
        * @readonly
        * @type {Object}
        * @description
        *   [en]Retrieve the back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       }
     }]);
     return PopoverElement;
   }(BaseElement);

   window.OnsPopoverElement = document.registerElement('ons-popover', {
     prototype: PopoverElement.prototype
   });

   /**
    * @param {String} name
    * @param {PopoverAnimator} Animator
    */
   window.OnsPopoverElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof animators.PopoverAnimator)) {
       throw new Error('"Animator" param must inherit PopoverAnimator');
     }
     _animatorDict$4[name] = Animator;
   };

   window.OnsPopoverElement.PopoverAnimator = animators.PopoverAnimator;

   var scheme$15 = {
     '.progress-bar': 'progress-bar--*',
     '.progress-bar__primary': 'progress-bar__primary--*',
     '.progress-bar__secondary': 'progress-bar__secondary--*'
   };

   var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

   /**
    * @element ons-progress-bar
    * @category progress
    * @description
    *   [en]
    *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
    *   [/en]
    *   [ja][/ja]
    * @codepen zvQbGj
    * @seealso ons-progress-circular
    *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
    *   [ja][/ja]
    * @example
    * <ons-progress-bar
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-bar>
    *
    * <ons-progress-bar
    *  indeterminate>
    * </ons-progress-bar>
    */

   var ProgressBarElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressBarElement, _BaseElement);

     function ProgressBarElement() {
       babelHelpers.classCallCheck(this, ProgressBarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressBarElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-bar--indeterminate');
           this._template.classList.remove('progress-bar--determinate');
         } else {
           this._template.classList.add('progress-bar--determinate');
           this._template.classList.remove('progress-bar--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         this._primary.style.width = this.hasAttribute('value') ? this.getAttribute('value') + '%' : '0%';
         this._secondary.style.width = this.hasAttribute('secondary-value') ? this.getAttribute('secondary-value') + '%' : '0%';
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$15);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }]);
     return ProgressBarElement;
   }(BaseElement);

   window.OnsProgressBarElement = document.registerElement('ons-progress-bar', {
     prototype: ProgressBarElement.prototype
   });

   var scheme$16 = {
     '.progress-circular': 'progress-circular--*',
     '.progress-circular__primary': 'progress-circular__primary--*',
     '.progress-circular__secondary': 'progress-circular__secondary--*'
   };

   var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

   /**
    * @element ons-progress-circular
    * @category progress
    * @description
    *   [en]
    *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
    *   [/en]
    *   [ja][/ja]
    * @codepen EVzMjR
    * @example
    * <ons-progress-circular
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-circular>
    *
    * <ons-progress-circular
    *  indeterminate>
    * </ons-progress-circular>
    */

   var ProgressCircularElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressCircularElement, _BaseElement);

     function ProgressCircularElement() {
       babelHelpers.classCallCheck(this, ProgressCircularElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressCircularElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressCircularElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-circular--indeterminate');
           this._template.classList.remove('progress-circular--determinate');
         } else {
           this._template.classList.add('progress-circular--determinate');
           this._template.classList.remove('progress-circular--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         if (this.hasAttribute('value')) {
           var per = Math.ceil(this.getAttribute('value') * 251.32 * 0.01);
           this._primary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
         if (this.hasAttribute('secondary-value')) {
           var per = Math.ceil(this.getAttribute('secondary-value') * 251.32 * 0.01);
           this._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template$1.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$16);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }]);
     return ProgressCircularElement;
   }(BaseElement);

   window.OnsProgressCircularElement = document.registerElement('ons-progress-circular', {
     prototype: ProgressCircularElement.prototype
   });

   var STATE_INITIAL = 'initial';
   var STATE_PREACTION = 'preaction';
   var STATE_ACTION = 'action';

   /**
    * @element ons-pull-hook
    * @category pull-hook
    * @description
    *   [en]
    *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
    *
    *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
    *   [/en]
    *   [ja][/ja]
    * @codepen WbJogM
    * @guide UsingPullHook
    *   [en]How to use Pull Hook[/en]
    *   [ja][/ja]
    * @example
    * <ons-page>
    *   <ons-pull-hook>
    *     Release to refresh
    *   </ons-pull-hook>
    * </ons-page>
    *
    * <script>
    *   document.querySelector('ons-pull-hook').onAction = function(done) {
    *     setTimeout(done, 1000);
    *   };
    * </script>
    */

   var PullHookElement = function (_BaseElement) {
     babelHelpers.inherits(PullHookElement, _BaseElement);

     function PullHookElement() {
       babelHelpers.classCallCheck(this, PullHookElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PullHookElement).apply(this, arguments));
     }

     babelHelpers.createClass(PullHookElement, [{
       key: 'createdCallback',


       /**
        * @event changestate
        * @description
        *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
        *   [ja]"initial", "preaction", "action"[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.pullHook
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.state
        *   [en]Current state.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
        *   [ja]disabled[/ja]
        */

       /**
        * @attribute height
        * @type {String}
        * @description
        *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
        *   [ja]pull down"preaction""64px"[/ja]
        */

       /**
        * @attribute threshold-height
        * @type {String}
        * @description
        *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
        *   [ja]pull down"action"[/ja]
        */

       /**
        * @attribute fixed-content
        * @description
        *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnScroll = this._onScroll.bind(this);

         this._currentTranslation = 0;

         this._setState(STATE_INITIAL, true);
         this._setStyle();
       }
     }, {
       key: '_createScrollElement',
       value: function _createScrollElement() {
         if (this.parentElement.classList.contains('scroll')) {
           return this.parentElement;
         }

         var scrollElement = util.createElement('<div class="scroll"><div>');

         var pageElement = this.parentElement;

         scrollElement.appendChild(this);
         while (pageElement.firstChild) {
           scrollElement.appendChild(pageElement.firstChild);
         }
         pageElement.appendChild(scrollElement);

         return scrollElement;
       }
     }, {
       key: '_setStyle',
       value: function _setStyle() {
         var height = this.height;

         this.style.top = '-' + height + 'px';
         this.style.height = height + 'px';
         this.style.lineHeight = height + 'px';
       }
     }, {
       key: '_onScroll',
       value: function _onScroll(event) {
         var element = this._pageElement;

         if (element.scrollTop < 0) {
           element.scrollTop = 0;
         }
       }
     }, {
       key: '_generateTranslationTransform',
       value: function _generateTranslationTransform(scroll) {
         return 'translate3d(0px, ' + scroll + 'px, 0px)';
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var _this2 = this;

         if (this.disabled) {
           return;
         }

         // Ignore when dragging left and right.
         if (event.gesture.direction === 'left' || event.gesture.direction === 'right') {
           return;
         }

         // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
         // there will be no inertial scroll when scrolling down. Allowing default scrolling will
         // kill all 'touchmove' events.
         var element = this._pageElement;
         element.scrollTop = this._startScroll - event.gesture.deltaY;
         if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
           event.gesture.preventDefault();
         }

         if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
           this._transitionDragLength = event.gesture.deltaY;

           var direction = event.gesture.interimDirection;
           if (direction === 'down') {
             this._transitionDragLength -= 1;
           } else {
             this._transitionDragLength += 1;
           }
         }

         var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

         if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
           event.gesture.stopDetect();

           setImmediate(function () {
             return _this2._finish();
           });
         } else if (scroll >= this.height) {
           this._setState(STATE_PREACTION);
         } else {
           this._setState(STATE_INITIAL);
         }

         event.stopPropagation();
         this._translateTo(scroll);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         if (this.disabled) {
           return;
         }

         this._startScroll = this._getCurrentScroll();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         if (this.disabled) {
           return;
         }

         if (this._currentTranslation > 0) {
           var scroll = this._currentTranslation;

           if (scroll > this.height) {
             this._finish();
           } else {
             this._translateTo(0, { animate: true });
           }
         }
       }

       /**
        * @property onAction
        * @type {Function}
        * @description
        *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_finish',
       value: function _finish() {
         var _this3 = this;

         this._setState(STATE_ACTION);
         this._translateTo(this.height, { animate: true });
         var action = this.onAction || function (done) {
           return done();
         };
         action(function () {
           _this3._translateTo(0, { animate: true });
           _this3._setState(STATE_INITIAL);
         });
       }

       /**
        * @property height
        * @type {Number}
        * @description
        *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_thresholdHeightEnabled',
       value: function _thresholdHeightEnabled() {
         var th = this.thresholdHeight;
         return th > 0 && th >= this.height;
       }
     }, {
       key: '_setState',
       value: function _setState(state, noEvent) {
         var lastState = this._getState();

         this.setAttribute('state', state);

         if (!noEvent && lastState !== this._getState()) {
           util.triggerElementEvent(this, 'changestate', {
             pullHook: this,
             state: state,
             lastState: lastState
           });
         }
       }
     }, {
       key: '_getState',
       value: function _getState() {
         return this.getAttribute('state');
       }

       /**
        * @property state
        * @readonly
        * @type {String}
        * @description
        *   [en]Current state of the element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getCurrentScroll',
       value: function _getCurrentScroll() {
         return this._pageElement.scrollTop;
       }

       /**
        * @property pullDistance
        * @readonly
        * @type {Number}
        * @description
        *   [en]The current number of pixels the pull hook has moved.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_isContentFixed',
       value: function _isContentFixed() {
         return this.hasAttribute('fixed-content');
       }
     }, {
       key: '_getScrollableElement',
       value: function _getScrollableElement() {
         if (this._isContentFixed()) {
           return this;
         } else {
           return this._scrollElement;
         }
       }

       /**
        * @param {Number} scroll
        * @param {Object} options
        * @param {Function} [options.callback]
        */

     }, {
       key: '_translateTo',
       value: function _translateTo(scroll) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (this._currentTranslation == 0 && scroll == 0) {
           return;
         }

         var done = function done() {
           if (scroll === 0) {
             _this4._getScrollableElement().removeAttribute('style');
           }

           if (options.callback) {
             options.callback();
           }
         };

         this._currentTranslation = scroll;

         if (options.animate) {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }, {
             duration: 0.3,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).play(done);
         } else {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }).play(done);
         }
       }
     }, {
       key: '_getMinimumScroll',
       value: function _getMinimumScroll() {
         var scrollHeight = this._scrollElement.getBoundingClientRect().height;
         var pageHeight = this._pageElement.getBoundingClientRect().height;

         return scrollHeight > pageHeight ? -(scrollHeight - pageHeight) : 0;
       }
     }, {
       key: '_createEventListeners',
       value: function _createEventListeners() {
         this._gestureDetector = new GestureDetector(this._pageElement, {
           dragMinDistance: 1,
           dragDistanceCorrection: false
         });

         // Bind listeners
         this._gestureDetector.on('drag', this._boundOnDrag);
         this._gestureDetector.on('dragstart', this._boundOnDragStart);
         this._gestureDetector.on('dragend', this._boundOnDragEnd);

         this._scrollElement.parentElement.addEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: '_destroyEventListeners',
       value: function _destroyEventListeners() {
         if (this._gestureDetector) {
           this._gestureDetector.off('drag', this._boundOnDrag);
           this._gestureDetector.off('dragstart', this._boundOnDragStart);
           this._gestureDetector.off('dragend', this._boundOnDragEnd);

           this._gestureDetector.dispose();
           this._gestureDetector = null;
         }

         if (this._scrollElement && this._scrollElement.parentElement) {
           this._scrollElement.parentElement.removeEventListener('scroll', this._boundOnScroll, false);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._scrollElement = this._createScrollElement();

         this._pageElement = this._scrollElement.parentElement;

         if (!this._pageElement.classList.contains('page__content')) {
           throw new Error('<ons-pull-hook> must be a direct descendant of an <ons-page> element.');
         }

         this._createEventListeners();
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._destroyEventListeners();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'height',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The height must be an integer');
         }

         this.setAttribute('height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('height') || '64', 10);
       }

       /**
        * @property thresholdHeight
        * @type {Number}
        * @description
        *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'thresholdHeight',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The threshold height must be an integer');
         }

         this.setAttribute('threshold-height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('threshold-height') || '96', 10);
       }
     }, {
       key: 'state',
       get: function get() {
         return this._getState();
       }
     }, {
       key: 'pullDistance',
       get: function get() {
         return this._currentTranslation;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return PullHookElement;
   }(BaseElement);

   window.OnsPullHookElement = document.registerElement('ons-pull-hook', {
     prototype: PullHookElement.prototype
   });

   window.OnsPullHookElement.STATE_ACTION = STATE_ACTION;
   window.OnsPullHookElement.STATE_INITIAL = STATE_INITIAL;
   window.OnsPullHookElement.STATE_PREACTION = STATE_PREACTION;

   /**
    * @class AnimatorCSS - implementation of Animator class using css transitions
    */

   var AnimatorCSS = function () {
     babelHelpers.createClass(AnimatorCSS, [{
       key: 'animate',


       /**
        * @method animate
        * @desc main animation function
        * @param {Element} element
        * @param {Object} finalCSS
        * @param {number} [duration=200] - duration in milliseconds
        * @return {Object} result
        * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
        * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
        * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
        * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
        * @example
        * ````
        *  var result = animator.animate(el, {opacity: 0.5}, 1000);
        *
        *  el.addEventListener('click', function(e){
        *    result.speed(200).then(function(){
        *      console.log('done');
        *    });
        *  }, 300);
        * ````
        */
       value: function animate(el, final) {
         var duration = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];

         var start = new Date().getTime(),
             initial = {},
             stopped = false,
             next = false,
             timeout = false,
             properties = Object.keys(final);

         var updateStyles = function updateStyles() {
           var s = window.getComputedStyle(el);
           properties.forEach(s.getPropertyValue.bind(s));
           s = el.offsetHeight;
         };

         var result = {
           stop: function stop() {
             var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

             timeout && clearTimeout(timeout);
             var k = Math.min(1, (new Date().getTime() - start) / duration);
             properties.forEach(function (i) {
               el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
             });
             el.style.transitionDuration = '0s';

             if (options.stopNext) {
               next = false;
             } else if (!stopped) {
               stopped = true;
               next && next();
             }
             return result;
           },
           then: function then(cb) {
             next = cb;
             if (stopped) {
               next && next();
             }
             return result;
           },
           speed: function speed(newDuration) {
             if (internal.config.animationsDisabled) {
               newDuration = 0;
             }
             if (!stopped) {
               (function () {
                 timeout && clearTimeout(timeout);

                 var passed = new Date().getTime() - start;
                 var k = passed / duration;
                 var remaining = newDuration * (1 - k);

                 properties.forEach(function (i) {
                   el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 updateStyles();

                 start = el.speedUpTime;
                 duration = remaining;

                 el.style.transitionDuration = duration / 1000 + 's';

                 properties.forEach(function (i) {
                   el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 timeout = setTimeout(result.stop, remaining);
               })();
             }
             return result;
           },
           finish: function finish() {
             var milliseconds = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

             var k = (new Date().getTime() - start) / duration;

             result.speed(milliseconds / (1 - k));
             return result;
           }
         };

         if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {
           return result;
         }

         var style = window.getComputedStyle(el);
         properties.forEach(function (e) {
           var v = parseFloat(style.getPropertyValue(e));
           initial[e] = isNaN(v) ? 0 : v;
         });

         if (!stopped) {
           el.style.transitionProperty = properties.join(',');
           el.style.transitionDuration = duration / 1000 + 's';

           properties.forEach(function (e) {
             el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
           });
         }

         timeout = setTimeout(result.stop, duration);
         this._onStopAnimations(el, result.stop);

         return result;
       }
     }]);

     function AnimatorCSS() {
       babelHelpers.classCallCheck(this, AnimatorCSS);

       this._queue = [];
       this._index = 0;
     }

     babelHelpers.createClass(AnimatorCSS, [{
       key: '_onStopAnimations',
       value: function _onStopAnimations(el, listener) {
         var queue = this._queue;
         var i = this._index++;
         queue[el] = queue[el] || [];
         queue[el][i] = function (options) {
           delete queue[el][i];
           if (queue[el] && queue[el].length == 0) {
             delete queue[el];
           }
           return listener(options);
         };
       }

       /**
       * @method stopAnimations
       * @desc stops active animations on a specified element
       * @param {Element|Array} element - element or array of elements
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAnimations',
       value: function stopAnimations(el) {
         var _this = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (Array.isArray(el)) {
           return el.forEach(function (el) {
             _this.stopAnimations(el, options);
           });
         }

         (this._queue[el] || []).forEach(function (e) {
           e(options || {});
         });
       }

       /**
       * @method stopAll
       * @desc stops all active animations
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAll',
       value: function stopAll() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.stopAnimations(Object.keys(this._queue), options);
       }

       /**
       * @method fade
       * @desc fades the element (short version for animate(el, {opacity: 0}))
       * @param {Element} element
       * @param {number} [duration=200]
       */

     }, {
       key: 'fade',
       value: function fade(el) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

         return this.animate(el, { opacity: 0 }, duration);
       }
     }]);
     return AnimatorCSS;
   }();

   /**
    * @element ons-ripple
    * @category ripple
    * @description
    *   [en]
    *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
    *
    *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
    *   [/en]
    *   [ja]DOM[/ja]
    * @codepen wKQWdZ
    * @example
    * <div class="my-div">
    *  <ons-ripple></ons-ripple>
    * </div>
    *
    * <ons-button ripple>Click me!</ons-button>
    */

   var RippleElement = function (_BaseElement) {
     babelHelpers.inherits(RippleElement, _BaseElement);

     function RippleElement() {
       babelHelpers.classCallCheck(this, RippleElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RippleElement).apply(this, arguments));
     }

     babelHelpers.createClass(RippleElement, [{
       key: 'createdCallback',


       /**
        * @attribute color
        * @type {String}
        * @description
        *   [en]Color of the ripple effect.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute background
        * @type {String}
        * @description
        *   [en]Color of the background.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('ripple');
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         } else {
           this._background = this.getElementsByClassName('ripple__background')[0];
           this._wave = this.getElementsByClassName('ripple__wave')[0];
         }

         this._animator = new AnimatorCSS();

         ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         ['_wave', '_background'].forEach(function (e) {
           _this3[e] = document.createElement('div');
           _this3[e].classList.add('ripple_' + e);
           _this3.appendChild(_this3[e]);
         });
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_calculateCoords',
       value: function _calculateCoords(e) {
         var x, y, h, w, r;
         var b = this.getBoundingClientRect();
         if (this._center) {
           x = b.width / 2;
           y = b.height / 2;
           r = Math.sqrt(x * x + y * y);
         } else {
           x = (e.clientX || e.changedTouches[0].clientX) - b.left;
           y = (e.clientY || e.changedTouches[0].clientY) - b.top;
           h = Math.max(y, b.height - y);
           w = Math.max(x, b.width - x);
           r = Math.sqrt(h * h + w * w);
         }
         return { x: x, y: y, r: r };
       }
     }, {
       key: '_rippleAnimation',
       value: function _rippleAnimation(e) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
         var _animator = this._animator;
         var _wave = this._wave;
         var _background = this._background;

         var _minR = this._minR;

         var _calculateCoords2 = this._calculateCoords(e);

         var x = _calculateCoords2.x;
         var y = _calculateCoords2.y;
         var r = _calculateCoords2.r;


         _animator.stopAll({ stopNext: 1 });
         _animator.animate(_background, { opacity: 1 }, duration);

         util.extend(_wave.style, {
           opacity: 1,
           top: y - _minR + 'px',
           left: x - _minR + 'px',
           width: 2 * _minR + 'px',
           height: 2 * _minR + 'px'
         });

         return _animator.animate(_wave, {
           top: y - r,
           left: x - r,
           height: 2 * r,
           width: 2 * r
         }, duration);
       }
     }, {
       key: '_updateParent',
       value: function _updateParent() {
         if (!this._parentUpdated && this.parentNode) {
           var computedStyle = window.getComputedStyle(this.parentNode);
           if (computedStyle.getPropertyValue('position') === 'static') {
             this.parentNode.style.position = 'relative';
           }
           this._parentUpdated = true;
         }
       }
     }, {
       key: '_onTap',
       value: function _onTap(e) {
         var _this4 = this;

         if (!this.disabled) {
           this._updateParent();
           this._rippleAnimation(e.gesture.srcEvent).then(function () {
             _this4._animator.fade(_this4._wave);
             _this4._animator.fade(_this4._background);
           });
         }
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this._updateParent();
           this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var _this5 = this;

         if (this._holding) {
           this._holding.speed(300).then(function () {
             _this5._animator.stopAll({ stopNext: true });
             _this5._animator.fade(_this5._wave);
             _this5._animator.fade(_this5._background);
           });

           this._holding = false;
         }

         document.removeEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this._holding) {
           return this._onRelease(e);
         }
         if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
           this._onTap(e);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._parentNode = this.parentNode;
         this._boundOnTap = this._onTap.bind(this);
         this._boundOnHold = this._onHold.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnRelease = this._onRelease.bind(this);

         if (internal.config.animationsDisabled) {
           this.disabled = true;
         } else {
           this._parentNode.addEventListener('tap', this._boundOnTap);
           this._parentNode.addEventListener('hold', this._boundOnHold);
           this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._parentNode.removeEventListener('tap', this._boundOnTap);
         this._parentNode.removeEventListener('hold', this._boundOnHold);
         this._parentNode.removeEventListener('dragstart', this._boundOnDragStart);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'start-radius') {
           this._minR = Math.max(0, parseFloat(current) || 0);
         }
         if (name === 'color' && current) {
           this._wave.style.background = current;
           if (!this.hasAttribute('background')) {
             this._background.style.background = current;
           }
         }
         if (name === 'background' && (current || last)) {
           if (current === 'none') {
             this._background.setAttribute('disabled', 'disabled');
             this._background.style.background = 'transparent';
           } else {
             if (this._background.hasAttribute('disabled')) {
               this._background.removeAttribute('disabled');
             }
             this._background.style.background = current;
           }
         }
         if (name === 'center') {
           this._center = current != null && current != 'false';
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return RippleElement;
   }(BaseElement);

   window.OnsRippleElement = document.registerElement('ons-ripple', {
     prototype: RippleElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @element ons-row
    * @category grid
    * @description
    *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
    *   [ja]ons-col[/ja]
    * @codepen GgujC {wide}
    * @guide Layouting
    *   [en]Layouting guide[/en]
    *   [ja][/ja]
    * @seealso ons-col
    *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
    *   [ja]ons-col[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-colons-colvertical-alignvertical-align[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
    *   [ja]topbottomcenter[/ja]
    */
   window.OnsRowElement = window.OnsRowElement ? window.OnsRowElement : document.registerElement('ons-row');

   var scheme$17 = {
     '': 'speed-dial__item--*'
   };

   /**
    * @element ons-speed-dial-item
    * @category speed-dial
    * @description
    *   [en]
    *     This component displays the child elements of the Material Design Speed dial component.
    *   [/en]
    *   [ja]
    *     Material DesignSpeed dial
    *   [/ja]
    * @codepen dYQYLg
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component.[/en]
    *   [ja]ons-speed-dial[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialItemElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialItemElement, _BaseElement);

     function SpeedDialItemElement() {
       babelHelpers.classCallCheck(this, SpeedDialItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialItemElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$17);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         e.stopPropagation();
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('fab');
         this.classList.add('fab--mini');
         this.classList.add('speed-dial__item');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$17);

         this.setAttribute('_compiled', '');
       }
     }]);
     return SpeedDialItemElement;
   }(BaseElement);

   window.OnsSpeedDialItemElement = document.registerElement('ons-speed-dial-item', {
     prototype: SpeedDialItemElement.prototype
   });

   var scheme$18 = {
     '': 'speed-dial--*'
   };

   /**
    * @element ons-speed-dial
    * @category speed-dial
    * @description
    *   [en]
    *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
    *
    *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
    *   [/en]
    *   [ja][/ja]
    * @codepen dYQYLg
    * @seealso ons-speed-dial-item
    *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
    *   [ja]ons-speed-dial-item[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialElement, _BaseElement);

     function SpeedDialElement() {
       babelHelpers.classCallCheck(this, SpeedDialElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialElement, [{
       key: 'createdCallback',


       /**
        * @event open
        * @description
        *   [en]Fired when the menu items are shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event close
        * @description
        *   [en]Fired when the menu items are hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *   [en]
        *     Specify the vertical and horizontal position of the component.
        *     I.e. to display it in the top right corner specify "right top".
        *     Choose from "right", "left", "top" and "bottom".
        *   [/en]
        *   [ja]
        *     
        *     "right top"
        *     rightlefttopbottom
        *   [/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
        *   [ja]
        *     up, down, left, right
        *   [/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();

           this.classList.add('speed__dial');

           if (this.hasAttribute('direction')) {
             this._updateDirection(this.getAttribute('direction'));
           } else {
             this._updateDirection('up');
           }
           this._updatePosition();
         }

         this._shown = true;
         this._itemShown = false;
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$18);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$18);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'direction':
             this._updateDirection(current);
             break;
           case 'position':
             this._updatePosition();
             break;
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._updateDirection(this.hasAttribute('direction') ? this.getAttribute('direction') : 'up');
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         if (!this.disabled && this._shown) {
           this.toggleItems();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.inline) {
           this.show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (!this.inline) {
           this.hide();
         }
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         var fab = util.findChild(this, 'ons-fab');

         if (fab) {
           this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
         }
       }
     }, {
       key: '_updateDirection',
       value: function _updateDirection(direction) {
         var children = this.items;
         for (var i = 0; i < children.length; i++) {
           children[i].style.transitionDelay = 25 * i + 'ms';
           children[i].style.webkitTransitionDelay = 25 * i + 'ms';
           children[i].style.bottom = 'auto';
           children[i].style.right = 'auto';
           children[i].style.top = 'auto';
           children[i].style.left = 'auto';
         }
         switch (direction) {
           case 'up':
             for (var i = 0; i < children.length; i++) {
               children[i].style.bottom = 72 + 56 * i + 'px';
               children[i].style.right = '8px';
             }
             break;
           case 'down':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = 72 + 56 * i + 'px';
               children[i].style.left = '8px';
             }
             break;
           case 'left':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = '8px';
               children[i].style.right = 72 + 56 * i + 'px';
             }
             break;
           case 'right':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = '8px';
               children[i].style.left = 72 + 56 * i + 'px';
             }
             break;
           default:
             throw new Error('Argument must be one of up, down, left or right.');
         }
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *   [en]Show the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.querySelector('ons-fab').show();
         this._shown = true;
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *   [en]Hide the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this2 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.hideItems();
         setTimeout(function () {
           _this2.querySelector('ons-fab').hide();
         }, 200);
         this._shown = false;
       }

       /**
        * @method showItems
        * @signature showItems()
        * @description
        *   [en]Show the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'showItems',
       value: function showItems() {
         if (!this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             children[i].style.transform = 'scale(1)';
             children[i].style.webkitTransform = 'scale(1)';
             children[i].style.transitionDelay = 25 * i + 'ms';
             children[i].style.webkitTransitionDelay = 25 * i + 'ms';
           }
         }
         this._itemShown = true;

         util.triggerElementEvent(this, 'open');
       }

       /**
        * @method hideItems
        * @signature hideItems()
        * @description
        *   [en]Hide the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hideItems',
       value: function hideItems() {
         if (this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             children[i].style.transform = 'scale(0)';
             children[i].style.webkitTransform = 'scale(0)';
             children[i].style.transitionDelay = 25 * (children.length - i) + 'ms';
             children[i].style.webkitTransitionDelay = 25 * (children.length - i) + 'ms';
           }
         }
         this._itemShown = false;
         util.triggerElementEvent(this, 'close');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'isOpen',


       /**
        * @method isOpen
        * @signature isOpen()
        * @description
        *   [en]Returns whether the menu is open or not.[/en]
        *   [ja][/ja]
        */
       value: function isOpen() {
         return this._itemShown;
       }

       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }

       /**
        * @method toggleItems
        * @signature toggleItems()
        * @description
        *   [en]Toggle item visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggleItems',
       value: function toggleItems() {
         if (this.isOpen()) {
           this.hideItems();
         } else {
           this.showItems();
         }
       }
     }, {
       key: 'items',
       get: function get() {
         return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         if (value) {
           this.hideItems();
         }
         util.arrayFrom(this.children).forEach(function (e) {
           util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
         });

         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property inline
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is inline or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'inline',
       get: function get() {
         return this.hasAttribute('inline');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this._shown && this.style.display !== 'none';
       }
     }]);
     return SpeedDialElement;
   }(BaseElement);

   window.OnsSpeedDialElement = document.registerElement('ons-speed-dial', {
     prototype: SpeedDialElement.prototype
   });

   var rewritables$1 = {
     /**
      * @param {Element} element
      * @param {Function} callback
      */

     ready: function ready(element, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} element
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(element, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-splitter-content
    * @category splitter
    * @description
    *  [en]
    *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
    *
    *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
    *  [/en]
    *  [ja]ons-splitter-contentons-splitter[/ja]
    * @codepen rOQOML
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` component is the parent element.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterContentElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterContentElement, _BaseElement);

     function SplitterContentElement() {
       babelHelpers.classCallCheck(this, SplitterContentElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterContentElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterContentElement, [{
       key: 'createdCallback',


       /**
        * @attribute page
        * @type {String}
        * @description
        *   [en]
        *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
        *
        *     It is also possible to put `<ons-page>` element as a child of the element.
        *   [/en]
        *   [ja]ons-splitter-contentURL[/ja]
        */
       value: function createdCallback() {
         this._page = null;
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
         }
         this.attributeChangedCallback('page', null, this.getAttribute('page'));
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this2 = this;

         if (name === 'page' && current !== null) {
           rewritables$1.ready(this, function () {
             return _this2.load(current);
           });
         }
       }

       /**
        * @property page
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Page element loaded in the splitter content.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',


       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page, [options]
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in `page` in the content.[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new `<ons-page>` element[/en]
        *   [ja][/ja]
        */
       value: function load(page) {
         var _this3 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback;

         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$1.link(_this3, util.createFragment(html), options, function (fragment) {
               _this3._hide();
               _this3.innerHTML = '';

               _this3.appendChild(fragment);

               _this3._show();
               callback && callback();
               resolve(_this3.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }
     }]);
     return SplitterContentElement;
   }(BaseElement);

   window.OnsSplitterContentElement = document.registerElement('ons-splitter-content', {
     prototype: SplitterContentElement.prototype
   });

   window.OnsSplitterContentElement.rewritables = rewritables$1;

   var SplitterMaskElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterMaskElement, _BaseElement);

     function SplitterMaskElement() {
       babelHelpers.classCallCheck(this, SplitterMaskElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterMaskElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterMaskElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(event) {
         if (util.match(this.parentNode, 'ons-splitter')) {
           this.parentNode._sides.forEach(function (side) {
             return side.close('left').catch(function () {});
           });
         }
         event.stopPropagation();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick);
       }
     }]);
     return SplitterMaskElement;
   }(BaseElement);

   window.OnsSplitterMaskElement = document.registerElement('ons-splitter-mask', {
     prototype: SplitterMaskElement.prototype
   });

   var SplitterAnimator = function () {
     function SplitterAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, SplitterAnimator);

       this._options = {
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         duration: '0.3',
         delay: '0'
       };
       this.updateOptions(options);
     }

     babelHelpers.createClass(SplitterAnimator, [{
       key: 'updateOptions',
       value: function updateOptions() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         util.extend(this._options, options);
         this._timing = this._options.timing;
         this._duration = this._options.duration;
         this._delay = this._options.delay;
       }

       /**
        * @param {Element} sideElement
        */

     }, {
       key: 'activate',
       value: function activate(sideElement) {
         var _this = this;

         var splitter = sideElement.parentNode;

         contentReady(splitter, function () {
           _this._side = sideElement;
           _this._content = splitter.content;
           _this._mask = splitter.mask;
         });
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._content = this._side = this._mask = null;
       }
     }, {
       key: 'translate',
       value: function translate(distance) {
         animit(this._side).queue({
           transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
         }).play();
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'open',
       value: function open(done) {
         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           callback();
           done && done();
         }), animit(this._mask).wait(this._delay).queue({
           display: 'block'
         }).queue({
           opacity: '1'
         }, {
           duration: this._duration,
           timing: 'linear'
         }));
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'close',
       value: function close(done) {
         var _this2 = this;

         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(0px, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           _this2._side.style.webkitTransition = '';
           done && done();
           callback();
         }), animit(this._mask).wait(this._delay).queue({
           opacity: '0'
         }, {
           duration: this._duration,
           timing: 'linear'
         }).queue({
           display: 'none'
         }));
       }
     }, {
       key: 'minus',
       get: function get() {
         return this._side._side === 'right' ? '-' : '';
       }
     }]);
     return SplitterAnimator;
   }();

   /**
    * @element ons-splitter
    * @category splitter
    * @description
    *  [en]
    *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
    *
    *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
    *  [/en]
    *  [ja][/ja]
    * @codepen rOQOML
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using components from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @example
    * <ons-splitter id="splitter">
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse swipeable>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    *
    * <script>
    *   var splitter = document.getElementById('splitter');
    *   splitter.left.open();
    * </script>
    */

   var SplitterElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterElement, _BaseElement);

     function SplitterElement() {
       babelHelpers.classCallCheck(this, SplitterElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterElement, [{
       key: '_getSide',
       value: function _getSide(side) {
         var element = util.findChild(this, function (e) {
           return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
         });
         element && CustomElements.upgrade(element);
         return element;
       }

       /**
        * @property left
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Left `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(handler) {
         this._sides.some(function (s) {
           return s.isOpen ? s.close() : false;
         }) || handler.callParentHandler();
       }
     }, {
       key: '_onModeChange',
       value: function _onModeChange(e) {
         var _this2 = this;

         if (e.target.parentNode) {
           contentReady(this, function () {
             _this2._layout();
           });
         }
       }
     }, {
       key: '_layout',
       value: function _layout() {
         var _this3 = this;

         this._sides.forEach(function (side) {
           _this3.content.style[side._side] = side.mode === 'split' ? side._width : 0;
         });
       }
     }, {
       key: 'createdCallback',
       value: function createdCallback() {
         var _this4 = this;

         this._boundOnDeviceBackButton = this._onDeviceBackButton.bind(this);
         this._boundOnModeChange = this._onModeChange.bind(this);

         contentReady(this, function () {
           _this4._compile();
           _this4._layout();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (!this.mask) {
           this.appendChild(document.createElement('ons-splitter-mask'));
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._boundOnDeviceBackButton);
         this.addEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;
         this.removeEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'left',
       get: function get() {
         return this._getSide('left');
       }
       /**
        * @property right
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Right `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'right',
       get: function get() {
         return this._getSide('right');
       }
     }, {
       key: '_sides',
       get: function get() {
         return [this.left, this.right].filter(function (e) {
           return e;
         });
       }
       /**
        * @property content
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The `<ons-splitter-content>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'content',
       get: function get() {
         return util.findChild(this, 'ons-splitter-content');
       }
     }, {
       key: 'mask',
       get: function get() {
         return util.findChild(this, 'ons-splitter-mask');
       }

       /**
        * @property onDeviceBackButton
        * @readonly
        * @type {Object}
        * @description
        *   [en]Retrieve the back button handler.[/en]
        *   [ja]ons-splitter[/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       }
     }]);
     return SplitterElement;
   }(BaseElement);

   window.OnsSplitterElement = document.registerElement('ons-splitter', {
     prototype: SplitterElement.prototype
   });

   window.OnsSplitterElement._animatorDict = {
     default: SplitterAnimator,
     overlay: SplitterAnimator
   };

   window.OnsSplitterElement.registerAnimator = function (name, Animator) {
     if (!(Animator instanceof SplitterAnimator)) {
       throw new Error('Animator parameter must be an instance of SplitterAnimator.');
     }
     window.OnsSplitterElement._animatorDict[name] = Animator;
   };

   window.OnsSplitterElement.SplitterAnimator = SplitterAnimator;

   var OnsSplitterElement$1 = OnsSplitterElement;

   var SPLIT_MODE = 'split';
   var COLLAPSE_MODE = 'collapse';
   var CLOSED_STATE = 'closed';
   var OPEN_STATE = 'open';
   var CHANGING_STATE = 'changing';

   var rewritables$2 = {
     /**
      * @param {Element} splitterSideElement
      * @param {Function} callback
      */

     ready: function ready(splitterSideElement, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} splitterSideElement
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(splitterSideElement, target, options, callback) {
       callback(target);
     }
   };

   var CollapseDetection = function () {
     function CollapseDetection(element, target) {
       babelHelpers.classCallCheck(this, CollapseDetection);

       this._element = element;
       this._boundOnChange = this._onChange.bind(this);
       target && this.changeTarget(target);
     }

     babelHelpers.createClass(CollapseDetection, [{
       key: 'changeTarget',
       value: function changeTarget(target) {
         this.disable();
         this._target = target;
         if (target) {
           this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
           this.activate();
         }
       }
     }, {
       key: '_match',
       value: function _match(value) {
         if (this._orientation) {
           return this._target === (value.isPortrait ? 'portrait' : 'landscape');
         }
         return value.matches;
       }
     }, {
       key: '_onChange',
       value: function _onChange(value) {
         this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
       }
     }, {
       key: 'activate',
       value: function activate() {
         if (this._orientation) {
           ons.orientation.on('change', this._boundOnChange);
           this._onChange({ isPortrait: ons.orientation.isPortrait() });
         } else {
           this._queryResult = window.matchMedia(this._target);
           this._queryResult.addListener(this._boundOnChange);
           this._onChange(this._queryResult);
         }
       }
     }, {
       key: 'disable',
       value: function disable() {
         if (this._orientation) {
           ons.orientation.off('change', this._boundOnChange);
         } else if (this._queryResult) {
           this._queryResult.removeListener(this._boundOnChange);
           this._queryResult = null;
         }
       }
     }]);
     return CollapseDetection;
   }();

   var widthToPx = function widthToPx(width, parent) {
     var value = parseInt(width, 10);
     var px = /px/.test(width);

     return px ? value : Math.round(parent.offsetWidth * value / 100);
   };

   var CollapseMode = function () {
     babelHelpers.createClass(CollapseMode, [{
       key: '_animator',
       get: function get() {
         return this._element._animator;
       }
     }]);

     function CollapseMode(element) {
       babelHelpers.classCallCheck(this, CollapseMode);

       this._active = false;
       this._state = CLOSED_STATE;
       this._element = element;
       this._lock = new DoorLock();
     }

     babelHelpers.createClass(CollapseMode, [{
       key: 'isOpen',
       value: function isOpen() {
         return this._active && this._state !== CLOSED_STATE;
       }
     }, {
       key: 'handleGesture',
       value: function handleGesture(e) {
         if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
           return;
         }
         if (e.type === 'dragstart') {
           this._onDragStart(e);
         } else if (!this._ignoreDrag) {
           e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         var scrolling = !/left|right/.test(event.gesture.direction);
         var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
         var area = this._element._swipeTargetWidth;
         var isOpen = this.isOpen();
         this._ignoreDrag = scrolling || area && distance > area && !isOpen;

         this._width = widthToPx(this._element._width, this._element.parentNode);
         this._startDistance = this._distance = isOpen ? this._width : 0;
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         event.gesture.preventDefault();
         var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
         var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
         if (distance !== this._distance) {
           this._animator.translate(distance);
           this._distance = distance;
           this._state = CHANGING_STATE;
         }
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var distance = this._distance;
         var width = this._width;
         var el = this._element;

         var direction = event.gesture.interimDirection;
         var shouldOpen = el._side !== direction && distance > width * el._threshold;
         this.executeAction(shouldOpen ? 'open' : 'close');
       }
     }, {
       key: 'layout',
       value: function layout() {
         if (this._active && this._state === OPEN_STATE) {
           this._animator.open();
         }
       }

       // enter collapse mode

     }, {
       key: 'enterMode',
       value: function enterMode() {
         if (!this._active) {
           this._active = true;
           this.layout();
         }
       }

       // exit collapse mode

     }, {
       key: 'exitMode',
       value: function exitMode() {
         this._active = false;
       }
     }, {
       key: '_isOpenOtherSideMenu',
       value: function _isOpenOtherSideMenu() {
         var _this = this;

         return util.arrayFrom(this._element.parentElement.children).some(function (e) {
           return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
         });
       }

       /**
        * @param {String} name - 'open' or 'close'
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @param {Boolean} [options.withoutAnimation]
        * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
        */

     }, {
       key: 'executeAction',
       value: function executeAction(name) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

         if (!this._active) {
           return Promise.resolve(false);
         }

         if (this._state === FINAL_STATE) {
           return Promise.resolve(this._element);
         }
         if (this._lock.isLocked()) {
           return Promise.reject('Splitter side is locked.');
         }
         if (name === 'open' && this._isOpenOtherSideMenu()) {
           return Promise.reject('Another menu is already open.');
         }
         if (this._element._emitEvent('pre' + name)) {
           return Promise.reject('Canceled in pre' + name + ' event.');
         }

         var callback = options.callback;
         var unlock = this._lock.lock();
         var done = function done() {
           _this2._state = FINAL_STATE;
           _this2.layout();
           unlock();
           _this2._element._emitEvent('post' + name);
           callback && callback();
         };

         if (options.withoutAnimation) {
           done();
           return Promise.resolve(this._element);
         }
         this._state = CHANGING_STATE;
         return new Promise(function (resolve) {
           _this2._animator[name](function () {
             done();
             resolve(_this2._element);
           });
         });
       }
     }]);
     return CollapseMode;
   }();

   /**
    * @element ons-splitter-side
    * @category splitter
    * @description
    *  [en]
    *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
    *
    *    It will be displayed on either the left or right side of the `<ons-splitte-content>` element.
    *
    *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
    *  [/en]
    *  [ja]ons-splitter-sideons-splitter[/ja]
    * @codepen rOQOML
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` is the parent component.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */


   var SplitterSideElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterSideElement, _BaseElement);

     function SplitterSideElement() {
       babelHelpers.classCallCheck(this, SplitterSideElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterSideElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterSideElement, [{
       key: 'createdCallback',


       /**
        * @event modechange
        * @description
        *   [en]Fired just after the component's mode changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.mode
        *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preopen
        * @description
        *   [en]Fired just before the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding menu.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postopen
        * @description
        *   [en]Fired just after the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preclose
        * @description
        *   [en]Fired just before the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding-menu.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postclose
        * @description
        *   [en]Fired just after the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default  default
        * @description
        *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
        *  [ja]"overlay", "default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute open-threshold
        * @type {Number}
        * @default  0.3
        * @description
        *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
        *  [ja]010.3[/ja]
        */

       /**
        * @attribute collapse
        * @type {String}
        * @description
        *   [en]
        *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
        *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
        *     If the value is a media query, the view will collapse when the media query resolves to `true`.
        *     If the value is not defined, the view always be in `"collapse"` mode.
        *   [/en]
        *   [ja]
        *     portrait, landscapewidth #px
        *     portraitlandscape
        *     
        *     collapse
        *   [/ja]
        */

       /**
        * @attribute swipe-target-width
        * @type {String}
        * @description
        *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute width
        * @type {String}
        * @description
        *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
        *   [ja]px%eg. 90%, 200px[/ja]
        */

       /**
        * @attribute side
        * @type {String}
        * @default left
        * @description
        *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
        *   [ja]"left""right"[/ja]
        */

       /**
        * @attribute mode
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
        *   [ja]"collapse""split"[/ja]
        */

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The URL of the menu page.[/en]
        *   [ja]ons-splitter-sideURL[/ja]
        */

       /**
        * @attribute swipeable
        * @type {Boolean}
        * @description
        *   [en]Whether to enable swipe interaction on collapse mode.[/en]
        *   [ja]collapse[/ja]
        */

       value: function createdCallback() {
         var _this4 = this;

         this._collapseMode = new CollapseMode(this);
         this._collapseDetection = new CollapseDetection(this);
         this._animatorFactory = new AnimatorFactory({
           animators: OnsSplitterElement$1._animatorDict,
           baseClass: SplitterAnimator,
           baseClassName: 'SplitterAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
         this._boundHandleGesture = function (e) {
           return _this4._collapseMode.handleGesture(e);
         };
         this._watchedAttributes = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold', 'page'];
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this5 = this;

         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('Parent must be an ons-splitter element.');
         }

         this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

         if (!this.hasAttribute('side')) {
           this.setAttribute('side', 'left');
         }

         contentReady(this, function () {
           _this5._watchedAttributes.forEach(function (e) {
             return _this5._update(e);
           });
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._collapseDetection.disable();
         this._gestureDetector.dispose();
         this._gestureDetector = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (this._watchedAttributes.indexOf(name) !== -1) {
           this._update(name, current);
         }
       }
     }, {
       key: '_update',
       value: function _update(name, value) {
         name = '_update' + name.split('-').map(function (e) {
           return e[0].toUpperCase() + e.slice(1);
         }).join('');
         return this[name](value);
       }
     }, {
       key: '_emitEvent',
       value: function _emitEvent(name) {
         if (name.slice(0, 3) !== 'pre') {
           return util.triggerElementEvent(this, name, { side: this });
         }
         var isCanceled = false;

         util.triggerElementEvent(this, name, {
           side: this,
           cancel: function cancel() {
             return isCanceled = true;
           }
         });

         return isCanceled;
       }
     }, {
       key: '_updateCollapse',
       value: function _updateCollapse() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('collapse') : arguments[0];

         if (value === null || value === 'split') {
           this._collapseDetection.disable();
           return this._updateMode(SPLIT_MODE);
         }
         if (value === '' || value === 'collapse') {
           this._collapseDetection.disable();
           return this._updateMode(COLLAPSE_MODE);
         }

         this._collapseDetection.changeTarget(value);
       }

       // readonly attribute for the users

     }, {
       key: '_updateMode',
       value: function _updateMode(mode) {
         if (mode !== this._mode) {
           this._mode = mode;
           this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
           this.setAttribute('mode', mode);

           util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
         }
       }
     }, {
       key: '_updatePage',
       value: function _updatePage() {
         var _this6 = this;

         var page = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('page') : arguments[0];

         if (page !== null) {
           rewritables$2.ready(this, function () {
             return _this6.load(page);
           });
         }
       }
     }, {
       key: '_updateOpenThreshold',
       value: function _updateOpenThreshold() {
         var threshold = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('open-threshold') : arguments[0];

         this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         var swipeable = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipeable') : arguments[0];

         var action = swipeable === null ? 'off' : 'on';

         if (this._gestureDetector) {
           this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
         }
       }
     }, {
       key: '_updateSwipeTargetWidth',
       value: function _updateSwipeTargetWidth() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipe-target-width') : arguments[0];

         this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         var width = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('width') : arguments[0];

         this._width = /^\d+(px|%)$/.test(width) ? width : '80%';
         this.style.width = this._width;
       }
     }, {
       key: '_updateSide',
       value: function _updateSide() {
         var side = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('side') : arguments[0];

         this._side = side === 'right' ? side : 'left';
       }
     }, {
       key: '_updateAnimation',
       value: function _updateAnimation() {
         var animation = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation') : arguments[0];

         this._animator = this._animatorFactory.newAnimator({ animation: animation });
         this._animator.activate(this);
       }
     }, {
       key: '_updateAnimationOptions',
       value: function _updateAnimationOptions() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation-options') : arguments[0];

         this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
       }

       /**
        * @property page
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Page element loaded in the splitter side.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'open',


       /**
        * @method open
        * @signature open([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */
       value: function open() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('open', options);
       }

       /**
        * @method close
        * @signature close([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'close',
       value: function close() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('close', options);
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        * @description
        *   [en]Opens if it's closed. Closes if it's open.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this.isOpen ? this.close(options) : this.open(options);
       }

       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page
        *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in pageUrl in the right section[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',
       value: function load(page) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback;

         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$2.link(_this7, util.createFragment(html), options, function (fragment) {
               _this7._hide();

               _this7.innerHTML = '';
               _this7.appendChild(fragment);

               _this7._show();
               callback && callback();
               resolve(_this7.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }

       /**
        * @property mode
        * @readonly
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'mode',
       get: function get() {
         return this._mode;
       }

       /**
        * @property isOpen
        * @type {Boolean}
        * @readonly
        * @description
        *   [en]This value is `true` when the menu is open..[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'isOpen',
       get: function get() {
         return this._collapseMode.isOpen();
       }
     }]);
     return SplitterSideElement;
   }(BaseElement);

   window.OnsSplitterSideElement = document.registerElement('ons-splitter-side', {
     prototype: SplitterSideElement.prototype
   });

   window.OnsSplitterSideElement.rewritables = rewritables$2;

   var scheme$19 = {
     '': 'switch--*',
     '.switch__input': 'switch--*__input',
     '.switch__handle': 'switch--*__handle',
     '.switch__toggle': 'switch--*__toggle'
   };

   var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

   var locations = {
     ios: [1, 21],
     material: [0, 16]
   };

   /**
    * @element ons-switch
    * @category switch
    * @description
    *   [en]
    *     Switch component. The switch can be toggled both by dragging and tapping.
    *
    *     Will automatically displays a Material Design switch on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Material Design switch[/en]
    *   [ja][/ja]
    * @codepen LpXZQQ
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @example
    * <ons-switch checked></ons-switch>
    * <ons-switch disabled></ons-switch>
    * <ons-switch modifier="material"></ons-switch>
    */

   var SwitchElement = function (_BaseElement) {
     babelHelpers.inherits(SwitchElement, _BaseElement);

     function SwitchElement() {
       babelHelpers.classCallCheck(this, SwitchElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SwitchElement).apply(this, arguments));
     }

     babelHelpers.createClass(SwitchElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._checkbox = this.querySelector('.switch__input');
         this._handle = this.querySelector('.switch__handle');

         ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('switch');

         this.appendChild(template$2.cloneNode(true));

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._checkbox.removeEventListener('change', this._onChange);
         this.removeEventListener('dragstart', this._onDragStart);
         this.removeEventListener('hold', this._onHold);
         this.removeEventListener('tap', this.click);
         this.removeEventListener('click', this._onClick);
         this._gestureDetector.dispose();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._checkbox.addEventListener('change', this._onChange);
         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
         this.addEventListener('dragstart', this._onDragStart);
         this.addEventListener('hold', this._onHold);
         this.addEventListener('tap', this.click);
         this._boundOnRelease = this._onRelease.bind(this);
         this.addEventListener('click', this._onClick);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         if (this.checked) {
           this.parentNode.setAttribute('checked', '');
         } else {
           this.parentNode.removeAttribute('checked');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick(ev) {
         if (ev.target.classList.contains('switch__touch')) {
           ev.preventDefault();
         }
       }
     }, {
       key: 'click',
       value: function click() {
         if (!this.disabled) {
           this.checked = !this.checked;
           util.triggerElementEvent(this.checkbox, 'change');
         }
       }
     }, {
       key: '_getPosition',
       value: function _getPosition(e) {
         var l = this._locations;
         return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this.classList.add('switch--active');
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
           this.classList.remove('switch--active');
           return;
         }
         this.classList.add('switch--active');
         this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

         this.addEventListener('drag', this._onDrag);
         document.addEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(e) {
         e.gesture.srcEvent.preventDefault();
         this._handle.style.left = this._getPosition(e) + 'px';
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var l = this._locations;
         var position = this._getPosition(e);

         this.checked = position >= (l[0] + l[1]) / 2;

         this.removeEventListener('drag', this._onDrag);
         document.removeEventListener('release', this._boundOnRelease);

         this._handle.style.left = '';
         this.classList.remove('switch--active');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             this._isMaterial = (current || '').indexOf('material') !== -1;
             this._locations = locations[this._isMaterial ? 'material' : 'ios'];
             ModifierUtil.onModifierChanged(last, current, this, scheme$19);
             break;
           case 'input-id':
             this._checkbox.id = current;
             break;
           case 'checked':
             this._checkbox.checked = current !== null;
             util.toggleAttribute(this._checkbox, name, current !== null);
             break;
           case 'disabled':
             util.toggleAttribute(this._checkbox, name, current !== null);
         }
       }
     }, {
       key: 'checked',


       /**
        * @event change
        * @description
        *   [en]Fired when the switch is toggled.[/en]
        *   [ja]ON/OFF[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.switch
        *   [en]Switch object.[/en]
        *   [ja]Switch[/ja]
        * @param {Boolean} event.value
        *   [en]Current value.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isInteractive
        *   [en]True if the change was triggered by the user clicking on the switch.[/en]
        *   [ja]true[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the switch.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Whether the switch is be disabled.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute checked
        * @description
        *   [en]Whether the switch is checked.[/en]
        *   [ja]ON[/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]This value is `true` if the switch is checked.[/en]
        *   [ja]ON`true`[/ja]
        */

       get: function get() {
         return this._checkbox.checked;
       },
       set: function set(value) {
         if (!!value !== this._checkbox.checked) {
           this._checkbox.click();
           this._checkbox.checked = !!value;
           return util.toggleAttribute(this, 'checked', this.checked);
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this._checkbox.disabled;
       },
       set: function set(value) {
         this._checkbox.disabled = value;
         return util.toggleAttribute(this, 'disabled', this.disabled);
       }

       /**
        * @property checkbox
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The underlying checkbox element.[/en]
        *   [ja]checkbox[/ja]
        */

     }, {
       key: 'checkbox',
       get: function get() {
         return this._checkbox;
       }
     }]);
     return SwitchElement;
   }(BaseElement);

   window.OnsSwitchElement = document.registerElement('ons-switch', {
     prototype: SwitchElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var TabbarAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function TabbarAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, TabbarAnimator);

       this.timing = options.timing || 'linear';
       this.duration = options.duration !== undefined ? options.duration : '0.4';
       this.delay = options.delay !== undefined ? options.delay : '0';
     }

     /**
      * @param {Element} enterPage ons-page element
      * @param {Element} leavePage ons-page element
      * @param {Number} enterPageIndex
      * @param {Number} leavePageIndex
      * @param {Function} done
      */


     babelHelpers.createClass(TabbarAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         throw new Error('This method must be implemented.');
       }
     }]);
     return TabbarAnimator;
   }();

   var TabbarNoneAnimator = function (_TabbarAnimator) {
     babelHelpers.inherits(TabbarNoneAnimator, _TabbarAnimator);

     function TabbarNoneAnimator() {
       babelHelpers.classCallCheck(this, TabbarNoneAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarNoneAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarNoneAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         setTimeout(done, 1000 / 60);
       }
     }]);
     return TabbarNoneAnimator;
   }(TabbarAnimator);

   var TabbarFadeAnimator = function (_TabbarAnimator2) {
     babelHelpers.inherits(TabbarFadeAnimator, _TabbarAnimator2);

     function TabbarFadeAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarFadeAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'linear';
       options.duration = options.duration !== undefined ? options.duration : '0.4';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarFadeAnimator).call(this, options));
     }

     babelHelpers.createClass(TabbarFadeAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarFadeAnimator;
   }(TabbarAnimator);

   var TabbarSlideAnimator = function (_TabbarAnimator3) {
     babelHelpers.inherits(TabbarSlideAnimator, _TabbarAnimator3);

     function TabbarSlideAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarSlideAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'ease-in';
       options.duration = options.duration !== undefined ? options.duration : '0.15';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarSlideAnimator).call(this, options));
     }

     /**
      * @param {jqLite} enterPage
      * @param {jqLite} leavePage
      */


     babelHelpers.createClass(TabbarSlideAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         var sgn = enterIndex > leaveIndex;

         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarSlideAnimator;
   }(TabbarAnimator);

   var scheme$21 = {
     '.tab-bar__content': 'tab-bar--*__content',
     '.tab-bar': 'tab-bar--*'
   };

   var _animatorDict$5 = {
     'default': TabbarNoneAnimator,
     'fade': TabbarFadeAnimator,
     'slide': TabbarSlideAnimator,
     'none': TabbarNoneAnimator
   };

   var rewritables$3 = {
     /**
      * @param {Element} tabbarElement
      * @param {Function} callback
      */

     ready: function ready(tabbarElement, callback) {
       callback();
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(tabbarElement, target, options, callback) {
       callback(target);
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Function} callback
      */
     unlink: function unlink(tabbarElement, target, callback) {
       callback(target);
     }
   };

   var generateId$1 = function () {
     var i = 0;
     return function () {
       return 'ons-tabbar-gen-' + i++;
     };
   }();

   /**
    * @element ons-tabbar
    * @category tabbar
    * @description
    *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
    *   [ja]ons-tab[/ja]
    * @codepen pGuDL
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tab
    *   [en]The `<ons-tab>` component.[/en]
    *   [ja]ons-tab[/ja]
    * @seealso ons-page
    *   [en]The `<ons-page>` component.[/en]
    *   [ja]ons-page[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>
    */

   var TabbarElement = function (_BaseElement) {
     babelHelpers.inherits(TabbarElement, _BaseElement);

     function TabbarElement() {
       babelHelpers.classCallCheck(this, TabbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarElement, [{
       key: 'createdCallback',


       /**
        * @event prechange
        * @description
        *   [en]Fires just before the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the change event.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postchange
        * @description
        *   [en]Fires just after the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @event reactive
        * @description
        *   [en]Fires if the already open tab is tapped again.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default none
        * @description
        *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
        *   [ja]"none""fade""slide""none"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute position
        * @initonly
        * @type {String}
        * @default bottom
        * @description
        *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
        *   [ja]"bottom""top""bottom"[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this._tabbarId = generateId$1();

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           for (var i = 0; i < _this2.firstChild.children.length; i++) {
             _this2.firstChild.children[i].style.display = 'none';
           }

           var activeIndex = _this2.getAttribute('activeIndex');

           if (activeIndex && _this2.children[1].children.length > activeIndex) {
             _this2.children[1].children[activeIndex].setAttribute('active', 'true');
           }

           autoStyle.prepare(_this2);
           ModifierUtil.initModifier(_this2, scheme$21);

           _this2._animatorFactory = new AnimatorFactory({
             animators: _animatorDict$5,
             baseClass: TabbarAnimator,
             baseClassName: 'TabbarAnimator',
             defaultAnimation: _this2.getAttribute('animation')
           });
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var content = util.create('.ons-tab-bar__content.tab-bar__content');
         var tabbar = util.create('.tab-bar.ons-tab-bar__footer.ons-tabbar-inner');

         while (this.firstChild) {
           tabbar.appendChild(this.firstChild);
         }

         this.appendChild(content);
         this.appendChild(tabbar);

         this._updatePosition();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var _this3 = this;

         var position = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('position') : arguments[0];

         var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
         var action = top ? util.addModifier : util.removeModifier;

         action(this, 'top');

         var page = util.findParent(this, 'ons-page');
         if (page) {
           this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

           if (util.match(page.firstChild, 'ons-toolbar')) {
             action(page.firstChild, 'noshadow');
           }
         }

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this3, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
         });
       }
     }, {
       key: '_getTabbarElement',
       value: function _getTabbarElement() {
         return util.findChild(this, '.tab-bar');
       }

       /**
        * @method loadPage
        * @signature loadPage(url, [options])
        * @param {String} url
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @description
        *   [en]Displays a new page without changing the active index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'loadPage',
       value: function loadPage(page) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           OnsTabElement.prototype._createPageElement(page, function (pageElement) {
             resolve(_this4._loadPageDOMAsync(pageElement, options));
           });
         });
       }

       /**
        * @param {Element} pageElement
        * @param {Object} [options]
        * @param {Object} [options.animation]
        * @param {Object} [options.callback]
        * @return {Promise} Resolves to the new page element.
        */

     }, {
       key: '_loadPageDOMAsync',
       value: function _loadPageDOMAsync(pageElement) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           rewritables$3.link(_this5, pageElement, options, function (pageElement) {
             _this5._contentElement.appendChild(pageElement);

             if (_this5.getActiveTabIndex() !== -1) {
               resolve(_this5._switchPage(pageElement, options));
             } else {
               if (options.callback instanceof Function) {
                 options.callback();
               }

               _this5._oldPageElement = pageElement;
               resolve(pageElement);
             }
           });
         });
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getTabbarId',
       value: function getTabbarId() {
         return this._tabbarId;
       }

       /**
        * @return {Element/null}
        */

     }, {
       key: '_getCurrentPageElement',
       value: function _getCurrentPageElement() {
         var pages = this._contentElement.children;
         var page = null;
         for (var i = 0; i < pages.length; i++) {
           if (pages[i].style.display !== 'none') {
             page = pages[i];
             break;
           }
         }

         if (page && page.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('Invalid state: page element must be a "ons-page" element.');
         }

         return page;
       }
     }, {
       key: '_switchPage',


       /**
        * @param {Element} element
        * @param {Object} options
        * @param {String} [options.animation]
        * @param {Function} [options.callback]
        * @param {Object} [options.animationOptions]
        * @param {Number} options.selectedTabIndex
        * @param {Number} options.previousTabIndex
        * @return {Promise} Resolves to the new page element.
        */
       value: function _switchPage(element, options) {
         var oldPageElement = this._oldPageElement || internal.nullElement;
         this._oldPageElement = element;
         var animator = this._animatorFactory.newAnimator(options);

         return new Promise(function (resolve) {
           if (oldPageElement !== internal.nullElement) {
             oldPageElement._hide();
           }

           animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
             if (oldPageElement !== internal.nullElement) {
               oldPageElement.style.display = 'none';
             }

             element.style.display = 'block';
             element._show();

             if (options.callback instanceof Function) {
               options.callback();
             }

             resolve(element);
           });
         });
       }

       /**
        * @method setActiveTab
        * @signature setActiveTab(index, [options])
        * @param {Number} index
        *   [en]Tab index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Boolean} [options.keepPage]
        *   [en]If true the page will not be changed.[/en]
        *   [ja]pagetrue[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
        *   [ja]`"fade"``"slide"``"none"`[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveTab',
       value: function setActiveTab(index) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         if (!options.animation && this.hasAttribute('animation')) {
           options.animation = this.getAttribute('animation');
         }

         var previousTab = this._getActiveTabElement(),
             selectedTab = this._getTabElement(index),
             previousTabIndex = this.getActiveTabIndex(),
             selectedTabIndex = index,
             previousPageElement = this._getCurrentPageElement();

         if (!selectedTab) {
           return Promise.reject('Specified index does not match any tab.');
         }

         if (selectedTabIndex === previousTabIndex) {
           util.triggerElementEvent(this, 'reactive', {
             index: selectedTabIndex,
             tabItem: selectedTab
           });

           return Promise.resolve(previousPageElement);
         }

         var canceled = false;

         util.triggerElementEvent(this, 'prechange', {
           index: selectedTabIndex,
           tabItem: selectedTab,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           selectedTab.setInactive();
           if (previousTab) {
             previousTab.setActive();
           }
           return Promise.reject('Canceled in prechange event.');
         }

         selectedTab.setActive();

         var needLoad = !selectedTab.isLoaded() && !options.keepPage;

         util.arrayFrom(this._getTabbarElement().children).forEach(function (tab) {
           if (tab != selectedTab) {
             tab.setInactive();
           } else {
             if (!needLoad) {
               util.triggerElementEvent(_this6, 'postchange', {
                 index: selectedTabIndex,
                 tabItem: selectedTab
               });
             }
           }
         });

         if (needLoad) {
           var removeElement;
           var params;

           var _ret = function () {
             removeElement = false;


             if (!previousTab && previousPageElement || previousTab && previousTab._pageElement !== previousPageElement) {
               removeElement = true;
             }

             params = {
               callback: function callback() {
                 util.triggerElementEvent(_this6, 'postchange', {
                   index: selectedTabIndex,
                   tabItem: selectedTab
                 });

                 if (options.callback instanceof Function) {
                   options.callback();
                 }
               },
               previousTabIndex: previousTabIndex,
               selectedTabIndex: selectedTabIndex
             };


             if (options.animation) {
               params.animation = options.animation;
             }

             params.animationOptions = options.animationOptions || {};

             var link = function link(element, callback) {
               rewritables$3.link(_this6, element, options, callback);
             };

             return {
               v: new Promise(function (resolve) {
                 selectedTab._loadPageElement(function (pageElement) {
                   resolve(_this6._loadPersistentPageDOM(pageElement, params));
                 }, link);
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         }

         return Promise.resolve(previousPageElement);
       }

       /**
        * @param {Element} element
        * @param {Object} options
        * @param {Object} options.animation
        */

     }, {
       key: '_loadPersistentPageDOM',
       value: function _loadPersistentPageDOM(element) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


         if (!util.isAttached(element)) {
           this._contentElement.appendChild(element);
         }

         element.removeAttribute('style');
         return this._switchPage(element, options);
       }

       /**
        * @method setTabbarVisibility
        * @signature setTabbarVisibility(visible)
        * @param {Boolean} visible
        * @description
        *   [en]Used to hide or show the tab bar.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setTabbarVisibility',
       value: function setTabbarVisibility(visible) {
         this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
         this._getTabbarElement().style.display = visible ? '' : 'none';
       }

       /**
        * @method getActiveTabIndex
        * @signature getActiveTabIndex()
        * @return {Number}
        *   [en]The index of the currently active tab.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
        *   [ja]-1[/ja]
        */

     }, {
       key: 'getActiveTabIndex',
       value: function getActiveTabIndex() {
         var tabs = this._getTabbarElement().children;

         for (var i = 0; i < tabs.length; i++) {
           if (tabs[i] instanceof window.OnsTabElement && tabs[i].isActive && tabs[i].isActive()) {
             return i;
           }
         }

         return -1;
       }

       /**
        * @return {Number} When active tab is not found, returns -1.
        */

     }, {
       key: '_getActiveTabElement',
       value: function _getActiveTabElement() {
         return this._getTabElement(this.getActiveTabIndex());
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_getTabElement',
       value: function _getTabElement(index) {
         return this._getTabbarElement().children[index];
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {}
     }, {
       key: '_show',
       value: function _show() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         var pages = this._contentElement.children;
         for (var i = pages.length - 1; i >= 0; i--) {
           pages[i]._destroy();
         }
         this.remove();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
         }
       }
     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this, '.tab-bar__content');
       }
     }, {
       key: 'pages',
       get: function get() {
         return util.arrayFrom(this._contentElement.children);
       }
     }]);
     return TabbarElement;
   }(BaseElement);

   window.OnsTabbarElement = document.registerElement('ons-tabbar', {
     prototype: TabbarElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsTabbarElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof TabbarAnimator)) {
       throw new Error('"Animator" param must inherit OnsTabbarElement.TabbarAnimator');
     }
     _animatorDict$5[name] = Animator;
   };

   window.OnsTabbarElement.rewritables = rewritables$3;
   window.OnsTabbarElement.TabbarAnimator = TabbarAnimator;

   var OnsTabbarElement$1 = OnsTabbarElement;

   var scheme$20 = {
     '': 'tab-bar--*__item',
     '.tab-bar__button': 'tab-bar--*__button'
   };
   var templateSource$2 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button tab-bar-inner"></button>\n  </div>\n');
   var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n  </div>\n');

   /**
    * @element ons-tab
    * @category tabbar
    * @description
    *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
    *   [ja]
    *     ons-tab
    *     ons-tab
    *   [/ja]
    * @codepen pGuDL
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja][/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tabbar
    *   [en]ons-tabbar component[/en]
    *   [ja]ons-tabbar[/ja]
    * @seealso ons-page
    *   [en]ons-page component[/en]
    *   [ja]ons-page[/ja]
    * @seealso ons-icon
    *   [en]ons-icon component[/en]
    *   [ja]ons-icon[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>

    */

   var TabElement = function (_BaseElement) {
     babelHelpers.inherits(TabElement, _BaseElement);

     function TabElement() {
       babelHelpers.classCallCheck(this, TabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabElement, [{
       key: 'createdCallback',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The page that is displayed when the tab is tapped.[/en]
        *   [ja]ons-tabURL[/ja]
        */

       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
        *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
        *   [/en]
        *   [ja]
        *     ons-icon
        *     background-imageCSS
        *   [/ja]
        */

       /**
        * @attribute active-icon
        * @type {String}
        * @description
        *   [en]The name of the icon when the tab is active.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute label
        * @type {String}
        * @description
        *   [en]The label of the tab item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute active
        * @description
        *   [en]This attribute should be set to the tab that is active by default.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         if (this.hasAttribute('label') || this.hasAttribute('icon')) {
           if (!this.hasAttribute('_compiled')) {
             this._compile();
           }
         } else {
           contentReady(this, function () {
             if (!_this2.hasAttribute('_compiled')) {
               _this2._compile();
             }
           });
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var fragment = document.createDocumentFragment();
         var hasChildren = false;

         while (this.childNodes[0]) {
           var node = this.childNodes[0];
           this.removeChild(node);
           fragment.appendChild(node);

           if (node.nodeType == Node.ELEMENT_NODE) {
             hasChildren = true;
           }
         }

         var template = templateSource$2.cloneNode(true);
         while (template.children[0]) {
           this.appendChild(template.children[0]);
         }
         this.classList.add('tab-bar__item');

         var button = util.findChild(this, '.tab-bar__button');

         if (hasChildren) {
           button.appendChild(fragment);
           this._hasDefaultTemplate = false;
         } else {
           this._hasDefaultTemplate = true;
           this._updateDefaultTemplate();
         }

         ModifierUtil.initModifier(this, scheme$20);
         this._updateRipple();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         // util.updateRipple(this.querySelector('.tab-bar__button'), this);
       }
     }, {
       key: '_updateDefaultTemplate',
       value: function _updateDefaultTemplate() {
         if (!this._hasDefaultTemplate) {
           return;
         }

         var button = util.findChild(this, '.tab-bar__button');

         var template = defaultInnerTemplateSource.cloneNode(true);

         if (!button.querySelector('.tab-bar__icon')) {
           button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
         }

         if (!button.querySelector('.tab-bar__label')) {
           button.appendChild(template.querySelector('.tab-bar__label'));
         }

         var self = this;
         var icon = this.getAttribute('icon');
         var label = this.getAttribute('label');

         if (typeof icon === 'string') {
           getIconElement().setAttribute('icon', icon);
         } else {
           var wrapper = button.querySelector('.tab-bar__icon');
           if (wrapper) {
             wrapper.remove();
           }
         }

         if (typeof label === 'string') {
           getLabelElement().textContent = label;
         } else {
           var _label = getLabelElement();
           if (_label) {
             _label.remove();
           }
         }

         function getLabelElement() {
           return self.querySelector('.tab-bar__label');
         }

         function getIconElement() {
           return self.querySelector('ons-icon');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick() {
         var tabbar = this._findTabbarElement();
         if (tabbar) {
           tabbar.setActiveTab(this._findTabIndex());
         }
       }
     }, {
       key: 'setActive',
       value: function setActive() {
         var radio = util.findChild(this, 'input');
         radio.checked = true;
         this.classList.add('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'none';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
       }
     }, {
       key: 'setInactive',
       value: function setInactive() {
         var radio = util.findChild(this, 'input');
         radio.checked = false;
         this.classList.remove('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'none';
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLoaded',
       value: function isLoaded() {
         return false;
       }

       /**
        * @param {Function} callback
        * @param {Function} link
        */

     }, {
       key: '_loadPageElement',
       value: function _loadPageElement(callback, link) {
         var _this3 = this;

         if (!this.pageElement) {
           this._createPageElement(this.getAttribute('page'), function (element) {
             link(element, function (element) {
               _this3.pageElement = element;
               callback(element);
             });
           });
         } else {
           callback(this.pageElement);
         }
       }
     }, {
       key: '_createPageElement',


       /**
        * @param {String} page
        * @param {Function} callback
        */
       value: function _createPageElement(page, callback) {
         internal.getPageHTMLAsync(page).then(function (html) {
           callback(util.createElement(html.trim()));
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isActive',
       value: function isActive() {
         return this.classList.contains('active');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           _this4._ensureElementPosition();

           var tabbar = _this4._findTabbarElement();

           if (tabbar.hasAttribute('modifier')) {
             var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
             _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
           }

           if (_this4.hasAttribute('active')) {
             (function () {
               var tabIndex = _this4._findTabIndex();

               OnsTabbarElement$1.rewritables.ready(tabbar, function () {
                 setImmediate(function () {
                   return tabbar.setActiveTab(tabIndex, { animation: 'none' });
                 });
               });
             })();
           } else {
             OnsTabbarElement$1.rewritables.ready(tabbar, function () {
               setImmediate(function () {
                 if (_this4.hasAttribute('page')) {
                   _this4._createPageElement(_this4.getAttribute('page'), function (pageElement) {
                     OnsTabbarElement$1.rewritables.link(tabbar, pageElement, {}, function (pageElement) {
                       _this4.pageElement = pageElement;
                       _this4.pageElement.style.display = 'none';
                       tabbar._contentElement.appendChild(_this4.pageElement);
                     });
                   });
                 }
               });
             });
           }

           _this4.addEventListener('click', _this4._boundOnClick, false);
         });
       }
     }, {
       key: '_findTabbarElement',
       value: function _findTabbarElement() {
         if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode;
         }

         if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode.parentNode;
         }

         return null;
       }
     }, {
       key: '_findTabIndex',
       value: function _findTabIndex() {
         var elements = this.parentNode.children;
         for (var i = 0; i < elements.length; i++) {
           if (this === elements[i]) {
             return i;
           }
         }
       }
     }, {
       key: '_ensureElementPosition',
       value: function _ensureElementPosition() {
         if (!this._findTabbarElement()) {
           throw new Error('This ons-tab element is must be child of ons-tabbar element.');
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this5 = this;

         switch (name) {
           case 'modifier':
             contentReady(this, function () {
               return ModifierUtil.onModifierChanged(last, current, _this5, scheme$20);
             });
             break;
           case 'ripple':
             contentReady(this, function () {
               return _this5._updateRipple();
             });
             break;
           case 'icon':
           case 'label':
             contentReady(this, function () {
               return _this5._updateDefaultTemplate();
             });
             break;
         }
       }
     }, {
       key: 'pageElement',
       set: function set(el) {
         this._pageElement = el;
       },
       get: function get() {
         if (typeof this._pageElement !== 'undefined') {
           return this._pageElement;
         }

         var tabbar = this._findTabbarElement();
         var index = this._findTabIndex();

         return tabbar._contentElement.children[index];
       }
     }]);
     return TabElement;
   }(BaseElement);

   window.OnsTabElement = document.registerElement('ons-tab', {
     prototype: TabElement.prototype
   });

   document.registerElement('ons-tabbar-item', {
     prototype: Object.create(TabElement.prototype)
   });

   var scheme$22 = { '': 'toolbar-button--*' };

   /**
    * @element ons-toolbar-button
    * @category toolbar
    * @modifier material
    *   [en]Material Design toolbar button.[/en]
    *   [ja][/ja]
    * @modifier outline
    *   [en]A button with an outline.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
    *   [ja]ons-toolbarons-bottom-toolbar[/ja]
    * @codepen aHmGL
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
    *   [ja]ons-back-button[/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-toolbar-button>
    *       Button
    *     </ons-toolbar-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   </div>
    *   <div class="right">
    *     <ons-toolbar-button>
    *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
    *     </ons-toolbar-button>
    *   </div>
    * </ons-toolbar>
    */

   var ToolbarButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarButtonElement, _BaseElement);

     function ToolbarButtonElement() {
       babelHelpers.classCallCheck(this, ToolbarButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarButtonElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('toolbar-button');

         ModifierUtil.initModifier(this, scheme$22);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
         }
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return ToolbarButtonElement;
   }(BaseElement);

   window.OnsToolbarButton = document.registerElement('ons-toolbar-button', {
     prototype: ToolbarButtonElement.prototype
   });

   var scheme$23 = {
     '': 'navigation-bar--*',
     '.navigation-bar__left': 'navigation-bar--*__left',
     '.navigation-bar__center': 'navigation-bar--*__center',
     '.navigation-bar__right': 'navigation-bar--*__right'
   };

   /**
    * @element ons-toolbar
    * @category toolbar
    * @modifier material
    *   [en]Material Design toolbar.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Transparent toolbar[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Toolbar component that can be used with navigation.
    *
    *     Left, center and right container can be specified by class names.
    *
    *     This component will automatically displays as a Material Design toolbar when running on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @guide Addingatoolbar [en]Adding a toolbar[/en][ja][/ja]
    * @seealso ons-bottom-toolbar
    *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
    *   [ja]ons-bottom-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
    *   [ja]ons-back-button[/ja]
    * @seealso ons-toolbar-button
    *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
    *   [ja]ons-toolbar-button[/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>
    *         Back
    *       </ons-back-button>
    *     </div>
    *     <div class="center">
    *       Title
    *     </div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    * </ons-page>
    */

   var ToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarElement, _BaseElement);

     function ToolbarElement() {
       babelHelpers.classCallCheck(this, ToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarElement, [{
       key: 'createdCallback',


       /**
        * @attribute inline
        * @initonly
        * @description
        *   [en]Display the toolbar as an inline element.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }
         });

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this2._tryToEnsureNodePosition();
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$23);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this3._tryToEnsureNodePosition();
         });
       }
     }, {
       key: '_tryToEnsureNodePosition',
       value: function _tryToEnsureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }
         var page = util.findParent(this, 'ons-page');

         if (page && page !== this.parentNode) {
           page._registerToolbar(this);
         }
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarLeftItemsElement',
       value: function _getToolbarLeftItemsElement() {
         return this.querySelector('.left') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarCenterItemsElement',
       value: function _getToolbarCenterItemsElement() {
         return this.querySelector('.center') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarRightItemsElement',
       value: function _getToolbarRightItemsElement() {
         return this.querySelector('.right') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarBackButtonLabelElement',
       value: function _getToolbarBackButtonLabelElement() {
         return this.querySelector('ons-back-button .back-button__label') || internal.nullElement;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('navigation-bar');
         this._ensureToolbarItemElements();
         ModifierUtil.initModifier(this, scheme$23);
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_ensureToolbarItemElements',
       value: function _ensureToolbarItemElements() {
         for (var i = this.childNodes.length - 1; i >= 0; i--) {
           // case of not element
           if (this.childNodes[i].nodeType != 1) {
             this.removeChild(this.childNodes[i]);
           }
         }

         var center = this._ensureToolbarElement('center');
         center.classList.add('navigation-bar__title');

         if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
           var left = this._ensureToolbarElement('left');
           var right = this._ensureToolbarElement('right');

           if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
             this.appendChild(left);
             this.appendChild(center);
             this.appendChild(right);
           }
         }
       }
     }, {
       key: '_ensureToolbarElement',
       value: function _ensureToolbarElement(name) {
         var element = util.findChild(this, '.' + name) || util.create('.' + name);

         element.classList.add('navigation-bar__' + name);

         return element;
       }
     }]);
     return ToolbarElement;
   }(BaseElement);

   window.OnsToolbarElement = document.registerElement('ons-toolbar', {
     prototype: ToolbarElement.prototype
   });

   var scheme$24 = {
     '.range': 'range--*',
     '.range__left': 'range--*__left'
   };

   var templateSource$3 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

   var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

   /**
    * @element ons-range
    * @category range
    * @modifier material
    *   [en]Material Design slider[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Range input component. Used to display a draggable slider.
    *
    *     Works very similar to the `<input type="range">` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xZQomM
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @seealso ons-input
    *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
    *   [ja][/ja]
    * @example
    * <ons-range value="20"></ons-range>
    * <ons-range modifier="material" value="10"></range>
    */

   var RangeElement = function (_BaseElement) {
     babelHelpers.inherits(RangeElement, _BaseElement);

     function RangeElement() {
       babelHelpers.classCallCheck(this, RangeElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RangeElement).apply(this, arguments));
     }

     babelHelpers.createClass(RangeElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._updateBoundAttributes();
           _this2._onChange();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
           var template = templateSource$3.cloneNode(true);
           while (template.children[0]) {
             this.appendChild(template.children[0]);
           }
         }

         ModifierUtil.initModifier(this, scheme$24);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._left.style.width = 100 * this._ratio + '%';
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$24);
         } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
           contentReady(this, function () {
             _this3._updateBoundAttributes();

             if (name === 'min' || name === 'max') {
               _this3._onChange();
             }
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('input', this._onChange);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('input', this._onChange);
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this4 = this;

         INPUT_ATTRIBUTES$1.forEach(function (attr) {
           if (_this4.hasAttribute(attr)) {
             _this4._input.setAttribute(attr, _this4.getAttribute(attr));
           } else {
             _this4._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_ratio',
       get: function get() {
         // Returns the current ratio.
         var min = this._input.min === '' ? 0 : parseInt(this._input.min);
         var max = this._input.max === '' ? 100 : parseInt(this._input.max);

         return (this.value - min) / (max - min);
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_left',
       get: function get() {
         return this.querySelector('.range__left');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current value.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input.value;
       },
       set: function set(val) {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.value = val;
           _this5._onChange();
         });
       }
     }]);
     return RangeElement;
   }(BaseElement);

   window.OnsRangeElement = document.registerElement('ons-range', {
     prototype: RangeElement.prototype
   });

   // fastclick
   window.addEventListener('load', function () {
     ons$1.fastClick = FastClick.attach(document.body);
   }, false);

   // ons._defaultDeviceBackButtonHandler
   window.addEventListener('DOMContentLoaded', function () {
     ons$1._deviceBackButtonDispatcher.enable();
     ons$1._defaultDeviceBackButtonHandler = ons$1._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
       navigator.app.exitApp();
     });
     document.body._gestureDetector = new ons$1.GestureDetector(document.body);
   }, false);

   // setup loading placeholder
   ons$1.ready(function () {
     ons$1._setupLoadingPlaceHolders();
   });

   // viewport.js
   new Viewport().setup();

   return ons$1;

}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUVsZW1lbnRzLmpzIiwiQ3VzdG9tRXZlbnQuanMiLCJNdXRhdGlvbk9ic2VydmVyLmpzIiwiYW5pbWl0LmpzIiwiY2hpbGROb2RlUmVtb3ZlLmpzIiwiY2xhc3NMaXN0LmpzIiwiZmFzdGNsaWNrLXBhdGNoZWQuanMiLCJtaWNyb2V2ZW50LmpzIiwicHJvbWlzZS03LjAuNC5taW4uanMiLCJzZXRJbW1lZGlhdGUuanMiLCJ2aWV3cG9ydC5qcyIsIndpbnN0b3JlLWpzY29tcGF0LmpzIiwib25zL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlci5qcyIsIm9ucy91dGlsLmpzIiwib25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCJvbnMvcGxhdGZvcm0uanMiLCJvbnMvbm90aWZpY2F0aW9uLmpzIiwib25zL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24uanMiLCJvbnMvaW50ZXJuYWwvaW50ZXJuYWwuanMiLCJvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeS5qcyIsIm9ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsLmpzIiwib25zL2ludGVybmFsL2xhenktcmVwZWF0LmpzIiwib25zL2ludGVybmFsL2luZGV4LmpzIiwib25zL29yaWVudGF0aW9uLmpzIiwib25zL3NvZnR3YXJlLWtleWJvYXJkLmpzIiwib25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyLmpzIiwib25zL2F1dG9zdHlsZS5qcyIsIm9ucy9kb29ybG9jay5qcyIsIm9ucy9jb250ZW50LXJlYWR5LmpzIiwib25zL29ucy5qcyIsIm9ucy9iYXNlLWVsZW1lbnQuanMiLCJlbGVtZW50cy9vbnMtdGVtcGxhdGUuanMiLCJlbGVtZW50cy9vbnMtaWYuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtY2Fyb3VzZWwtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC5qcyIsImVsZW1lbnRzL29ucy1jb2wuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1mYWIuanMiLCJlbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvci5qcyIsImVsZW1lbnRzL29ucy1pY29uLmpzIiwiZWxlbWVudHMvb25zLWxhenktcmVwZWF0LmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyLmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1saXN0LmpzIiwiZWxlbWVudHMvb25zLWlucHV0LmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1saWZ0LWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3MtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL25vbmUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXBhZ2UuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1wb3BvdmVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXByb2dyZXNzLWJhci5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhci5qcyIsImVsZW1lbnRzL29ucy1wdWxsLWhvb2suanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2FuaW1hdG9yLWNzcy5qcyIsImVsZW1lbnRzL29ucy1yaXBwbGUvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtcm93LmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1zcGVlZC1kaWFsLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzay5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlLmpzIiwiZWxlbWVudHMvb25zLXN3aXRjaC5qcyIsImVsZW1lbnRzL29ucy10YWJiYXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtdGFiYmFyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXRhYi5qcyIsImVsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy10b29sYmFyLmpzIiwiZWxlbWVudHMvb25zLXJhbmdlLmpzIiwic2V0dXAuanMiXSwibmFtZXMiOlsiYW5pbWF0aW9uT3B0aW9uc1BhcnNlIiwiRXZlbnQiLCJ1dGlsIiwib25zUGxhdGZvcm0iLCJvbnMiLCJQYWdlQXR0cmlidXRlRXhwcmVzc2lvbiIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZXIiLCJzY2hlbWUiLCJfYW5pbWF0b3JEaWN0IiwiRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJ0ZW1wbGF0ZVNvdXJjZSIsInRlbXBsYXRlIiwiQW5pbWF0b3IiLCJyZXdyaXRhYmxlcyIsIk9uc1NwbGl0dGVyRWxlbWVudCIsImdlbmVyYXRlSWQiLCJJTlBVVF9BVFRSSUJVVEVTIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEVBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LElBQTlELEVBQW9FLFlBQU07QUFDOUcsR0FBQSxjQUFVLEdBQVYsQ0FBYyxPQUFkO0FBQ0QsR0FBQSxHQUZxQyxDQUF0QztBQUdBLEdBQUEsV0FBUyxJQUFULENBQWMsZ0JBQWQsR0FBaUMsSUFBSUEsTUFBSSxlQUFSLENBQXdCLFNBQVMsSUFBakMsQ0FBakM7QUFDRCxHQUFBLENBTkQsRUFNRyxLQU5IOzs7QUFTQUEsU0FBSSxLQUFKLENBQVUsWUFBVztBQUNuQixHQUFBLFFBQUkseUJBQUo7QUFDRCxHQUFBLENBRkQ7OztBQUtBLEdBQUEsSUFBSSxRQUFKLEdBQWUsS0FBZiIsImZpbGUiOiJvbnNlbnVpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuM1xuaWYgKHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xuICAgIHZhciBXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIl9fc3RcIiArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKSArIChjb3VudGVyKysgKyBcIl9fXCIpO1xuICAgIH07XG4gICAgV2Vha01hcC5wcm90b3R5cGUgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5KSBlbnRyeVsxXSA9IHZhbHVlOyBlbHNlIGRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5uYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IFsga2V5LCB2YWx1ZSBdLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHJldHVybiAoZW50cnkgPSBrZXlbdGhpcy5uYW1lXSkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSB8fCBlbnRyeVswXSAhPT0ga2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVudHJ5WzBdID0gZW50cnlbMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBlbnRyeVswXSA9PT0ga2V5O1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LldlYWtNYXAgPSBXZWFrTWFwO1xuICB9KSgpO1xufVxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIHZhciByZWdpc3RyYXRpb25zVGFibGUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgc2V0SW1tZWRpYXRlO1xuICBpZiAoL1RyaWRlbnR8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHNldFRpbWVvdXQ7XG4gIH0gZWxzZSBpZiAod2luZG93LnNldEltbWVkaWF0ZSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5kYXRhID09PSBzZW50aW5lbCkge1xuICAgICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcbiAgICAgICAgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgZnVuYygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICBzZXRJbW1lZGlhdGVRdWV1ZS5wdXNoKGZ1bmMpO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCBcIipcIik7XG4gICAgfTtcbiAgfVxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKG9ic2VydmVyKSB7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdyYXBJZk5lZWRlZChub2RlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCAmJiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwud3JhcElmTmVlZGVkKG5vZGUpIHx8IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFja3MoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gc2NoZWR1bGVkT2JzZXJ2ZXJzO1xuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICAgIG9ic2VydmVycy5zb3J0KGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgcmV0dXJuIG8xLnVpZF8gLSBvMi51aWRfO1xuICAgIH0pO1xuICAgIHZhciBhbnlOb25FbXB0eSA9IGZhbHNlO1xuICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKTtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2tfKHF1ZXVlLCBvYnNlcnZlcik7XG4gICAgICAgIGFueU5vbkVtcHR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYW55Tm9uRW1wdHkpIGRpc3BhdGNoQ2FsbGJhY2tzKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZXR1cm47XG4gICAgICByZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IG9ic2VydmVyKSByZWdpc3RyYXRpb24ucmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIG5vZGUgPSB0YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2pdO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldCAmJiAhb3B0aW9ucy5zdWJ0cmVlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gY2FsbGJhY2sob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHJlY29yZCkgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgdWlkQ291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIEpzTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5ub2Rlc18gPSBbXTtcbiAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgdGhpcy51aWRfID0gKyt1aWRDb3VudGVyO1xuICB9XG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgb2JzZXJ2ZTogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQgPSB3cmFwSWZOZWVkZWQodGFyZ2V0KTtcbiAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhIHx8IG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KHRhcmdldCk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQodGFyZ2V0LCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXS5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbih0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICByZWdpc3RyYXRpb25zLnB1c2gocmVnaXN0cmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub2Rlc18ucHVzaCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmVnaXN0cmF0aW9uLmFkZExpc3RlbmVycygpO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgfSxcbiAgICB0YWtlUmVjb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weU9mUmVjb3JkcyA9IHRoaXMucmVjb3Jkc187XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgICByZXR1cm4gY29weU9mUmVjb3JkcztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5hZGRlZE5vZGVzID0gW107XG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgdGhpcy5uZXh0U2libGluZyA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG51bGw7XG4gICAgdGhpcy5vbGRWYWx1ZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29weU11dGF0aW9uUmVjb3JkKG9yaWdpbmFsKSB7XG4gICAgdmFyIHJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZChvcmlnaW5hbC50eXBlLCBvcmlnaW5hbC50YXJnZXQpO1xuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSBvcmlnaW5hbC5yZW1vdmVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gb3JpZ2luYWwucHJldmlvdXNTaWJsaW5nO1xuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZTtcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgZnVuY3Rpb24gZ2V0UmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHJldHVybiBjdXJyZW50UmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKSB7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUgPSBjb3B5TXV0YXRpb25SZWNvcmQoY3VycmVudFJlY29yZCk7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclJlY29yZHMoKSB7XG4gICAgY3VycmVudFJlY29yZCA9IHJlY29yZFdpdGhPbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQgPT09IHJlY29yZFdpdGhPbGRWYWx1ZSB8fCByZWNvcmQgPT09IGN1cnJlbnRSZWNvcmQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIG5ld1JlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSBuZXdSZWNvcmQpIHJldHVybiBsYXN0UmVjb3JkO1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBSZWdpc3RyYXRpb24ob2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICB9XG4gIFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZW5xdWV1ZTogZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICB2YXIgcmVjb3JkcyA9IHRoaXMub2JzZXJ2ZXIucmVjb3Jkc187XG4gICAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsYXN0UmVjb3JkID0gcmVjb3Jkc1tsZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlY29yZFRvUmVwbGFjZUxhc3QgPSBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgcmVjb3JkKTtcbiAgICAgICAgaWYgKHJlY29yZFRvUmVwbGFjZUxhc3QpIHtcbiAgICAgICAgICByZWNvcmRzW2xlbmd0aCAtIDFdID0gcmVjb3JkVG9SZXBsYWNlTGFzdDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2sodGhpcy5vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICByZWNvcmRzW2xlbmd0aF0gPSByZWNvcmQ7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRhcmdldCkgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQobm9kZSwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICAgICAgdHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgY2FzZSBcIkRPTUF0dHJNb2RpZmllZFwiOlxuICAgICAgICB2YXIgbmFtZSA9IGUuYXR0ck5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlLnJlbGF0ZWROb2RlLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gbmV3IGdldFJlY29yZChcImF0dHJpYnV0ZXNcIiwgdGFyZ2V0KTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLmF0dHJDaGFuZ2UgPT09IE11dGF0aW9uRXZlbnQuQURESVRJT04gPyBudWxsIDogZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lKSA9PT0gLTEgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lc3BhY2UpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiOlxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGFyYWN0ZXJEYXRhXCIsIHRhcmdldCk7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01Ob2RlUmVtb3ZlZFwiOlxuICAgICAgICB0aGlzLmFkZFRyYW5zaWVudE9ic2VydmVyKGUudGFyZ2V0KTtcblxuICAgICAgIGNhc2UgXCJET01Ob2RlSW5zZXJ0ZWRcIjpcbiAgICAgICAgdmFyIGNoYW5nZWROb2RlID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXM7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiRE9NTm9kZUluc2VydGVkXCIpIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IGNoYW5nZWROb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY2hhbmdlZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGlsZExpc3RcIiwgZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIHJlY29yZC5hZGRlZE5vZGVzID0gYWRkZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgcmVjb3JkLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZChlLnJlbGF0ZWROb2RlLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCkgcmV0dXJuO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2xlYXJSZWNvcmRzKCk7XG4gICAgfVxuICB9O1xuICBnbG9iYWwuSnNNdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICBpZiAoIWdsb2JhbC5NdXRhdGlvbk9ic2VydmVyKSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbn0pKHRoaXMpO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3cuQ3VzdG9tRWxlbWVudHMgfHwge1xuICBmbGFnczoge31cbn07XG5cbihmdW5jdGlvbihzY29wZSkge1xuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcbiAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgdmFyIGFkZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIG1vZHVsZXMucHVzaChtb2R1bGUpO1xuICB9O1xuICB2YXIgaW5pdGlhbGl6ZU1vZHVsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICBtb2R1bGUoc2NvcGUpO1xuICAgIH0pO1xuICB9O1xuICBzY29wZS5hZGRNb2R1bGUgPSBhZGRNb2R1bGU7XG4gIHNjb3BlLmluaXRpYWxpemVNb2R1bGVzID0gaW5pdGlhbGl6ZU1vZHVsZXM7XG4gIHNjb3BlLmhhc05hdGl2ZSA9IEJvb2xlYW4oZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KTtcbiAgc2NvcGUudXNlTmF0aXZlID0gIWZsYWdzLnJlZ2lzdGVyICYmIHNjb3BlLmhhc05hdGl2ZSAmJiAhd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmICghd2luZG93LkhUTUxJbXBvcnRzIHx8IEhUTUxJbXBvcnRzLnVzZU5hdGl2ZSk7XG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBJTVBPUlRfTElOS19UWVBFID0gd2luZG93LkhUTUxJbXBvcnRzID8gSFRNTEltcG9ydHMuSU1QT1JUX0xJTktfVFlQRSA6IFwibm9uZVwiO1xuICBmdW5jdGlvbiBmb3JTdWJ0cmVlKG5vZGUsIGNiKSB7XG4gICAgZmluZEFsbEVsZW1lbnRzKG5vZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChjYihlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvclJvb3RzKGUsIGNiKTtcbiAgICB9KTtcbiAgICBmb3JSb290cyhub2RlLCBjYik7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEFsbEVsZW1lbnRzKG5vZGUsIGZpbmQsIGRhdGEpIHtcbiAgICB2YXIgZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgaWYgKCFlKSB7XG4gICAgICBlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGUgJiYgZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZSA9IGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChlKSB7XG4gICAgICBpZiAoZmluZChlLCBkYXRhKSAhPT0gdHJ1ZSkge1xuICAgICAgICBmaW5kQWxsRWxlbWVudHMoZSwgZmluZCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBlID0gZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGZvclJvb3RzKG5vZGUsIGNiKSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIGZvclN1YnRyZWUocm9vdCwgY2IpO1xuICAgICAgcm9vdCA9IHJvb3Qub2xkZXJTaGFkb3dSb290O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmb3JEb2N1bWVudFRyZWUoZG9jLCBjYikge1xuICAgIF9mb3JEb2N1bWVudFRyZWUoZG9jLCBjYiwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIF9mb3JEb2N1bWVudFRyZWUoZG9jLCBjYiwgcHJvY2Vzc2luZ0RvY3VtZW50cykge1xuICAgIGRvYyA9IHdyYXAoZG9jKTtcbiAgICBpZiAocHJvY2Vzc2luZ0RvY3VtZW50cy5pbmRleE9mKGRvYykgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9jZXNzaW5nRG9jdW1lbnRzLnB1c2goZG9jKTtcbiAgICB2YXIgaW1wb3J0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9XCIgKyBJTVBPUlRfTElOS19UWVBFICsgXCJdXCIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW1wb3J0cy5sZW5ndGgsIG47IGkgPCBsICYmIChuID0gaW1wb3J0c1tpXSk7IGkrKykge1xuICAgICAgaWYgKG4uaW1wb3J0KSB7XG4gICAgICAgIF9mb3JEb2N1bWVudFRyZWUobi5pbXBvcnQsIGNiLCBwcm9jZXNzaW5nRG9jdW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2IoZG9jKTtcbiAgfVxuICBzY29wZS5mb3JEb2N1bWVudFRyZWUgPSBmb3JEb2N1bWVudFRyZWU7XG4gIHNjb3BlLmZvclN1YnRyZWUgPSBmb3JTdWJ0cmVlO1xufSk7XG5cbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIGZsYWdzID0gc2NvcGUuZmxhZ3M7XG4gIHZhciBmb3JTdWJ0cmVlID0gc2NvcGUuZm9yU3VidHJlZTtcbiAgdmFyIGZvckRvY3VtZW50VHJlZSA9IHNjb3BlLmZvckRvY3VtZW50VHJlZTtcbiAgZnVuY3Rpb24gYWRkZWROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gYWRkZWQobm9kZSkgfHwgYWRkZWRTdWJ0cmVlKG5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZGVkKG5vZGUpIHtcbiAgICBpZiAoc2NvcGUudXBncmFkZShub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGF0dGFjaGVkKG5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZGVkU3VidHJlZShub2RlKSB7XG4gICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoYWRkZWQoZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoZWROb2RlKG5vZGUpIHtcbiAgICBhdHRhY2hlZChub2RlKTtcbiAgICBpZiAoaW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGF0dGFjaGVkKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHZhciBoYXNQb2x5ZmlsbE11dGF0aW9ucyA9ICF3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciA9PT0gd2luZG93LkpzTXV0YXRpb25PYnNlcnZlcjtcbiAgc2NvcGUuaGFzUG9seWZpbGxNdXRhdGlvbnMgPSBoYXNQb2x5ZmlsbE11dGF0aW9ucztcbiAgdmFyIGlzUGVuZGluZ011dGF0aW9ucyA9IGZhbHNlO1xuICB2YXIgcGVuZGluZ011dGF0aW9ucyA9IFtdO1xuICBmdW5jdGlvbiBkZWZlck11dGF0aW9uKGZuKSB7XG4gICAgcGVuZGluZ011dGF0aW9ucy5wdXNoKGZuKTtcbiAgICBpZiAoIWlzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgaXNQZW5kaW5nTXV0YXRpb25zID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQodGFrZU11dGF0aW9ucyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRha2VNdXRhdGlvbnMoKSB7XG4gICAgaXNQZW5kaW5nTXV0YXRpb25zID0gZmFsc2U7XG4gICAgdmFyICRwID0gcGVuZGluZ011dGF0aW9ucztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9ICRwLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSAkcFtpXSk7IGkrKykge1xuICAgICAgcCgpO1xuICAgIH1cbiAgICBwZW5kaW5nTXV0YXRpb25zID0gW107XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChoYXNQb2x5ZmlsbE11dGF0aW9ucykge1xuICAgICAgZGVmZXJNdXRhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgX2F0dGFjaGVkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hdHRhY2hlZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2F0dGFjaGVkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spKSB7XG4gICAgICBpZiAoIWVsZW1lbnQuX19hdHRhY2hlZCAmJiBpbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19hdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZXRhY2hlZE5vZGUobm9kZSkge1xuICAgIGRldGFjaGVkKG5vZGUpO1xuICAgIGZvclN1YnRyZWUobm9kZSwgZnVuY3Rpb24oZSkge1xuICAgICAgZGV0YWNoZWQoZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGV0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChoYXNQb2x5ZmlsbE11dGF0aW9ucykge1xuICAgICAgZGVmZXJNdXRhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgX2RldGFjaGVkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9kZXRhY2hlZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2RldGFjaGVkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spKSB7XG4gICAgICBpZiAoZWxlbWVudC5fX2F0dGFjaGVkICYmICFpbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZWxlbWVudC5kZXRhY2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgZWxlbWVudC5kZXRhY2hlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5Eb2N1bWVudChlbGVtZW50KSB7XG4gICAgdmFyIHAgPSBlbGVtZW50O1xuICAgIHZhciBkb2MgPSB3cmFwKGRvY3VtZW50KTtcbiAgICB3aGlsZSAocCkge1xuICAgICAgaWYgKHAgPT0gZG9jKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcCA9IHAucGFyZW50Tm9kZSB8fCBwLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgcC5ob3N0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3YXRjaFNoYWRvdyhub2RlKSB7XG4gICAgaWYgKG5vZGUuc2hhZG93Um9vdCAmJiAhbm9kZS5zaGFkb3dSb290Ll9fd2F0Y2hlZCkge1xuICAgICAgZmxhZ3MuZG9tICYmIGNvbnNvbGUubG9nKFwid2F0Y2hpbmcgc2hhZG93LXJvb3QgZm9yOiBcIiwgbm9kZS5sb2NhbE5hbWUpO1xuICAgICAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gICAgICB3aGlsZSAocm9vdCkge1xuICAgICAgICBvYnNlcnZlKHJvb3QpO1xuICAgICAgICByb290ID0gcm9vdC5vbGRlclNoYWRvd1Jvb3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZXIobXV0YXRpb25zKSB7XG4gICAgaWYgKGZsYWdzLmRvbSkge1xuICAgICAgdmFyIG14ID0gbXV0YXRpb25zWzBdO1xuICAgICAgaWYgKG14ICYmIG14LnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgJiYgbXguYWRkZWROb2Rlcykge1xuICAgICAgICBpZiAobXguYWRkZWROb2Rlcykge1xuICAgICAgICAgIHZhciBkID0gbXguYWRkZWROb2Rlc1swXTtcbiAgICAgICAgICB3aGlsZSAoZCAmJiBkICE9PSBkb2N1bWVudCAmJiAhZC5ob3N0KSB7XG4gICAgICAgICAgICBkID0gZC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdSA9IGQgJiYgKGQuVVJMIHx8IGQuX1VSTCB8fCBkLmhvc3QgJiYgZC5ob3N0LmxvY2FsTmFtZSkgfHwgXCJcIjtcbiAgICAgICAgICB1ID0gdS5zcGxpdChcIi8/XCIpLnNoaWZ0KCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmdyb3VwKFwibXV0YXRpb25zICglZCkgWyVzXVwiLCBtdXRhdGlvbnMubGVuZ3RoLCB1IHx8IFwiXCIpO1xuICAgIH1cbiAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihteCkge1xuICAgICAgaWYgKG14LnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgZm9yRWFjaChteC5hZGRlZE5vZGVzLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgaWYgKCFuLmxvY2FsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZE5vZGUobik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3JFYWNoKG14LnJlbW92ZWROb2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICAgIGlmICghbi5sb2NhbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWNoZWROb2RlKG4pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmbGFncy5kb20gJiYgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VSZWNvcmRzKG5vZGUpIHtcbiAgICBub2RlID0gd3JhcChub2RlKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSB3cmFwKGRvY3VtZW50KTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmVyID0gbm9kZS5fX29ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgaGFuZGxlcihvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgIHRha2VNdXRhdGlvbnMoKTtcbiAgICB9XG4gIH1cbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuICBmdW5jdGlvbiBvYnNlcnZlKGluUm9vdCkge1xuICAgIGlmIChpblJvb3QuX19vYnNlcnZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVyKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGluUm9vdCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIGluUm9vdC5fX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXBncmFkZURvY3VtZW50KGRvYykge1xuICAgIGRvYyA9IHdyYXAoZG9jKTtcbiAgICBmbGFncy5kb20gJiYgY29uc29sZS5ncm91cChcInVwZ3JhZGVEb2N1bWVudDogXCIsIGRvYy5iYXNlVVJJLnNwbGl0KFwiL1wiKS5wb3AoKSk7XG4gICAgYWRkZWROb2RlKGRvYyk7XG4gICAgb2JzZXJ2ZShkb2MpO1xuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBncmFkZURvY3VtZW50VHJlZShkb2MpIHtcbiAgICBmb3JEb2N1bWVudFRyZWUoZG9jLCB1cGdyYWRlRG9jdW1lbnQpO1xuICB9XG4gIHZhciBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QgPSBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290O1xuICBpZiAob3JpZ2luYWxDcmVhdGVTaGFkb3dSb290KSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvb3QgPSBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QuY2FsbCh0aGlzKTtcbiAgICAgIEN1c3RvbUVsZW1lbnRzLndhdGNoU2hhZG93KHRoaXMpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgfVxuICBzY29wZS53YXRjaFNoYWRvdyA9IHdhdGNoU2hhZG93O1xuICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gdXBncmFkZURvY3VtZW50VHJlZTtcbiAgc2NvcGUudXBncmFkZVN1YnRyZWUgPSBhZGRlZFN1YnRyZWU7XG4gIHNjb3BlLnVwZ3JhZGVBbGwgPSBhZGRlZE5vZGU7XG4gIHNjb3BlLmF0dGFjaGVkTm9kZSA9IGF0dGFjaGVkTm9kZTtcbiAgc2NvcGUudGFrZVJlY29yZHMgPSB0YWtlUmVjb3Jkcztcbn0pO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuICBmdW5jdGlvbiB1cGdyYWRlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuX191cGdyYWRlZF9fICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaXMgPSBub2RlLmdldEF0dHJpYnV0ZShcImlzXCIpO1xuICAgICAgdmFyIGRlZmluaXRpb24gPSBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihpcyB8fCBub2RlLmxvY2FsTmFtZSk7XG4gICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoaXMgJiYgZGVmaW5pdGlvbi50YWcgPT0gbm9kZS5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKG5vZGUsIGRlZmluaXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpcyAmJiAhZGVmaW5pdGlvbi5leHRlbmRzKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZ3JhZGVXaXRoRGVmaW5pdGlvbihub2RlLCBkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGdyYWRlV2l0aERlZmluaXRpb24oZWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGZsYWdzLnVwZ3JhZGUgJiYgY29uc29sZS5ncm91cChcInVwZ3JhZGU6XCIsIGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICBpZiAoZGVmaW5pdGlvbi5pcykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpc1wiLCBkZWZpbml0aW9uLmlzKTtcbiAgICB9XG4gICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIGVsZW1lbnQuX191cGdyYWRlZF9fID0gdHJ1ZTtcbiAgICBjcmVhdGVkKGVsZW1lbnQpO1xuICAgIHNjb3BlLmF0dGFjaGVkTm9kZShlbGVtZW50KTtcbiAgICBzY29wZS51cGdyYWRlU3VidHJlZShlbGVtZW50KTtcbiAgICBmbGFncy51cGdyYWRlICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBmdW5jdGlvbiBpbXBsZW1lbnRQcm90b3R5cGUoZWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGlmIChPYmplY3QuX19wcm90b19fKSB7XG4gICAgICBlbGVtZW50Ll9fcHJvdG9fXyA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21NaXhpbihlbGVtZW50LCBkZWZpbml0aW9uLnByb3RvdHlwZSwgZGVmaW5pdGlvbi5uYXRpdmUpO1xuICAgICAgZWxlbWVudC5fX3Byb3RvX18gPSBkZWZpbml0aW9uLnByb3RvdHlwZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3VzdG9tTWl4aW4oaW5UYXJnZXQsIGluU3JjLCBpbk5hdGl2ZSkge1xuICAgIHZhciB1c2VkID0ge307XG4gICAgdmFyIHAgPSBpblNyYztcbiAgICB3aGlsZSAocCAhPT0gaW5OYXRpdmUgJiYgcCAhPT0gSFRNTEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHApO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGs7IGsgPSBrZXlzW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKCF1c2VkW2tdKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluVGFyZ2V0LCBrLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIGspKTtcbiAgICAgICAgICB1c2VkW2tdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlZChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuY3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICBlbGVtZW50LmNyZWF0ZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBzY29wZS51cGdyYWRlID0gdXBncmFkZTtcbiAgc2NvcGUudXBncmFkZVdpdGhEZWZpbml0aW9uID0gdXBncmFkZVdpdGhEZWZpbml0aW9uO1xuICBzY29wZS5pbXBsZW1lbnRQcm90b3R5cGUgPSBpbXBsZW1lbnRQcm90b3R5cGU7XG59KTtcblxud2luZG93LkN1c3RvbUVsZW1lbnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgaXNJRTExT3JPbGRlciA9IHNjb3BlLmlzSUUxMU9yT2xkZXI7XG4gIHZhciB1cGdyYWRlRG9jdW1lbnRUcmVlID0gc2NvcGUudXBncmFkZURvY3VtZW50VHJlZTtcbiAgdmFyIHVwZ3JhZGVBbGwgPSBzY29wZS51cGdyYWRlQWxsO1xuICB2YXIgdXBncmFkZVdpdGhEZWZpbml0aW9uID0gc2NvcGUudXBncmFkZVdpdGhEZWZpbml0aW9uO1xuICB2YXIgaW1wbGVtZW50UHJvdG90eXBlID0gc2NvcGUuaW1wbGVtZW50UHJvdG90eXBlO1xuICB2YXIgdXNlTmF0aXZlID0gc2NvcGUudXNlTmF0aXZlO1xuICBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50OiBmaXJzdCBhcmd1bWVudCBgbmFtZWAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoXCItXCIpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50OiBmaXJzdCBhcmd1bWVudCAoJ25hbWUnKSBtdXN0IGNvbnRhaW4gYSBkYXNoICgnLScpLiBBcmd1bWVudCBwcm92aWRlZCB3YXMgJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInLlwiKTtcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdyZWdpc3RlckVsZW1lbnQnIG9uICdEb2N1bWVudCc6IFJlZ2lzdHJhdGlvbiBmYWlsZWQgZm9yIHR5cGUgJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInLiBUaGUgdHlwZSBuYW1lIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZURlZmluaXRpb25FcnJvcjogYSB0eXBlIHdpdGggbmFtZSAnXCIgKyBTdHJpbmcobmFtZSkgKyBcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlZmluaXRpb24ucHJvdG90eXBlKSB7XG4gICAgICBkZWZpbml0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbi5fX25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgZGVmaW5pdGlvbi5saWZlY3ljbGUgPSBkZWZpbml0aW9uLmxpZmVjeWNsZSB8fCB7fTtcbiAgICBkZWZpbml0aW9uLmFuY2VzdHJ5ID0gYW5jZXN0cnkoZGVmaW5pdGlvbi5leHRlbmRzKTtcbiAgICByZXNvbHZlVGFnTmFtZShkZWZpbml0aW9uKTtcbiAgICByZXNvbHZlUHJvdG90eXBlQ2hhaW4oZGVmaW5pdGlvbik7XG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVBcGkoZGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuICAgIHJlZ2lzdGVyRGVmaW5pdGlvbihkZWZpbml0aW9uLl9fbmFtZSwgZGVmaW5pdGlvbik7XG4gICAgZGVmaW5pdGlvbi5jdG9yID0gZ2VuZXJhdGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uKTtcbiAgICBkZWZpbml0aW9uLmN0b3IucHJvdG90eXBlID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XG4gICAgZGVmaW5pdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkZWZpbml0aW9uLmN0b3I7XG4gICAgaWYgKHNjb3BlLnJlYWR5KSB7XG4gICAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKGRvY3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb24uY3RvcjtcbiAgfVxuICBmdW5jdGlvbiBvdmVycmlkZUF0dHJpYnV0ZUFwaShwcm90b3R5cGUpIHtcbiAgICBpZiAocHJvdG90eXBlLnNldEF0dHJpYnV0ZS5fcG9seWZpbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2V0QXR0cmlidXRlID0gcHJvdG90eXBlLnNldEF0dHJpYnV0ZTtcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIGNoYW5nZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBzZXRBdHRyaWJ1dGUpO1xuICAgIH07XG4gICAgdmFyIHJlbW92ZUF0dHJpYnV0ZSA9IHByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGU7XG4gICAgcHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNoYW5nZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHJlbW92ZUF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlLl9wb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wZXJhdGlvbikge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgb3BlcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNSZXNlcnZlZFRhZyhuYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZFRhZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuYW1lID09PSByZXNlcnZlZFRhZ0xpc3RbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXNlcnZlZFRhZ0xpc3QgPSBbIFwiYW5ub3RhdGlvbi14bWxcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiZm9udC1mYWNlXCIsIFwiZm9udC1mYWNlLXNyY1wiLCBcImZvbnQtZmFjZS11cmlcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJtaXNzaW5nLWdseXBoXCIgXTtcbiAgZnVuY3Rpb24gYW5jZXN0cnkoZXh0bmRzKSB7XG4gICAgdmFyIGV4dGVuZGVlID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24oZXh0bmRzKTtcbiAgICBpZiAoZXh0ZW5kZWUpIHtcbiAgICAgIHJldHVybiBhbmNlc3RyeShleHRlbmRlZS5leHRlbmRzKS5jb25jYXQoWyBleHRlbmRlZSBdKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pIHtcbiAgICB2YXIgYmFzZVRhZyA9IGRlZmluaXRpb24uZXh0ZW5kcztcbiAgICBmb3IgKHZhciBpID0gMCwgYTsgYSA9IGRlZmluaXRpb24uYW5jZXN0cnlbaV07IGkrKykge1xuICAgICAgYmFzZVRhZyA9IGEuaXMgJiYgYS50YWc7XG4gICAgfVxuICAgIGRlZmluaXRpb24udGFnID0gYmFzZVRhZyB8fCBkZWZpbml0aW9uLl9fbmFtZTtcbiAgICBpZiAoYmFzZVRhZykge1xuICAgICAgZGVmaW5pdGlvbi5pcyA9IGRlZmluaXRpb24uX19uYW1lO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlUHJvdG90eXBlQ2hhaW4oZGVmaW5pdGlvbikge1xuICAgIGlmICghT2JqZWN0Ll9fcHJvdG9fXykge1xuICAgICAgdmFyIG5hdGl2ZVByb3RvdHlwZSA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHZhciBpbnN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWZpbml0aW9uLnRhZyk7XG4gICAgICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUHJvdG90eXBlID09PSBkZWZpbml0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgIG5hdGl2ZVByb3RvdHlwZSA9IGV4cGVjdGVkUHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBkZWZpbml0aW9uLnByb3RvdHlwZSwgYW5jZXN0b3I7XG4gICAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8gIT09IG5hdGl2ZVByb3RvdHlwZSkge1xuICAgICAgICBhbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIHByb3RvLl9fcHJvdG9fXyA9IGFuY2VzdG9yO1xuICAgICAgICBwcm90byA9IGFuY2VzdG9yO1xuICAgICAgfVxuICAgICAgZGVmaW5pdGlvbi5uYXRpdmUgPSBuYXRpdmVQcm90b3R5cGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKGRvbUNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbi50YWcpLCBkZWZpbml0aW9uKTtcbiAgfVxuICB2YXIgcmVnaXN0cnkgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnlbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJEZWZpbml0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICByZWdpc3RyeVtuYW1lXSA9IGRlZmluaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGluc3RhbnRpYXRlKGRlZmluaXRpb24pO1xuICAgIH07XG4gIH1cbiAgdmFyIEhUTUxfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgdHlwZUV4dGVuc2lvbikge1xuICAgIGlmIChuYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9tQ3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pIHtcbiAgICBpZiAodGFnKSB7XG4gICAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVFeHRlbnNpb24pIHtcbiAgICAgIHR5cGVFeHRlbnNpb24gPSB0eXBlRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHZhciBkZWZpbml0aW9uID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24odHlwZUV4dGVuc2lvbiB8fCB0YWcpO1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICBpZiAodGFnID09IGRlZmluaXRpb24udGFnICYmIHR5cGVFeHRlbnNpb24gPT0gZGVmaW5pdGlvbi5pcykge1xuICAgICAgICByZXR1cm4gbmV3IGRlZmluaXRpb24uY3RvcigpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlRXh0ZW5zaW9uICYmICFkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jdG9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbGVtZW50O1xuICAgIGlmICh0eXBlRXh0ZW5zaW9uKSB7XG4gICAgICBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpc1wiLCB0eXBlRXh0ZW5zaW9uKTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBlbGVtZW50ID0gZG9tQ3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcuaW5kZXhPZihcIi1cIikgPj0gMCkge1xuICAgICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIEhUTUxFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdmFyIGRvbUNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmJpbmQoZG9jdW1lbnQpO1xuICB2YXIgZG9tQ3JlYXRlRWxlbWVudE5TID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TLmJpbmQoZG9jdW1lbnQpO1xuICB2YXIgaXNJbnN0YW5jZTtcbiAgaWYgKCFPYmplY3QuX19wcm90b19fICYmICF1c2VOYXRpdmUpIHtcbiAgICBpc0luc3RhbmNlID0gZnVuY3Rpb24ob2JqLCBjdG9yKSB7XG4gICAgICB2YXIgcCA9IG9iajtcbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGlmIChwID09PSBjdG9yLnByb3RvdHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLl9fcHJvdG9fXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGlzSW5zdGFuY2UgPSBmdW5jdGlvbihvYmosIGJhc2UpIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBiYXNlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd3JhcERvbU1ldGhvZFRvRm9yY2VVcGdyYWRlKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBvcmlnID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIG9ialttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG4gPSBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB1cGdyYWRlQWxsKG4pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgfVxuICB3cmFwRG9tTWV0aG9kVG9Gb3JjZVVwZ3JhZGUoTm9kZS5wcm90b3R5cGUsIFwiY2xvbmVOb2RlXCIpO1xuICB3cmFwRG9tTWV0aG9kVG9Gb3JjZVVwZ3JhZGUoZG9jdW1lbnQsIFwiaW1wb3J0Tm9kZVwiKTtcbiAgaWYgKGlzSUUxMU9yT2xkZXIpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wb3J0Tm9kZSA9IGRvY3VtZW50LmltcG9ydE5vZGU7XG4gICAgICBkb2N1bWVudC5pbXBvcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuID0gaW1wb3J0Tm9kZS5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT0gbi5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgZi5hcHBlbmRDaGlsZChuKTtcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICB9XG4gIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IHJlZ2lzdGVyO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TID0gY3JlYXRlRWxlbWVudE5TO1xuICBzY29wZS5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICBzY29wZS5pbnN0YW5jZW9mID0gaXNJbnN0YW5jZTtcbiAgc2NvcGUucmVzZXJ2ZWRUYWdMaXN0ID0gcmVzZXJ2ZWRUYWdMaXN0O1xuICBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbiA9IGdldFJlZ2lzdGVyZWREZWZpbml0aW9uO1xuICBkb2N1bWVudC5yZWdpc3RlciA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudDtcbn0pO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIHVzZU5hdGl2ZSA9IHNjb3BlLnVzZU5hdGl2ZTtcbiAgdmFyIGluaXRpYWxpemVNb2R1bGVzID0gc2NvcGUuaW5pdGlhbGl6ZU1vZHVsZXM7XG4gIHZhciBpc0lFMTFPck9sZGVyID0gL1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGlmICh1c2VOYXRpdmUpIHtcbiAgICB2YXIgbm9wID0gZnVuY3Rpb24oKSB7fTtcbiAgICBzY29wZS53YXRjaFNoYWRvdyA9IG5vcDtcbiAgICBzY29wZS51cGdyYWRlID0gbm9wO1xuICAgIHNjb3BlLnVwZ3JhZGVBbGwgPSBub3A7XG4gICAgc2NvcGUudXBncmFkZURvY3VtZW50VHJlZSA9IG5vcDtcbiAgICBzY29wZS51cGdyYWRlU3VidHJlZSA9IG5vcDtcbiAgICBzY29wZS50YWtlUmVjb3JkcyA9IG5vcDtcbiAgICBzY29wZS5pbnN0YW5jZW9mID0gZnVuY3Rpb24ob2JqLCBiYXNlKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgYmFzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxpemVNb2R1bGVzKCk7XG4gIH1cbiAgdmFyIHVwZ3JhZGVEb2N1bWVudFRyZWUgPSBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlO1xuICBpZiAoIXdpbmRvdy53cmFwKSB7XG4gICAgaWYgKHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCkge1xuICAgICAgd2luZG93LndyYXAgPSBTaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQ7XG4gICAgICB3aW5kb3cudW53cmFwID0gU2hhZG93RE9NUG9seWZpbGwudW53cmFwSWZOZWVkZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy53cmFwID0gd2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBib290c3RyYXAoKSB7XG4gICAgdXBncmFkZURvY3VtZW50VHJlZSh3cmFwKGRvY3VtZW50KSk7XG4gICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgICAgSFRNTEltcG9ydHMuX19pbXBvcnRzUGFyc2luZ0hvb2sgPSBmdW5jdGlvbihlbHQpIHtcbiAgICAgICAgdXBncmFkZURvY3VtZW50VHJlZSh3cmFwKGVsdC5pbXBvcnQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIEN1c3RvbUVsZW1lbnRzLnJlYWR5ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgQ3VzdG9tRWxlbWVudHMucmVhZHlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICAgICAgQ3VzdG9tRWxlbWVudHMuZWxhcHNlZCA9IEN1c3RvbUVsZW1lbnRzLnJlYWR5VGltZSAtIEhUTUxJbXBvcnRzLnJlYWR5VGltZTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiV2ViQ29tcG9uZW50c1JlYWR5XCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc0lFMTFPck9sZGVyICYmIHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uKGluVHlwZSwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICBlLmluaXRDdXN0b21FdmVudChpblR5cGUsIEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpLCBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICB9XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgc2NvcGUuZmxhZ3MuZWFnZXIpIHtcbiAgICBib290c3RyYXAoKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgJiYgIXdpbmRvdy5hdHRhY2hFdmVudCAmJiAoIXdpbmRvdy5IVE1MSW1wb3J0cyB8fCB3aW5kb3cuSFRNTEltcG9ydHMucmVhZHkpKSB7XG4gICAgYm9vdHN0cmFwKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvYWRFdmVudCA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiAhSFRNTEltcG9ydHMucmVhZHkgPyBcIkhUTUxJbXBvcnRzTG9hZGVkXCIgOiBcIkRPTUNvbnRlbnRMb2FkZWRcIjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihsb2FkRXZlbnQsIGJvb3RzdHJhcCk7XG4gIH1cbiAgc2NvcGUuaXNJRTExT3JPbGRlciA9IGlzSUUxMU9yT2xkZXI7XG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuIiwiaWYgKCF3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBDdXN0b21FdmVudDtcblxuICAgIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgdmFyIGV2dDtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgfSkoKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjIyXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiX19zdFwiICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArIFwiX19cIik7XG4gICAgfTtcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZW50cnlbMF0gPSBlbnRyeVsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuV2Vha01hcCA9IFdlYWtNYXA7XG4gIH0pKCk7XG59XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XG4gIH1cbn0pKHNlbGYpOyIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cblxuLyoqXG4gKiBNaW5pbWFsIGFuaW1hdGlvbiBsaWJyYXJ5IGZvciBtYW5hZ2luZyBjc3MgdHJhbnNpdGlvbiBvbiBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cbndpbmRvdy5hbmltaXQgPSAoZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBUSU1FT1VUX1JBVElPID0gMS40O1xuXG4gIHZhciB1dGlsID0ge1xuICB9O1xuXG4gIC8vIGNhcGl0YWxpemUgc3RyaW5nXG4gIHV0aWwuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG5cbiAgLyoqXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvcGVydHlcbiAgKiBAcGFyYW0ge0Zsb2F0fSBwYXJhbXMuZHVyYXRpb25cbiAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnRpbWluZ1xuICAqL1xuICB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcGFyYW1zLnByb3BlcnR5ID0gcGFyYW1zLnByb3BlcnR5IHx8ICdhbGwnO1xuICAgIHBhcmFtcy5kdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbiB8fCAwLjQ7XG4gICAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XG5cbiAgICB2YXIgcHJvcHMgPSBwYXJhbXMucHJvcGVydHkuc3BsaXQoLyArLyk7XG5cbiAgICByZXR1cm4gcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wICsgJyAnICsgcGFyYW1zLmR1cmF0aW9uICsgJ3MgJyArIHBhcmFtcy50aW1pbmc7XG4gICAgfSkuam9pbignLCAnKTtcbiAgfTtcblxuICAvKipcbiAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciBvbiBcInRyYW5zaXRpb25lbmRcIiBldmVudC5cbiAgKi9cbiAgdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cblxuICAgIHZhciBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCA9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbiAgfTtcblxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIFsndHJhbnNpdGlvbmVuZCddO1xuICAgIH1cblxuICAgIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnXTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC52ZW5kb3JQcmVmaXggPT09ICd3ZWJraXQnIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbycgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtb3onIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbXMnKSB7XG4gICAgICByZXR1cm4gW3V0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSkoKTtcblxuICB1dGlsLl9jc3NQcm9wZXJ0eURpY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICAgIHZhciBkaWN0ID0ge307XG4gICAgdmFyIGEgPSAnQScuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xuXG4gICAgdmFyIHVwcGVyID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHZhciBrZXkgPSBzdHlsZXNbaV1cbiAgICAgICAgLnJlcGxhY2UoL15bXFwtXSsvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXC1dW2Etel0vZywgdXBwZXIpXG4gICAgICAgIC5yZXBsYWNlKC9ebW96LywgJ01veicpO1xuXG4gICAgICBpZiAoYSA8PSBrZXkuY2hhckNvZGVBdCgwKSAmJiB6ID49IGtleS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdjc3NUZXh0JyAmJiBrZXkgIT09ICdwYXJlbnRUZXh0Jykge1xuICAgICAgICAgIGRpY3Rba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfSkoKTtcblxuICB1dGlsLmhhc0Nzc1Byb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcbiAgfTtcblxuICAvKipcbiAgICogVmVuZG9yIHByZWZpeCBmb3IgY3NzIHByb3BlcnR5LlxuICAgKi9cbiAgdXRpbC52ZW5kb3JQcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpLFxuICAgIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5jYWxsKHN0eWxlcylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgICApWzFdO1xuICAgIHJldHVybiBwcmU7XG4gIH0pKCk7XG5cbiAgdXRpbC5mb3JjZUxheW91dEF0T25jZSA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmF0Y2hJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZm9yY2UgbGF5b3V0XG4gICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIHV0aWwuYmF0Y2hJbW1lZGlhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICAgIHJldHVybiAndHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkodXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICAgIHJldHVybiB1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfSkoKTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB2YXIgQW5pbWl0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1pdChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gW2VsZW1lbnRdO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUXVldWUgPSBbXTtcbiAgICB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3QgPSBbXTtcbiAgfTtcblxuICBBbmltaXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uUXVldWU6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gICAgICovXG4gICAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZSB3aXRoIHBhc3NlZCBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucyBvciBvdGhlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSwge2R1cmF0aW9uOiAwLjR9KVxuICAgICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2Nzczoge2NvbG9yOiAncmVkJ30sIGR1cmF0aW9uOiAwLjJ9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8QW5pbWl0LlRyYW5zaXRpb258RnVuY3Rpb259IHRyYW5zaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgcXVldWU6IGZ1bmN0aW9uKHRyYW5zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMudHJhbnNpdGlvblF1ZXVlO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMuY3NzID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uY3NzKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIGNzczogdHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XG4gICAgICAgIHF1ZXVlLnB1c2godHJhbnNpdGlvbi5idWlsZCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXR9IHNlY29uZHNcbiAgICAgKi9cbiAgICB3YWl0OiBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgICBpZiAoc2Vjb25kcyA+IDApIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwICogc2Vjb25kcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgIHZhciBjc3MgPSB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9IGVsZW1lbnQuc3R5bGVbZWxlbWVudC5zdHlsZVtpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWluZ11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNpdGlvbl1cbiAgICAgKi9cbiAgICByZXN0b3JlU3R5bGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmICFvcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmR1cmF0aW9uXCIgaXMgcmVxdWlyZWQgd2hlbiBcIm9wdGlvbnMudHJhbnNpdGlvblwiIGlzIGVuYWJsZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZTtcblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiB8fCAob3B0aW9ucy5kdXJhdGlvbiAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IG9wdGlvbnMudHJhbnNpdGlvbiB8fCAoJ2FsbCAnICsgb3B0aW9ucy5kdXJhdGlvbiArICdzICcgKyAob3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcicpKTtcblxuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgICB2YXIgY2xlYXJUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBhZGQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlclxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPKTtcblxuICAgICAgICAgIC8vIHRyYW5zaXRpb24gYW5kIHN0eWxlIHNldHRpbmdzXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXG4gICAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgICAgaWYgKGNzc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3NzW25hbWVdID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gdHJhbnNpdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAvLyBDbGVhciB0cmFuc2l0aW9uIGFuaW1hdGlvbiBzZXR0aW5ncy5cbiAgICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnbm9uZSc7XG5cbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbmFtZSA9ICcnOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gY3NzW2tleV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBzdGFydEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RlcXVldWVUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgdHJhbnNpdGlvbiBleGlzdHMuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLl9jdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxmLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRyYW5zaXRpb24uY2FsbCh0aGlzLCBkb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBbmltaXR9IGFyZ3VtZW50c1xuICAgKi9cbiAgQW5pbWl0LnJ1bkFsbCA9IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cy4uLiAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV0ucGxheSgpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgKi9cbiAgQW5pbWl0LlRyYW5zaXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLm9wdGlvbnMudGltaW5nID0gdGhpcy5vcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJztcbiAgICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMucHJvcGVydHkgPSB0aGlzLm9wdGlvbnMucHJvcGVydHkgfHwgJ2FsbCc7XG4gIH07XG5cbiAgQW5pbWl0LlRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGJ1aWxkOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY3NzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0gY3JlYXRlQWN0dWFsQ3NzUHJvcHModGhpcy5vcHRpb25zLmNzcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXRpbC5mb3JjZUxheW91dEF0T25jZShlbGVtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdHVhbENzc1Byb3BzKGNzcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZWZpeGVkID0gdXRpbC52ZW5kb3JQcmVmaXggKyB1dGlsLmNhcGl0YWxpemUobmFtZSk7XG4gICAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkocHJlZml4ZWQpKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxuXG4gIHJldHVybiBBbmltaXQ7XG59KSgpO1xuIiwiLypcclxuICogY2hpbGROb2RlLnJlbW92ZSBtZXRob2QgcG9seWZpbGwgZm9yIElFLlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2hpbGROb2RlL3JlbW92ZVxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuXHQgIEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcblx0ICAgIFx0dGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxufSkoKTtcclxuIiwiLypcclxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXHJcbiAqIDEuMS4yMDE1MDMxMlxyXG4gKlxyXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXHJcbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cclxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcclxuICovXHJcblxyXG4vKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXHJcblxyXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xyXG5cclxuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XHJcblxyXG4vLyBGdWxsIHBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XHJcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxyXG5pZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKVxyXG4gIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XHJcblxyXG4oZnVuY3Rpb24gKHZpZXcpIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XHJcblxyXG52YXJcclxuICAgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXHJcbiAgLCBwcm90b1Byb3AgPSBcInByb3RvdHlwZVwiXHJcbiAgLCBlbGVtQ3RyUHJvdG8gPSB2aWV3LkVsZW1lbnRbcHJvdG9Qcm9wXVxyXG4gICwgb2JqQ3RyID0gT2JqZWN0XHJcbiAgLCBzdHJUcmltID0gU3RyaW5nW3Byb3RvUHJvcF0udHJpbSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcclxuICB9XHJcbiAgLCBhcnJJbmRleE9mID0gQXJyYXlbcHJvdG9Qcm9wXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICB2YXJcclxuICAgICAgICBpID0gMFxyXG4gICAgICAsIGxlbiA9IHRoaXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIC8vIFZlbmRvcnM6IHBsZWFzZSBhbGxvdyBjb250ZW50IGNvZGUgdG8gaW5zdGFudGlhdGUgRE9NRXhjZXB0aW9uc1xyXG4gICwgRE9NRXggPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xyXG4gICAgdGhpcy5uYW1lID0gdHlwZTtcclxuICAgIHRoaXMuY29kZSA9IERPTUV4Y2VwdGlvblt0eXBlXTtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgfVxyXG4gICwgY2hlY2tUb2tlbkFuZEdldEluZGV4ID0gZnVuY3Rpb24gKGNsYXNzTGlzdCwgdG9rZW4pIHtcclxuICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXHJcbiAgICAgICAgICBcIlNZTlRBWF9FUlJcIlxyXG4gICAgICAgICwgXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKC9cXHMvLnRlc3QodG9rZW4pKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCJcclxuICAgICAgICAsIFwiU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJJbmRleE9mLmNhbGwoY2xhc3NMaXN0LCB0b2tlbik7XHJcbiAgfVxyXG4gICwgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcclxuICAgICAgLCBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW11cclxuICAgICAgLCBpID0gMFxyXG4gICAgICAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHRoaXMucHVzaChjbGFzc2VzW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cclxuICAsIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgQ2xhc3NMaXN0KHRoaXMpO1xyXG4gIH1cclxuO1xyXG4vLyBNb3N0IERPTUV4Y2VwdGlvbiBpbXBsZW1lbnRhdGlvbnMgZG9uJ3QgYWxsb3cgY2FsbGluZyBET01FeGNlcHRpb24ncyB0b1N0cmluZygpXHJcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxyXG5ET01FeFtwcm90b1Byb3BdID0gRXJyb3JbcHJvdG9Qcm9wXTtcclxuY2xhc3NMaXN0UHJvdG8uaXRlbSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICB0b2tlbiArPSBcIlwiO1xyXG4gIHJldHVybiBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pICE9PSAtMTtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhclxyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcclxuICAgICwgaSA9IDBcclxuICAgICwgbCA9IHRva2Vucy5sZW5ndGhcclxuICAgICwgdG9rZW5cclxuICAgICwgdXBkYXRlZCA9IGZhbHNlXHJcbiAgO1xyXG4gIGRvIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcclxuICAgIGlmIChjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pID09PSAtMSkge1xyXG4gICAgICB0aGlzLnB1c2godG9rZW4pO1xyXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICAgICwgaW5kZXhcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xyXG4gICAgd2hpbGUgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlICgrK2kgPCBsKTtcclxuXHJcbiAgaWYgKHVwZGF0ZWQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcblxyXG4gIHZhclxyXG4gICAgICByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKVxyXG4gICAgLCBtZXRob2QgPSByZXN1bHQgP1xyXG4gICAgICBmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXHJcbiAgICA6XHJcbiAgICAgIGZvcmNlICE9PSBmYWxzZSAmJiBcImFkZFwiXHJcbiAgO1xyXG5cclxuICBpZiAobWV0aG9kKSB7XHJcbiAgICB0aGlzW21ldGhvZF0odG9rZW4pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZvcmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gIXJlc3VsdDtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xyXG59O1xyXG5cclxuaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xyXG4gIHZhciBjbGFzc0xpc3RQcm9wRGVzYyA9IHtcclxuICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcclxuICAgICwgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XHJcbiAgfSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXHJcbiAgICBpZiAoZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xyXG4gICAgICBjbGFzc0xpc3RQcm9wRGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICAgIH1cclxuICB9XHJcbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xyXG4gIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XHJcbn1cclxuXHJcbn0oc2VsZikpO1xyXG5cclxufSBlbHNlIHtcclxuLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXHJcbi8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKTtcclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XHJcblxyXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXHJcbiAgLy8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXHJcbiAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xyXG4gICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgICB2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XHJcblxyXG4gICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIHRva2VuID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XHJcbiAgICBjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxyXG4gIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICBpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcclxuICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XHJcblxyXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbih0b2tlbiwgZm9yY2UpIHtcclxuICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICB9XHJcblxyXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcclxufSgpKTtcclxuXHJcbn1cclxuXHJcbn1cclxuXHJcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXplIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuXHRcdGlmIChldmVudC50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZXZlbnQuZGV0YWlsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRwZXJtaXR0ZWQgPSB0aGlzLm9uTW91c2UoZXZlbnQpO1xuXG5cdFx0Ly8gT25seSB1bnNldCB0YXJnZXRFbGVtZW50IGlmIHRoZSBjbGljayBpcyBub3QgcGVybWl0dGVkLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGNoZWNrIGZvciAhdGFyZ2V0RWxlbWVudCBpbiBvbk1vdXNlIGZhaWxzIGFuZCB0aGUgYnJvd3NlcidzIGNsaWNrIGRvZXNuJ3QgZ28gdGhyb3VnaC5cblx0XHRpZiAoIXBlcm1pdHRlZCkge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gcGVybWl0dGVkO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMubGF5ZXI7XG5cblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgRmFzdENsaWNrIGlzIG5lZWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqL1xuXHRGYXN0Q2xpY2subm90TmVlZGVkID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xuXHRcdHZhciBjaHJvbWVWZXJzaW9uO1xuXHRcdHZhciBibGFja2JlcnJ5VmVyc2lvbjtcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XG5cblx0XHQvLyBEZXZpY2VzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b3VjaCBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIENocm9tZSB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRjaHJvbWVWZXJzaW9uID0gKygvQ2hyb21lXFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoY2hyb21lVmVyc2lvbikge1xuXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIG9uIEFuZHJvaWQgd2l0aCB1c2VyLXNjYWxhYmxlPVwibm9cIiBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjODkpXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDaHJvbWUgMzIgYW5kIGFib3ZlIHdpdGggd2lkdGg9ZGV2aWNlLXdpZHRoIG9yIGxlc3MgZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIENocm9tZSBkZXNrdG9wIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICMxNSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0JsYWNrQmVycnkxMCkge1xuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xuXG5cdFx0XHQvLyBCbGFja0JlcnJ5IDEwLjMrIGRvZXMgbm90IHJlcXVpcmUgRmFzdGNsaWNrIGxpYnJhcnkuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXG5cdFx0XHRpZiAoYmxhY2tiZXJyeVZlcnNpb25bMV0gPj0gMTAgJiYgYmxhY2tiZXJyeVZlcnNpb25bMl0gPj0gMykge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIHVzZXItc2NhbGFibGU9bm8gZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTEwIHdpdGggLW1zLXRvdWNoLWFjdGlvbjogbm9uZSBvciBtYW5pcHVsYXRpb24sIHdoaWNoIGRpc2FibGVzIGRvdWJsZS10YXAtdG8tem9vbSAoaXNzdWUgIzk3KVxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBGaXJlZm94IHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGZpcmVmb3hWZXJzaW9uID0gKygvRmlyZWZveFxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGZpcmVmb3hWZXJzaW9uID49IDI3KSB7XG5cdFx0XHQvLyBGaXJlZm94IDI3KyBkb2VzIG5vdCBoYXZlIHRhcCBkZWxheSBpZiB0aGUgY29udGVudCBpcyBub3Qgem9vbWFibGUgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjI4OTZcblxuXHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXHRcdFx0aWYgKG1ldGFWaWV3cG9ydCAmJiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTE6IHByZWZpeGVkIC1tcy10b3VjaC1hY3Rpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgaXQncyByZWNvbW1lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG59KCkpO1xuIiwiLyoqXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxuICogXG4gKiAtIHB1cmUgamF2YXNjcmlwdCAtIHNlcnZlciBjb21wYXRpYmxlLCBicm93c2VyIGNvbXBhdGlibGVcbiAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcbiAqIC0gc3VwZXIgc2ltcGxlIC0geW91IGdldCBpdCBpbW1lZGlhdGVseSwgbm8gbXlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiAtIGNyZWF0ZSBhIE1pY3JvRXZlbnREZWJ1ZyB3aXRoIGdvb2RpZXMgdG8gZGVidWdcbiAqICAgLSBtYWtlIGl0IHNhZmVyIHRvIHVzZVxuKi9cblxuLyoqIE5PVEU6IFRoaXMgbGlicmFyeSBpcyBjdXN0b21pemVkIGZvciBPbnNlbiBVSS4gKi9cblxudmFyIE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xuTWljcm9FdmVudC5wcm90b3R5cGUgID0ge1xuICBvbiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGZjdCk7XG4gIH0sXG4gIG9uY2UgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVyKTtcbiAgICAgIHJldHVybiBmY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnQsIHdyYXBwZXIpO1xuICB9LFxuICBvZmYgIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmKCBldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlICApICByZXR1cm47XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5zcGxpY2UodGhpcy5fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGZjdCksIDEpO1xuICB9LFxuICBlbWl0IDogZnVuY3Rpb24oZXZlbnQgLyogLCBhcmdzLi4uICovKXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAqXG4gKiAtIHJlcXVpcmUoJ01pY3JvRXZlbnQnKS5taXhpbihGb29iYXIpIHdpbGwgbWFrZSBGb29iYXIgYWJsZSB0byB1c2UgTWljcm9FdmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG4qL1xuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcbiAgdmFyIHByb3BzID0gWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKyspe1xuICAgIGlmKCB0eXBlb2YgZGVzdE9iamVjdCA9PT0gJ2Z1bmN0aW9uJyApe1xuICAgICAgZGVzdE9iamVjdC5wcm90b3R5cGVbcHJvcHNbaV1dICA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9ZWxzZXtcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vLyBleHBvcnQgaW4gY29tbW9uIGpzXG5pZiggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoJ2V4cG9ydHMnIGluIG1vZHVsZSkpe1xuICBtb2R1bGUuZXhwb3J0cyAgPSBNaWNyb0V2ZW50O1xufVxuXG53aW5kb3cuTWljcm9FdmVudCA9IE1pY3JvRXZlbnQ7XG4iLCIhZnVuY3Rpb24gbih0LGUscil7ZnVuY3Rpb24gbyh1LGYpe2lmKCFlW3VdKXtpZighdFt1XSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyh1LCEwKTtpZihpKXJldHVybiBpKHUsITApO3ZhciBzPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrdStcIidcIik7dGhyb3cgcy5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHN9dmFyIGw9ZVt1XT17ZXhwb3J0czp7fX07dFt1XVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihuKXt2YXIgZT10W3VdWzFdW25dO3JldHVybiBvKGU/ZTpuKX0sbCxsLmV4cG9ydHMsbix0LGUscil9cmV0dXJuIGVbdV0uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSx1PTA7dTxyLmxlbmd0aDt1KyspbyhyW3VdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKG4sdCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7fWZ1bmN0aW9uIG8obil7dHJ5e3JldHVybiBuLnRoZW59Y2F0Y2godCl7cmV0dXJuIGQ9dCx3fX1mdW5jdGlvbiBpKG4sdCl7dHJ5e3JldHVybiBuKHQpfWNhdGNoKGUpe3JldHVybiBkPWUsd319ZnVuY3Rpb24gdShuLHQsZSl7dHJ5e24odCxlKX1jYXRjaChyKXtyZXR1cm4gZD1yLHd9fWZ1bmN0aW9uIGYobil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ld1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBmdW5jdGlvblwiKTt0aGlzLl8zNz0wLHRoaXMuXzEyPW51bGwsdGhpcy5fNTk9W10sbiE9PXImJnYobix0aGlzKX1mdW5jdGlvbiBjKG4sdCxlKXtyZXR1cm4gbmV3IG4uY29uc3RydWN0b3IoZnVuY3Rpb24obyxpKXt2YXIgdT1uZXcgZihyKTt1LnRoZW4obyxpKSxzKG4sbmV3IHAodCxlLHUpKX0pfWZ1bmN0aW9uIHMobix0KXtmb3IoOzM9PT1uLl8zNzspbj1uLl8xMjtyZXR1cm4gMD09PW4uXzM3P3ZvaWQgbi5fNTkucHVzaCh0KTp2b2lkIHkoZnVuY3Rpb24oKXt2YXIgZT0xPT09bi5fMzc/dC5vbkZ1bGZpbGxlZDp0Lm9uUmVqZWN0ZWQ7aWYobnVsbD09PWUpcmV0dXJuIHZvaWQoMT09PW4uXzM3P2wodC5wcm9taXNlLG4uXzEyKTphKHQucHJvbWlzZSxuLl8xMikpO3ZhciByPWkoZSxuLl8xMik7cj09PXc/YSh0LnByb21pc2UsZCk6bCh0LnByb21pc2Uscil9KX1mdW5jdGlvbiBsKG4sdCl7aWYodD09PW4pcmV0dXJuIGEobixuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIikpO2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkpe3ZhciBlPW8odCk7aWYoZT09PXcpcmV0dXJuIGEobixkKTtpZihlPT09bi50aGVuJiZ0IGluc3RhbmNlb2YgZilyZXR1cm4gbi5fMzc9MyxuLl8xMj10LHZvaWQgaChuKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKXJldHVybiB2b2lkIHYoZS5iaW5kKHQpLG4pfW4uXzM3PTEsbi5fMTI9dCxoKG4pfWZ1bmN0aW9uIGEobix0KXtuLl8zNz0yLG4uXzEyPXQsaChuKX1mdW5jdGlvbiBoKG4pe2Zvcih2YXIgdD0wO3Q8bi5fNTkubGVuZ3RoO3QrKylzKG4sbi5fNTlbdF0pO24uXzU5PW51bGx9ZnVuY3Rpb24gcChuLHQsZSl7dGhpcy5vbkZ1bGZpbGxlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246bnVsbCx0aGlzLm9uUmVqZWN0ZWQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90Om51bGwsdGhpcy5wcm9taXNlPWV9ZnVuY3Rpb24gdihuLHQpe3ZhciBlPSExLHI9dShuLGZ1bmN0aW9uKG4pe2V8fChlPSEwLGwodCxuKSl9LGZ1bmN0aW9uKG4pe2V8fChlPSEwLGEodCxuKSl9KTtlfHxyIT09d3x8KGU9ITAsYSh0LGQpKX12YXIgeT1uKFwiYXNhcC9yYXdcIiksZD1udWxsLHc9e307dC5leHBvcnRzPWYsZi5fOTk9cixmLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKG4sdCl7aWYodGhpcy5jb25zdHJ1Y3RvciE9PWYpcmV0dXJuIGModGhpcyxuLHQpO3ZhciBlPW5ldyBmKHIpO3JldHVybiBzKHRoaXMsbmV3IHAobix0LGUpKSxlfX0se1wiYXNhcC9yYXdcIjo0fV0sMjpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIobil7dmFyIHQ9bmV3IG8oby5fOTkpO3JldHVybiB0Ll8zNz0xLHQuXzEyPW4sdH12YXIgbz1uKFwiLi9jb3JlLmpzXCIpO3QuZXhwb3J0cz1vO3ZhciBpPXIoITApLHU9cighMSksZj1yKG51bGwpLGM9cih2b2lkIDApLHM9cigwKSxsPXIoXCJcIik7by5yZXNvbHZlPWZ1bmN0aW9uKG4pe2lmKG4gaW5zdGFuY2VvZiBvKXJldHVybiBuO2lmKG51bGw9PT1uKXJldHVybiBmO2lmKHZvaWQgMD09PW4pcmV0dXJuIGM7aWYobj09PSEwKXJldHVybiBpO2lmKG49PT0hMSlyZXR1cm4gdTtpZigwPT09bilyZXR1cm4gcztpZihcIlwiPT09bilyZXR1cm4gbDtpZihcIm9iamVjdFwiPT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiPT10eXBlb2Ygbil0cnl7dmFyIHQ9bi50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpcmV0dXJuIG5ldyBvKHQuYmluZChuKSl9Y2F0Y2goZSl7cmV0dXJuIG5ldyBvKGZ1bmN0aW9uKG4sdCl7dChlKX0pfXJldHVybiByKG4pfSxvLmFsbD1mdW5jdGlvbihuKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTtyZXR1cm4gbmV3IG8oZnVuY3Rpb24obixlKXtmdW5jdGlvbiByKHUsZil7aWYoZiYmKFwib2JqZWN0XCI9PXR5cGVvZiBmfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmKSl7aWYoZiBpbnN0YW5jZW9mIG8mJmYudGhlbj09PW8ucHJvdG90eXBlLnRoZW4pe2Zvcig7Mz09PWYuXzM3OylmPWYuXzEyO3JldHVybiAxPT09Zi5fMzc/cih1LGYuXzEyKTooMj09PWYuXzM3JiZlKGYuXzEyKSx2b2lkIGYudGhlbihmdW5jdGlvbihuKXtyKHUsbil9LGUpKX12YXIgYz1mLnRoZW47aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYyl7dmFyIHM9bmV3IG8oYy5iaW5kKGYpKTtyZXR1cm4gdm9pZCBzLnRoZW4oZnVuY3Rpb24obil7cih1LG4pfSxlKX19dFt1XT1mLDA9PT0tLWkmJm4odCl9aWYoMD09PXQubGVuZ3RoKXJldHVybiBuKFtdKTtmb3IodmFyIGk9dC5sZW5ndGgsdT0wO3U8dC5sZW5ndGg7dSsrKXIodSx0W3VdKX0pfSxvLnJlamVjdD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24odCxlKXtlKG4pfSl9LG8ucmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24odCxlKXtuLmZvckVhY2goZnVuY3Rpb24obil7by5yZXNvbHZlKG4pLnRoZW4odCxlKX0pfSl9LG8ucHJvdG90eXBlW1wiY2F0Y2hcIl09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGhlbihudWxsLG4pfX0se1wiLi9jb3JlLmpzXCI6MX1dLDM6W2Z1bmN0aW9uKG4sdCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7aWYoYy5sZW5ndGgpdGhyb3cgYy5zaGlmdCgpfWZ1bmN0aW9uIG8obil7dmFyIHQ7dD1mLmxlbmd0aD9mLnBvcCgpOm5ldyBpLHQudGFzaz1uLHUodCl9ZnVuY3Rpb24gaSgpe3RoaXMudGFzaz1udWxsfXZhciB1PW4oXCIuL3Jhd1wiKSxmPVtdLGM9W10scz11Lm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihyKTt0LmV4cG9ydHM9byxpLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKCl7dHJ5e3RoaXMudGFzay5jYWxsKCl9Y2F0Y2gobil7by5vbmVycm9yP28ub25lcnJvcihuKTooYy5wdXNoKG4pLHMoKSl9ZmluYWxseXt0aGlzLnRhc2s9bnVsbCxmW2YubGVuZ3RoXT10aGlzfX19LHtcIi4vcmF3XCI6NH1dLDQ6W2Z1bmN0aW9uKG4sdCxlKXsoZnVuY3Rpb24obil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShuKXtmLmxlbmd0aHx8KHUoKSxjPSEwKSxmW2YubGVuZ3RoXT1ufWZ1bmN0aW9uIHIoKXtmb3IoO3M8Zi5sZW5ndGg7KXt2YXIgbj1zO2lmKHMrPTEsZltuXS5jYWxsKCkscz5sKXtmb3IodmFyIHQ9MCxlPWYubGVuZ3RoLXM7ZT50O3QrKylmW3RdPWZbdCtzXTtmLmxlbmd0aC09cyxzPTB9fWYubGVuZ3RoPTAscz0wLGM9ITF9ZnVuY3Rpb24gbyhuKXt2YXIgdD0xLGU9bmV3IGEobikscj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtyZXR1cm4gZS5vYnNlcnZlKHIse2NoYXJhY3RlckRhdGE6ITB9KSxmdW5jdGlvbigpe3Q9LXQsci5kYXRhPXR9fWZ1bmN0aW9uIGkobil7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2NsZWFyVGltZW91dChlKSxjbGVhckludGVydmFsKHIpLG4oKX12YXIgZT1zZXRUaW1lb3V0KHQsMCkscj1zZXRJbnRlcnZhbCh0LDUwKX19dC5leHBvcnRzPWU7dmFyIHUsZj1bXSxjPSExLHM9MCxsPTEwMjQsYT1uLk11dGF0aW9uT2JzZXJ2ZXJ8fG4uV2ViS2l0TXV0YXRpb25PYnNlcnZlcjt1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGE/byhyKTppKHIpLGUucmVxdWVzdEZsdXNoPXUsZS5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXI9aX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDU6W2Z1bmN0aW9uKG4sdCxlKXtcImZ1bmN0aW9uXCIhPXR5cGVvZiBQcm9taXNlLnByb3RvdHlwZS5kb25lJiYoUHJvbWlzZS5wcm90b3R5cGUuZG9uZT1mdW5jdGlvbihuLHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg/dGhpcy50aGVuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzO2UudGhlbihudWxsLGZ1bmN0aW9uKG4pe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBufSwwKX0pfSl9LHt9XSw2OltmdW5jdGlvbihuLHQsZSl7bihcImFzYXBcIik7XCJ1bmRlZmluZWRcIj09dHlwZW9mIFByb21pc2UmJihQcm9taXNlPW4oXCIuL2xpYi9jb3JlLmpzXCIpLG4oXCIuL2xpYi9lczYtZXh0ZW5zaW9ucy5qc1wiKSksbihcIi4vcG9seWZpbGwtZG9uZS5qc1wiKX0se1wiLi9saWIvY29yZS5qc1wiOjEsXCIuL2xpYi9lczYtZXh0ZW5zaW9ucy5qc1wiOjIsXCIuL3BvbHlmaWxsLWRvbmUuanNcIjo1LGFzYXA6M31dfSx7fSxbNl0pO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxMiBCYXJuZXNhbmRub2JsZS5jb20sIGxsYywgRG9uYXZvbiBXZXN0LCBhbmQgRG9tZW5pYyBEZW5pY29sYVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30oKSkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdwb3J0KCkge1xuXG4gICAgICAgIHRoaXMuUFJFX0lPUzdfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG4gICAgICAgIHRoaXMuSU9TN19WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcbiAgICAgICAgdGhpcy5ERUZBVUxUX1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuXG4gICAgICAgIHRoaXMuZW5zdXJlVmlld3BvcnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSB7fTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5uYW1lID0gdGhpcy5nZXRQbGF0Zm9ybU5hbWUoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS52ZXJzaW9uID0gdGhpcy5nZXRQbGF0Zm9ybVZlcnNpb24oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmVuc3VyZVZpZXdwb3J0RWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuICAgICAgICBpZighdGhpcy52aWV3cG9ydEVsZW1lbnQpe1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5uYW1lID0gXCJ2aWV3cG9ydFwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3cG9ydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm8tYWRqdXN0JykgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy52aWV3cG9ydEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50JykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBsYXRmb3JtLm5hbWUgPT0gJ2lvcycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS52ZXJzaW9uID49IDcgJiYgaXNXZWJWaWV3KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5JT1M3X1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLlBSRV9JT1M3X1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuREVGQVVMVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1dlYlZpZXcoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEod2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwIHx8IHdpbmRvdy5QaG9uZUdhcCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYW5kcm9pZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImlvc1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5rbm93blxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZ2V0UGxhdGZvcm1WZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09TICcpO1xuICAgICAgICByZXR1cm4gd2luZG93Lk51bWJlcih3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5zdWJzdHIoc3RhcnQgKyAzLCAzKS5yZXBsYWNlKCdfJywgJy4nKSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5WaWV3cG9ydCA9IFZpZXdwb3J0O1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IE9wZW4gVGVjaG5vbG9naWVzLCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuLy8gSmF2YVNjcmlwdCBEeW5hbWljIENvbnRlbnQgc2hpbSBmb3IgV2luZG93cyBTdG9yZSBhcHBzXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHdpbmRvdy5NU0FwcCAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuXG4gICAgICAgIC8vIFNvbWUgbm9kZXMgd2lsbCBoYXZlIGFuIFwiYXR0cmlidXRlc1wiIHByb3BlcnR5IHdoaWNoIHNoYWRvd3MgdGhlIE5vZGUucHJvdG90eXBlLmF0dHJpYnV0ZXMgcHJvcGVydHlcbiAgICAgICAgLy8gIGFuZCBtZWFucyB3ZSBkb24ndCBhY3R1YWxseSBzZWUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIE5vZGUgKGludGVyZXN0aW5nbHkgdGhlIFZTIGRlYnVnIGNvbnNvbGVcbiAgICAgICAgLy8gIGFwcGVhcnMgdG8gc3VmZmVyIGZyb20gdGhlIHNhbWUgaXNzdWUpLlxuICAgICAgICAvL1xuICAgICAgICB2YXIgRWxlbWVudF9zZXRBdHRyaWJ1dGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCBcInNldEF0dHJpYnV0ZVwiKS52YWx1ZTtcbiAgICAgICAgdmFyIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJyZW1vdmVBdHRyaWJ1dGVcIikudmFsdWU7XG4gICAgICAgIHZhciBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUxQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgXCJpbnNlcnRBZGphY2VudEhUTUxcIik7XG4gICAgICAgIHZhciBOb2RlX2dldF9hdHRyaWJ1dGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIpLmdldDtcbiAgICAgICAgdmFyIE5vZGVfZ2V0X2NoaWxkTm9kZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCBcImNoaWxkTm9kZXNcIikuZ2V0O1xuICAgICAgICB2YXIgZGV0ZWN0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlX2dldF9hdHRyaWJ1dGVzLmNhbGwoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBFbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUuY2FsbChlbGVtZW50LCBhdHRyaWJ1dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hpbGROb2RlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfY2hpbGROb2Rlcy5jYWxsKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEFkamFjZW50SFRNTChlbGVtZW50LCBwb3NpdGlvbiwgaHRtbCkge1xuICAgICAgICAgICAgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlLmNhbGwoZWxlbWVudCwgcG9zaXRpb24sIGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5VbnNhZmVNb2RlKCkge1xuICAgICAgICAgICAgdmFyIGlzVW5zYWZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uRGl2LmlubmVySFRNTCA9IFwiPHRlc3QvPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaXNVbnNhZmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzVW5zYWZlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZShodG1sLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgY2xlYW5lciA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcImNsZWFuZXJcIik7XG4gICAgICAgICAgICBlbXB0eShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0QWRqYWNlbnRIVE1MKGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50LCBcImFmdGVyYmVnaW5cIiwgaHRtbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBjbGVhbmVyLmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzY3JpcHRzLCBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY3JpcHQudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2luZXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9lY21hc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L3gtamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2xpdmVzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2luZXJ0LVwiICsgc2NyaXB0LnR5cGUuc2xpY2UoXCJ0ZXh0L1wiLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcImFwcGxpY2F0aW9uL2luZXJ0LVwiICsgc2NyaXB0LnR5cGUuc2xpY2UoXCJhcHBsaWNhdGlvbi9cIi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnNlQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGF0dHJpYnV0ZXMgY29sbGVjdGlvbiBpcyBsaXZlIGl0IGlzIHNpbXBsZXIgdG8gcXVldWUgdXAgdGhlIHJlbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmFtZVswXSA9PT0gXCJvXCIgfHwgbmFtZVswXSA9PT0gXCJPXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWVbMV0gPT09IFwiblwiIHx8IG5hbWVbMV0gPT09IFwiTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7IG5hbWU6IGF0dHJpYnV0ZS5uYW1lLCB2YWx1ZTogYXR0cmlidXRlLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlKGVsZW1lbnQsIFwieC1cIiArIGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkTm9kZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuc2VBdHRyaWJ1dGVzKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjbGVhbmVyLmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgICAgIHZhciBjbGVhbmVkTm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50KS5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuZXIuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbmVkTm9kZXMgPSBjbGVhbmVkTm9kZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmhlYWQpLmNoaWxkTm9kZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuZXIuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbmVkTm9kZXMgPSBjbGVhbmVkTm9kZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmJvZHkpLmNoaWxkTm9kZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbGVhbmVkTm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnNlUHJvcGVydHlTZXR0ZXIocHJvcGVydHksIHNldHRlcikge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTZXR0ZXIgPSBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgcHJvcGVydHksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IHByb3BlcnR5RGVzY3JpcHRvci5nZXQsXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LldpbkpTICYmIHdpbmRvdy5XaW5KUy5fZXhlY1Vuc2FmZSAmJiBpblVuc2FmZU1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBjbGVhbnNlKHZhbHVlLCB0aGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIocHJvcGVydHlEZXNjcmlwdG9yLCB0aGF0LCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW5zZVByb3BlcnR5U2V0dGVyKFwiaW5uZXJIVE1MXCIsIGZ1bmN0aW9uIChwcm9wZXJ0eURlc2NyaXB0b3IsIHRhcmdldCwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGVtcHR5KHRhcmdldCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYW5zZVByb3BlcnR5U2V0dGVyKFwib3V0ZXJIVE1MXCIsIGZ1bmN0aW9uIChwcm9wZXJ0eURlc2NyaXB0b3IsIHRhcmdldCwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxufSgpKTsiLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHVud3JhcCA9IHN0cmluZyA9PiBzdHJpbmcuc2xpY2UoMSwgLTEpO1xuY29uc3QgaXNPYmplY3RTdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nLnN0YXJ0c1dpdGgoJ3snKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ30nKTtcbmNvbnN0IGlzQXJyYXlTdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nLnN0YXJ0c1dpdGgoJ1snKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ10nKTtcbmNvbnN0IGlzUXVvdGVkU3RyaW5nID0gc3RyaW5nID0+IChzdHJpbmcuc3RhcnRzV2l0aCgnXFwnJykgJiYgc3RyaW5nLmVuZHNXaXRoKCdcXCcnKSkgfHwgKHN0cmluZy5zdGFydHNXaXRoKCdcIicpICYmIHN0cmluZy5lbmRzV2l0aCgnXCInKSk7XG5cbmNvbnN0IGVycm9yID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0b2tlbiBcXCcnICsgdG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uICcgKyAob3JpZ2luYWxTdHJpbmcubGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCAtIDEpICsgJyBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbn07XG5cbmNvbnN0IHByb2Nlc3NUb2tlbiA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICBpZiAodG9rZW4gPT09ICd0cnVlJyB8fCB0b2tlbiA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiB0b2tlbiA9PT0gJ3RydWUnO1xuICB9IGVsc2UgaWYgKGlzUXVvdGVkU3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiB1bndyYXAodG9rZW4pO1xuICB9IGVsc2UgaWYgKCFpc05hTih0b2tlbikpIHtcbiAgICByZXR1cm4gKyh0b2tlbik7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3RTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICB9XG59O1xuXG5jb25zdCBuZXh0VG9rZW4gPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltTGVmdCgpO1xuICBsZXQgbGltaXQgPSBzdHJpbmcubGVuZ3RoO1xuXG4gIGlmIChzdHJpbmdbMF0gPT09ICc6JyB8fCBzdHJpbmdbMF0gPT09ICcsJykge1xuXG4gICAgbGltaXQgPSAxO1xuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAneycgfHwgc3RyaW5nWzBdID09PSAnWycpIHtcblxuICAgIGNvbnN0IGMgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgbmVzdGVkT2JqZWN0ID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYyArIDIpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0LS07XG4gICAgICAgIGlmIChuZXN0ZWRPYmplY3QgPT09IDApIHtcbiAgICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAnXFwnJyB8fCBzdHJpbmdbMF0gPT09ICdcXFwiJykge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmdbaV0gPT09IHN0cmluZ1swXSkge1xuICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoWycgJywgJywnLCAnOiddLmluZGV4T2Yoc3RyaW5nW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgbGltaXQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGltaXQpO1xufTtcblxuY29uc3QgcGFyc2VPYmplY3QgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGlzVmFsaWRLZXkgPSBrZXkgPT4gL15bQS1aX1xcJF1bQS1aMC05X1xcJF0qJC9pLnRlc3Qoa2V5KTtcblxuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3Qgb2JqZWN0ID0ge307XG4gIGxldCByZWFkaW5nS2V5ID0gdHJ1ZSwga2V5LCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZShzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW1MZWZ0KCk7XG5cbiAgICBpZiAoKHRva2VuID09PSAnOicgJiYgKCFyZWFkaW5nS2V5IHx8ICFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpXG4gICAgICAgfHwgKHRva2VuID09PSAnLCcgJiYgcmVhZGluZ0tleSlcbiAgICAgICB8fCAodG9rZW4gIT09ICc6JyAmJiB0b2tlbiAhPT0gJywnICYmIChwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4gIT09ICcsJyAmJiBwcmV2aW91c1Rva2VuICE9PSAnOicpKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICc6JyAmJiByZWFkaW5nS2V5ICYmIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgIGlmIChpc1ZhbGlkS2V5KHByZXZpb3VzVG9rZW4pKSB7XG4gICAgICAgIGtleSA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIHJlYWRpbmdLZXkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgdG9rZW4gXFwnJyArIHByZXZpb3VzVG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uIDAgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnICYmICFyZWFkaW5nS2V5ICYmIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHByZXZpb3VzVG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgICAgcmVhZGluZ0tleSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyYXkgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBsZXQgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xuXG4gICAgaWYgKHRva2VuID09PSAnLCcgJiYgKCFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHByZXZpb3VzVG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gIT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbmNvbnN0IHBhcnNlID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuXG4gIGlmIChpc09iamVjdFN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBzdHJpbmcgbXVzdCBiZSBvYmplY3Qgb3IgYXJyYXkgbGlrZTogJyArIHN0cmluZyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZSBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudXRpbC5wcmVwYXJlUXVlcnkgPSAocXVlcnkpID0+IHtcbiAgcmV0dXJuIHF1ZXJ5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBxdWVyeSA6IChlbGVtZW50KSA9PiB1dGlsLm1hdGNoKGVsZW1lbnQsIHF1ZXJ5KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5tYXRjaCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBpZiAocXVlcnlbMF0gPT09ICcuJykge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhxdWVyeS5zbGljZSgxKSk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcXVlcnk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnQvbnVsbH1cbiAqL1xudXRpbC5maW5kQ2hpbGQgPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5baV07XG4gICAgaWYgKG1hdGNoKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnQvbnVsbH1cbiAqL1xudXRpbC5maW5kUGFyZW50ID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hdGNoKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc0F0dGFjaGVkID0gKGVsZW1lbnQpID0+IHtcbiAgd2hpbGUgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQgPSAoZWxlbWVudCkgPT4ge1xuICB3aGlsZSAoZWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5tYXRjaCgvKG9ucy1uYXZpZ2F0b3J8b25zLXRhYmJhcnxvbnMtc2xpZGluZy1tZW51fG9ucy1zcGxpdC12aWV3KS8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gKi9cbnV0aWwucHJvcGFnYXRlQWN0aW9uID0gKGVsZW1lbnQsIGFjdGlvbikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZFthY3Rpb25dIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oY2hpbGQsIGFjdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGUgPSAoc2VsZWN0b3IgPSAnJywgc3R5bGUgPSB7fSkgPT4ge1xuICBjb25zdCBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XG5cbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cblxuICB1dGlsLmV4dGVuZChlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZUVsZW1lbnQgPSAoaHRtbCkgPT4ge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHdyYXBwZXIuaW5uZXJIVE1MID0gaHRtbDtcblxuICBpZiAod3JhcHBlci5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImh0bWxcIiBtdXN0IGJlIG9uZSB3cmFwcGVyIGVsZW1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlci5jaGlsZHJlblswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn07XG5cbi8qXG4gKiBAcGFyYW0ge09iamVjdH0gZHN0IERlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cbiAqL1xudXRpbC5leHRlbmQgPSAoZHN0LCAuLi5hcmdzKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnc1tpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgZHN0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuYXJyYXlGcm9tID0gKGFycmF5TGlrZSkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhaWxTYWZlXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLnBhcnNlSlNPTk9iamVjdFNhZmVseSA9IChqc29uU3RyaW5nLCBmYWlsU2FmZSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFpbFNhZmU7XG4gIH1cbiAgcmV0dXJuIGZhaWxTYWZlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcbiAqIEByZXR1cm4ge0FueX0gLSB3aGF0ZXZlciBpcyBsb2NhdGVkIGF0IHRoYXQgcGF0aFxuICovXG51dGlsLmZpbmRGcm9tUGF0aCA9IChwYXRoKSA9PiB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBlbCA9IHdpbmRvdywga2V5O1xuICB3aGlsZSAoa2V5ID0gcGF0aC5zaGlmdCgpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICBlbCA9IGVsW2tleV07XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxuICogQHJldHVybiB7Q3VzdG9tRXZlbnR9XG4gKi9cbnV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgZGV0YWlsID0ge30pID0+IHtcblxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZGV0YWlsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZXZlbnRba2V5XSA9IGRldGFpbFtrZXldO1xuICB9KTtcblxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5oYXNNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKS5zb21lKGUgPT4gZSA9PT0gbW9kaWZpZXJOYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGFkZGVkIG9yIG5vdC5cbiAqL1xudXRpbC5hZGRNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAodXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtb2RpZmllck5hbWUgPSBtb2RpZmllck5hbWUudHJpbSgpO1xuICBjb25zdCBtb2RpZmllckF0dHJpYnV0ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgKG1vZGlmaWVyQXR0cmlidXRlICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC5yZW1vdmVNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLyk7XG5cbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lKTtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKTtcblxuICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcbn07XG5cbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCBlbmFibGUpID0+IHtcbiAgaWYgKGVuYWJsZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufTtcblxudXRpbC5iaW5kTGlzdGVuZXJzID0gKGVsZW1lbnQsIGxpc3RlbmVyTmFtZXMpID0+IHtcbiAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGJvdW5kTmFtZSA9IG5hbWUucmVwbGFjZSgvXl9bYS16XS8sICdfYm91bmQnICsgbmFtZVsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBlbGVtZW50W2JvdW5kTmFtZV0gPSBlbGVtZW50W2JvdW5kTmFtZV0gfHwgZWxlbWVudFtuYW1lXS5iaW5kKGVsZW1lbnQpO1xuICB9KTtcbn07XG5cbnV0aWwuZWFjaCA9IChvYmosIGYpID0+IE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gZihrZXksIG9ialtrZXldKSk7XG5cbmNvbnN0IHNhZmUgPSBmID0+IGZ1bmN0aW9uKCl7XG4gIGlmIChmIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xudXRpbC5zYWZlQ2FsbCA9IChvYmplY3QsIHByb3AsIC4uLnJlc3QpID0+IHNhZmUob2JqZWN0W3Byb3BdKS5hcHBseShvYmplY3QsIHJlc3QpO1xudXRpbC5zYWZlQXBwbHkgPSAob2JqZWN0LCBwcm9wLCAgIHJlc3QpID0+IHNhZmUob2JqZWN0W3Byb3BdKS5hcHBseShvYmplY3QsIHJlc3QpO1xuXG5jb25zdCBpc09mVHlwZSA9IChvYmplY3QsIHR5cGUpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5zb21lKHR5cGUgPT4gaXNPZlR5cGUob2JqZWN0LCB0eXBlKSk7XG4gIH1cbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0eXBlID09PSAnbnVsbCc7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0eXBlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqZWN0ID09PSB0eXBlO1xuICB9XG59O1xuXG5jb25zdCBfcHJpbnRUeXBlID0gdHlwZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUubWFwKF9wcmludFR5cGUpLmpvaW4oJyBvciAnKTtcbiAgfVxuICByZXR1cm4gKHR5cGUgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiAnYW4gaW5zdGFuY2Ugb2YgJyArIHR5cGUpIHx8XG4gICAgKHR5cGUgPT09ICdudWxsJyAmJiAnbnVsbCcpIHx8ICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgJ2EgJyArIHR5cGUpIHx8IEpTT04uc3RyaW5naWZ5KHR5cGUpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgaW4gdGhlIGVycm9yIGlmIHRoZSB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbn0gb2JqZWN0IC0gb2JqZWN0IHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB2YWxpZGF0aW9uIG9wdGlvbnMgb3IgdHlwZVxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd8RnVuY3Rpb259IG9wdGlvbnMudHlwZSAtIGV4cGVjdGVkIHR5cGUgb3IgYXJyYXkgb2YgdmFsaWQgdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufSBvcHRpb25zLnJldHVybnMgLSBleHBlY3RlZCB0eXBlIG9mIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zYWZlQ2FsbCAtIGlmIHRoaXMgaXMgdHJ1ZSB0aGVuIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIHRoZSBgb2JqZWN0YCBhcmd1bWVudCBpZiBpdCdzIGEgZnVuY3Rpb24uIEl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIGl0IGl0J3Mgbm90LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZHluYW1pY0NhbGwgLSBpZiB0aGlzIGlzIHNldCB0aGVuIGFsbCBjaGVja3Mgd2lsbCBiZSBjb21wbGV0ZWQgd2hlbiB0cnlpbmcgdG8gZXhlY3V0ZSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLiBGdXJ0aGVybW9yZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb2JqZWN0YCBhcmd1bWVudCBpdCB3aWxsIHVzZSBvcHRpb25zLmR5bmFtaWNDYWxsJ3MgYG9iamVjdFtrZXldYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmR5bmFtaWNDYWxsLm9iamVjdCAtIHJlcXVpcmVkIGlmIGR5bmFtaWNDYWxsIGlzIGV4aXN0c1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZHluYW1pY0NhbGwua2V5IC0gcmVxdWlyZWQgaWYgZHluYW1pY0NhbGwgaXMgZXhpc3RzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5jb250ZXh0IC0gdGhpcyBpcyBzdGlsbCBhbiBleHBlcmltZW50YWwgc2V0dGluZy4gQ29udGV4dCBvZiB0aGUgZnVuY3Rpb24uIFVzZWQgb25seSB3aXRoIGR5bmFtaWNDYWxsIGFuZCByZXR1cm5zLiBEZWZhdWx0cyB0byBkeW5hbWljQ2FsbC5vYmplY3QuXG4gKiBAcmV0dXJuIHZhbGlkYXRlZCBvYmplY3RcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIHZhbGlkYXRpb24gZmFpbHNcbiAqIEBleGFtcGxlXG4gKiAgICBkb2dlID0gdmFsaWRhdGVkKCdkb2dlJywgZG9nZSwgW0RvZ2UsICdzdHJpbmcnXSk7XG4gKiAgICBmb28gPSB2YWxpZGF0ZWQoJ2ZvbycsIGZvbywge3R5cGU6IFsnbnVtYmVyJywgQXJyYXksICdudWxsJ119KTtcbiAqICAgIGJhciA9IHZhbGlkYXRlZCgnYmFyJywgYmFyLCB7dHlwZTogJ2Z1bmN0aW9uJywgc2FmZUNhbGw6IHRydWV9KTtcbiAqICAgIGJheiA9IHZhbGlkYXRlZCgnYmF6JywgbnVsbCwge3R5cGU6ICdmdW5jdGlvbicsIHJldHVybnM6ICdzdHJpbmcnLCBkeW5hbWljQ2FsbDoge29iamVjdDogb2JqLCBrZXk6ICdmb28nfX0pO1xuICpcbiAqICAgIGhvZ2UgPSB2YWxpZGF0ZWQoJ2hvZ2UnLCBvYmosIHtcbiAqICAgICAgdHlwZTogW0RvZ2UsIER1Y2tdLFxuICogICAgICBvYmplY3Q6IHtcbiAqICAgICAgICBuYW1lOiAnc3RyaW5nJyxcbiAqICAgICAgICB3b3c6ICdib29sZWFuJyxcbiAqICAgICAgICB3YWxrOiB7dHlwZTogJ2Z1bmN0aW9uJywgcmV0dXJuczogJ2Jvb2xlYW4nfSxcbiAqICAgICAgICB0YWxrOiB7dHlwZTogJ2Z1bmN0aW9uJywgZHluYW1pY0NhbGw6IHtvYmplY3Q6IG9iaiwga2V5OiAncXVhY2snfSwgc2FmZUNhbGw6IHRydWV9XG4gKiAgICAgIH1cbiAqICAgIH0pO1xuICpcbiAqIEB0b2RvIFN1cHBvcnQgZm9yIGZ1bmN0aW9ucyB3aXRoIG9wdGlvbnMub2JqZWN0IC0ge3R5cGU6IEZ1bmN0aW9uLCBvYmplY3Q6IG9ian1cbiAqL1xuXG5jb25zdCB2YWxpZGF0ZWQgPSB1dGlsLnZhbGlkYXRlZCA9IChuYW1lLCBvYmplY3QsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8ICghb3B0aW9ucy5vYmplY3QgJiYgb3B0aW9ucyk7XG4gIGlmICh0eXBlICYmICFpc09mVHlwZShvYmplY3QsIHR5cGUpICYmICEob3B0aW9ucy5keW5hbWljQ2FsbCB8fCBvcHRpb25zLnNhZmVDYWxsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBtdXN0IGJlICcgKyBfcHJpbnRUeXBlKHR5cGUpICsgJy4gWW91IHByb3ZpZGVkICcgKyBvYmplY3QpO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0KSB7XG4gICAgbmFtZSA9IG5hbWUgPyBuYW1lICsgJy4nIDogJyc7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5vYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGR5bmFtaWNDYWxsID0gb3B0aW9ucy5vYmplY3Rba2V5XS5keW5hbWljQ2FsbDtcbiAgICAgIGlmIChkeW5hbWljQ2FsbCkge1xuICAgICAgICBkeW5hbWljQ2FsbC5vYmplY3QgPSBkeW5hbWljQ2FsbC5vYmplY3QgfHwgb2JqZWN0O1xuICAgICAgICBkeW5hbWljQ2FsbC5rZXkgPSBkeW5hbWljQ2FsbC5rZXkgfHwga2V5O1xuICAgICAgfVxuICAgICAgcmVzdWx0W2tleV0gPSB2YWxpZGF0ZWQobmFtZSArIGtleSwgb2JqZWN0W2tleV0sIG9wdGlvbnMub2JqZWN0W2tleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKHR5cGUgPT09IEZ1bmN0aW9uIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB7b2JqZWN0OiBvYmosIGtleX0gPSBvcHRpb25zLmR5bmFtaWNDYWxsIHx8IHt9O1xuICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgfHwgb2JqO1xuICAgIGNvbnN0IHRlc3QgPSBvcHRpb25zLnNhZmVDYWxsID8gc2FmZSA6IG9wdGlvbnMuZHluYW1pY0NhbGwgPyBmID0+IHZhbGlkYXRlZChuYW1lLCBmLCBGdW5jdGlvbikgOiBmID0+IGY7XG5cbiAgICBvYmplY3QgPSBvcHRpb25zLmR5bmFtaWNDYWxsID8gKC4uLnJlc3QpID0+IHRlc3Qob2JqW2tleV0pLmFwcGx5KGNvbnRleHQsIHJlc3QpIDogdGVzdChvYmplY3QpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV0dXJucykge1xuICAgICAgcmV0dXJuICguLi5yZXN0KSA9PiAgdmFsaWRhdGVkKG5hbWUgKyAnXFwncyByZXN1bHQnLCBvYmplY3QuYXBwbHkoY29udGV4dCwgcmVzdCksIG9wdGlvbnMucmV0dXJucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cbnV0aWwudXBkYXRlUmlwcGxlID0gKHRhcmdldCkgPT4ge1xuICBjb25zdCByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xuXG4gIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSkge1xuICAgIGlmICghcmlwcGxlRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtcmlwcGxlJyksIHRhcmdldC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmlwcGxlRWxlbWVudCkge1xuICAgIHJpcHBsZUVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xudXRpbC5pc0ludGVnZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICBpc0Zpbml0ZSh2YWx1ZSkgJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1dGlsO1xuIiwiLypcbiAqIEdlc3R1cmUgZGV0ZWN0b3IgbGlicmFyeSB0aGF0IGZvcmtlZCBmcm9tIGdpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnQsIFV0aWxzLCBEZXRlY3Rpb24sIFBvaW50ZXJFdmVudDtcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5HZXN0dXJlRGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgY2xhc3MgZm9yIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjgq/jg6njgrnjgafjgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICogQHNpZ25hdHVyZSBjb25zdHJ1Y3RvcihlbGVtZW50Wywgb3B0aW9uc10pXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dQ3JlYXRlIGEgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZS5bL2VuXVxuICogIFtqYV1HZXN0dXJlRGV0ZWN0b3Ljga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KLRE9N6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7b25zLkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xudmFyIEdlc3R1cmVEZXRlY3RvciA9IGZ1bmN0aW9uIEdlc3R1cmVEZXRlY3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKiBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGAvZ2VzdHVyZXNgLiBFYWNoIGdlc3R1cmUgY2FuIGJlIGRpc2FibGVkL2VuYWJsZWRcbiAqIGJ5IHNldHRpbmcgaXQncyBuYW1lIChsaWtlIGBzd2lwZWApIHRvIGZhbHNlLlxuICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hBY3Rpb24gPSAncGFuLXknO1xuICogIGRlbGV0ZSBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdDtcbiAqIGBgYGBcbiAqIEBwcm9wZXJ0eSBkZWZhdWx0c1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzID0ge1xuICBiZWhhdmlvcjoge1xuICAgIC8vIHVzZXJTZWxlY3Q6ICdub25lJywgLy8gQWxzbyBkaXNhYmxlcyBzZWxlY3Rpb24gaW4gYGlucHV0YCBjaGlsZHJlblxuICAgIHRvdWNoQWN0aW9uOiAncGFuLXknLFxuICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG4gICAgdXNlckRyYWc6ICdub25lJyxcbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cbn07XG5cbi8qKlxuICogR2VzdHVyZURldGVjdG9yIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMgPSAoR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyAmJiBHZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFKSB8fCBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggR2VzdHVyZURldGVjdG9yIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgPSBHZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyA9IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICBpZihHZXN0dXJlRGV0ZWN0b3IuUkVBRFkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBmaW5kIHdoYXQgZXZlbnR0eXBlcyB3ZSBhZGQgbGlzdGVuZXJzIHRvXG4gIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICBVdGlscy5lYWNoKEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QpO1xuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfRU5ELCBEZXRlY3Rpb24uZGV0ZWN0KTtcblxuICAvLyBHZXN0dXJlRGV0ZWN0b3IgaXMgcmVhZHkuLi4hXG4gIEdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IHRydWU7XG59XG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBzdGF0aWNcbiAqL1xuVXRpbHMgPSBHZXN0dXJlRGV0ZWN0b3IudXRpbHMgPSB7XG4gIC8qKlxuICAgKiBleHRlbmQgbWV0aG9kLCBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGNsb25pbmcgd2hlbiBgZGVzdGAgaXMgYW4gZW1wdHkgb2JqZWN0LlxuICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXSAgZG8gYSBtZXJnZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkgJiYgKGRlc3Rba2V5XSA9PT0gdW5kZWZpbmVkIHx8ICFtZXJnZSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgYWRkRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvckVhY2ggb3ZlciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge2FueX0gaXRlcmF0b3IuaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IuaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgIGluIHRoZSBpdGVyYXRvclxuICAgKi9cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbjtcblxuICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIC8vIGFycmF5c1xuICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gb2JqZWN0c1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IoaSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpICYmXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBpblN0cjogZnVuY3Rpb24gaW5TdHIoc3JjLCBmaW5kKSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cbiAgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQpIHtcbiAgICBpZihzcmMuaW5kZXhPZikge1xuICAgICAgdmFyIGluZGV4ID0gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICByZXR1cm4gKGluZGV4ID09PSAtMSkgPyBmYWxzZSA6IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHBhZ2VYID0gW10sXG4gICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgY2xpZW50WSA9IFtdLFxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cblxuICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBnZXRWZWxvY2l0eTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuICAvKipcbiAgICogZG8gYSBzbWFsbCBjb21wYXJpc29uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICovXG4gIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYKSxcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgaWYoeCA+PSB5KSB7XG4gICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xuICAgKiBAcGFyYW0ge1RvdWNofXRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIGdldERpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC8gdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwcm9wO1xuICAgICAgLy8gcHJlZml4ZXNcbiAgICAgIGlmKHByZWZpeGVzW2ldKSB7XG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXG4gICAgICBpZihwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqL1xuICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgY3NzIHByb3BlcnRpZXNcbiAgICBVdGlscy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZmFsc2VGbiA9IHRvZ2dsZSAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgaWYocHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICogc28gcHJldmVudF9kZWZhdWx0IGJlY29tZXMgcHJldmVudERlZmF1bHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgKi9cbiAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cbi8qKlxuICogQGNsYXNzIEV2ZW50XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50ID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAvKipcbiAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGFydGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAqIHRoaXMgZmluZHMgb3V0IGlmIHdlIHNob3VsZCB0byBkZXRlY3QgZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4gb25Ub3VjaEhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY29yZSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uIG9uVG91Y2hIYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc1BvaW50ZXIgPSBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMsXG4gICAgICAgICAgaXNNb3VzZSA9IFV0aWxzLmluU3RyKHNyY1R5cGUsICdtb3VzZScpLFxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgaW4gYSBtb3VzZWV2ZW50LCBidXQgdGhlcmUgaGFzIGJlZW4gYSB0b3VjaGV2ZW50IHRyaWdnZXJlZCBpbiB0aGlzIHNlc3Npb25cbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXG4gICAgICBpZihpc01vdXNlICYmIHNlbGYucHJldmVudE1vdXNlRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtb3VzZWJ1dHRvbiBtdXN0IGJlIGRvd25cbiAgICAgIH0gZWxzZSBpZihpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XG4gICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICB9IGVsc2UgaWYoIWlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgaWYoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIFBvaW50ZXJFdmVudC5yZXNldCgpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXJldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGRldGVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgcmV0dXJuIG9uVG91Y2hIYW5kbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXG4gICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgR2VzdHVyZURldGVjdG9yLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICovXG4gIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xuICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxuICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgIH1cblxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICB2YXIgZXZEYXRhID0gdGhpcy5jb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIHRyaWdnZXJUeXBlLCB0b3VjaExpc3QsIGV2KTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICBpZihldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICogdGhlIGBvblRvdWNoYCBtZXRob2QgaXMgYmluZCB0byB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICB2YXIgdHlwZXM7XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgIHJldHVybiBldi50b3VjaGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xuICAgICAgdmFyIHRvdWNoTGlzdCA9IFtdO1xuXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgLyoqXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSB0aGlzLnNyY0V2ZW50O1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG5Qb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihldmVudFR5cGUsIHBvaW50ZXJFdmVudCkge1xuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcbiAgICBVdGlscy5leHRlbmQoR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKCk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQG1ldGhvZCBvblxuICAgKiBAc2lnbmF0dXJlIG9uKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1BZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2VzdHVyZS4gQXZhaWxhYmxlIGdlc3R1cmVzIGFyZTogZHJhZywgZHJhZ2xlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93biwgaG9sZCwgcmVsZWFzZSwgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duLCB0YXAsIGRvdWJsZXRhcCwgdG91Y2gsIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0IGFuZCByb3RhdGUuIFsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj44Gr5a++44GZ44KL44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS6L+95Yqg44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44K444Kn44K544OB44Oj5ZCN44Gv44CBZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIGhvbGQgcmVsZWFzZSBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93biB0YXAgZG91YmxldGFwIHRvdWNoIHRyYW5zZm9ybSBwaW5jaCBwaW5jaGluIHBpbmNob3V0IHJvdGF0ZSDjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3mpJznn6XjgZnjgovjgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzZWxmLmV2ZW50SGFuZGxlcnMucHVzaCh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb2ZmXG4gICAqIEBzaWduYXR1cmUgb2ZmKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBpbmRleCA9IFV0aWxzLmluQXJyYXkoeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgaWYoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBzaWduYXR1cmUgdHJpZ2dlcihnZXN0dXJlLCBldmVudERhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmKFV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBlbmFibGVcbiAgICogQHNpZ25hdHVyZSBlbmFibGUoc3RhdGUpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVuYWJsZSBvciBkaXNhYmxlIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj5qSc55+l44KS5pyJ5Yq55YyWL+eEoeWKueWMluOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICogICBbZW5dU3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgZW5hYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd5pyJ5Yq544Gr44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gc3RhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZVxuICAgKiBAc2lnbmF0dXJlIGRpc3Bvc2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW5kIGRlc3Ryb3kgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGluc3RhbmNlLlsvZW5dXG4gICAqICBbamFd44GT44Gu44Kk44Oz44K544K/44Oz44K544Gn44Gu44K444Kn44K544OB44Oj44Gu5qSc55+l44KE44CB44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS5YWo44Gm6Kej6Zmk44GX44Gm5buD5qOE44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIGksIGVoO1xuXG4gICAgLy8gdW5kbyBhbGwgY2hhbmdlcyBtYWRlIGJ5IHN0b3BfYnJvd3Nlcl9iZWhhdmlvclxuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCBmYWxzZSk7XG5cbiAgICAvLyB1bmJpbmQgYWxsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgIGZvcihpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgaWYoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnRGlzdGFuY2VDb3JyZWN0aW9uICYmIGV2LmRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgIGlmKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICApKSB7XG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNTAsXG4gICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICogVXNlZnVsIHRvIGF2b2lkIGEgamVyay1zdGFydGluZyBkcmFnLCB3aGljaCBjYW4gbWFrZSBmaW5lLWFkanVzdG1lbnRzXG4gICAgICAgICAqIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNYXhUb3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggaXQsIGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tIb3Jpem9udGFsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2FtZSBhcyBgZHJhZ0Jsb2NrSG9yaXpvbnRhbGAsIGJ1dCBmb3IgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja1ZlcnRpY2FsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcbiAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrVG9BeGlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcbiAgICAgIH1cbiAgICB9O1xuICB9KSgnZHJhZycpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAgICogb25seSB1c2FibGUgaWYgeW91IGtub3cgd2hhdCB5b3VyIGRvaW5nLi4uXG4gICAqXG4gICAqIEBjbGFzcyBHZXN0dXJlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5HZXN0dXJlID0ge1xuICAgIG5hbWU6ICdnZXN0dXJlJyxcbiAgICBpbmRleDogMTMzNyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAgICpcbiAgICogQGNsYXNzIEhvbGRcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBob2xkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGlmKGV2LmRpc3RhbmNlID4gb3B0aW9ucy5ob2xkVGhyZXNob2xkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuSG9sZCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRpbWVvdXQ6IDUwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGhyZXNob2xkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBob2xkR2VzdHVyZVxuICAgIH07XG4gIH0pKCdob2xkJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgcmVsZWFzZWQgZnJvbSB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgUmVsZWFzZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJlbGVhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuUmVsZWFzZSA9IHtcbiAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgaW5kZXg6IEluZmluaXR5LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gICAqIGBgYGBcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqICB9KTtcbiAgICogYGBgYFxuICAgKlxuICAgKiBAY2xhc3MgU3dpcGVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZih0b3VjaGVzIDwgb3B0aW9ucy5zd2lwZU1pblRvdWNoZXMgfHxcbiAgICAgICAgICB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICAgKlxuICAgKiBAY2xhc3MgVGFwXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBkb3VibGV0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgaWYoIVV0aWxzLmluU3RyKGV2LnNyY0V2ZW50LnR5cGUsICdjYW5jZWwnKSAmJiBldi5kZWx0YVRpbWUgPCBvcHRpb25zLnRhcE1heFRpbWUgJiYgIWhhc01vdmVkKSB7XG4gICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xuICAgICAgICAgIHNpbmNlUHJldiA9IHByZXYgJiYgcHJldi5sYXN0RXZlbnQgJiYgZXYudGltZVN0YW1wIC0gcHJldi5sYXN0RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgIGRpZERvdWJsZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgIGlmKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwMCxcbiAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgfVxuICAgIH07XG4gIH0pKCd0YXAnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBUb3VjaFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRvdWNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudE1vdXNlICYmIGV2LnBvaW50ZXJUeXBlID09IFBPSU5URVJfTU9VU0UpIHtcbiAgICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICpcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJvdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAvLyBhdCBsZWFzdCBtdWx0aXRvdWNoXG4gICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgaWYocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8IDIpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNDUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5Sb3RhdGlvbjogMVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgIH07XG4gIH0pKCd0cmFuc2Zvcm0nKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdHVyZURldGVjdG9yO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5wbGF0Zm9ybVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBtZXRob2RzIHRvIGRldGVjdCBjdXJyZW50IHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV3nj77lnKjlrp/ooYzjgZXjgozjgabjgYTjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICovXG5jbGFzcyBQbGF0Zm9ybSB7XG5cbiAgLyoqXG4gICAqIEFsbCBlbGVtZW50cyB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIHRoZSBhcHAgd2FzIHJ1bm5pbmcgb24gdGhpcyBwbGF0Zm9ybS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlbmRlclBsYXRmb3JtID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgKiBAc2lnbmF0dXJlIHNlbGVjdChwbGF0Zm9ybSlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwbGF0Zm9ybSBOYW1lIG9mIHRoZSBwbGF0Zm9ybS5cbiAgICogICBbZW5dUG9zc2libGUgdmFsdWVzIGFyZTogXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIgb3IgXCJ3cFwiLlsvZW5dXG4gICAqICAgW2phXVwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiLCBcIndwXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V0cyB0aGUgcGxhdGZvcm0gdXNlZCB0byByZW5kZXIgdGhlIGVsZW1lbnRzLiBVc2VmdWwgZm9yIHRlc3RpbmcuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44KS5o+P55S744GZ44KL44Gf44KB44Gr5Yip55So44GZ44KL44OX44Op44OD44OI44OV44Kp44O844Og5ZCN44KS6Kit5a6a44GX44G+44GZ44CC44OG44K544OI44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIHNlbGVjdChwbGF0Zm9ybSkge1xuICAgIGlmICh0eXBlb2YgcGxhdGZvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IHBsYXRmb3JtLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICAgKiAgIFtqYV1Db3Jkb3Zh5YaF44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV2ViVmlldygpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV2ViVmlldygpIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgZG9tIGNvbnRlbnRzIGxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEod2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwIHx8IHdpbmRvdy5QaG9uZUdhcCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1xuICAgKiBAc2lnbmF0dXJlIGlzSU9TKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgaU9TLlsvZW5dXG4gICAqICAgW2phXWlPU+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUygpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2lvcyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnd3AnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAvV2luMzJOVHxXaW5DRS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9XaW5kb3dzIFBob25lfElFTW9iaWxlfFdQRGVza3RvcC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob3MgaXNJUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUuWy9lbl1cbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNCbGFja0JlcnJ5XG4gICAqIEBzaWduYXR1cmUgaXNCbGFja0JlcnJ5KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkuWy9lbl1cbiAgICogICBbamFdQmxhY2tCZXJyeeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0JsYWNrQmVycnkoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdibGFja2JlcnJ5JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlcmFcbiAgICogQHNpZ25hdHVyZSBpc09wZXJhKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBPcGVyYS5bL2VuXVxuICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09wZXJhKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnb3BlcmEnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0ZpcmVmb3hcbiAgICogQHNpZ25hdHVyZSBpc0ZpcmVmb3goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEZpcmVmb3guWy9lbl1cbiAgICogICBbamFdRmlyZWZveOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZpcmVmb3goKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdmaXJlZm94JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuWy9lbl1cbiAgICogICBbamFdU2FmYXJp5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU2FmYXJpKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnc2FmYXJpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNDaHJvbWVcbiAgICogQHNpZ25hdHVyZSBpc0Nocm9tZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21lLlsvZW5dXG4gICAqICAgW2phXUNocm9tZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0Nocm9tZSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2Nocm9tZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cuY2hyb21lICYmICEoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApICYmICEobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJRVxuICAgKiBAc2lnbmF0dXJlIGlzSUUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyLlsvZW5dXG4gICAqICAgW2phXUludGVybmV0IEV4cGxvcmVy5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSUUoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0VkZ2VcbiAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEVkZ2UuWy9lbl1cbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0VkZ2UoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdlZGdlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TN2Fib3ZlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxuICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TN2Fib3ZlKCkge1xuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuICgvaU9TL2kudGVzdChkZXZpY2UucGxhdGZvcm0pICYmIChwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3KSk7XG4gICAgfSBlbHNlIGlmKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc3QgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vYmlsZU9TKCkge1xuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XG4gICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcbiAgICAgIHJldHVybiAnd3AnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRJT1NEZXZpY2UoKSB7XG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwb2QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnbmEnO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQbGF0Zm9ybSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5ub3RpZmljYXRpb25cbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY3JlYXRlIGRpZmZlcmVudCBraW5kcyBvZiBhbGVydCBkaWFsb2dzLiBUaGVyZSBhcmUgdGhyZWUgbWV0aG9kcyBhdmFpbGFibGU6XG4gKlxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uYWxlcnQoKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLnByb21wdCgpYFxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdIZWxsbywgd29ybGQhJyk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKCdBcmUgeW91IHJlYWR5PycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xuICogICAgICAgaWYgKGFuc3dlciA9PT0gMSkge1xuICogICAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdMZXRcXCdzIGdvIScpO1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLnByb21wdCgnSG93IG9sZCBhcmUgPycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xuICogICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnWW91IGFyZSAnICsgYWdlICsgJyB5ZWFycyBvbGQuJyk7XG4gKiAgICAgfVxuICogICApO1xuICovXG5jb25zdCBub3RpZmljYXRpb24gPSB7fTtcblxubm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyA9IGZ1bmN0aW9uKHRpdGxlLCBtZXNzYWdlLFxuICBidXR0b25MYWJlbHMsIHByaW1hcnlCdXR0b25JbmRleCwgbW9kaWZpZXIsIGFuaW1hdGlvbiwgaWQsIGNhbGxiYWNrLFxuICBtZXNzYWdlSXNIVE1MLCBjYW5jZWxhYmxlLCBwcm9tcHREaWFsb2csIGF1dG9mb2N1cywgcGxhY2Vob2xkZXIsXG4gIGRlZmF1bHRWYWx1ZSwgc3VibWl0T25FbnRlciwgY29tcGlsZSkge1xuXG4gIGNvbXBpbGUgPSBjb21waWxlIHx8IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0OyB9O1xuXG4gIGNvbnN0IHRpdGxlRWxlbWVudEhUTUwgPSB0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnID8gJzxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj48L2Rpdj4nIDogJyc7XG5cblxuICBsZXQgZGlhbG9nRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxvbnMtYWxlcnQtZGlhbG9nPlxuICAgICR7dGl0bGVFbGVtZW50SFRNTH1cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPjwvZGl2PlxuICA8L29ucy1hbGVydC1kaWFsb2c+YCk7XG5cbiAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShkaWFsb2dFbGVtZW50KTtcblxuICBpZiAoaWQpIHtcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gIH1cblxuICBsZXQgdGl0bGVFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gIGxldCBtZXNzYWdlRWxlbWVudCA9IGRpYWxvZ0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gIGxldCBmb290ZXJFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWZvb3RlcicpO1xuICBsZXQgaW5wdXRFbGVtZW50O1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICByZXN1bHQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXN1bHQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcmVzdWx0LnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG5cbiAgbW9kaWZpZXIgPSBtb2RpZmllciB8fCBkaWFsb2dFbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcblxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJykge1xuICAgIHRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICB9XG5cbiAgdGl0bGVFbGVtZW50ID0gbnVsbDtcblxuICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJywgYW5pbWF0aW9uKTtcblxuICBpZiAobWVzc2FnZUlzSFRNTCkge1xuICAgIG1lc3NhZ2VFbGVtZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICB9XG5cbiAgaWYgKHByb21wdERpYWxvZykge1xuICAgIGlucHV0RWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGlucHV0IGNsYXNzPVwidGV4dC1pbnB1dCB0ZXh0LWlucHV0LS11bmRlcmJhclwiIHR5cGU9XCJ0ZXh0XCI+PC9pbnB1dD4nKTtcblxuICAgIGlmIChtb2RpZmllcikge1xuICAgICAgaW5wdXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoYHRleHQtaW5wdXQtLSR7bW9kaWZpZXJ9YCk7XG4gICAgfVxuXG4gICAgaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlcik7XG4gICAgaW5wdXRFbGVtZW50LnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIGlucHV0RWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBpbnB1dEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xuXG4gICAgbWVzc2FnZUVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KTtcblxuICAgIGlmIChzdWJtaXRPbkVudGVyKSB7XG4gICAgICBpbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICBkaWFsb2dFbGVtZW50LmhpZGUoe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nRWxlbWVudCk7XG5cbiAgY29tcGlsZShkaWFsb2dFbGVtZW50KTtcblxuICBpZiAoYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyKSB7XG4gICAgZm9vdGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUnKTtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICBsZXQgYnV0dG9uRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj48L2J1dHRvbj4nKTtcbiAgICBidXR0b25FbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGJ1dHRvbkxhYmVsc1tpXSkpO1xuXG4gICAgaWYgKGkgPT0gcHJpbWFyeUJ1dHRvbkluZGV4KSB7XG4gICAgICBidXR0b25FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCcpO1xuICAgIH1cblxuICAgIGlmIChidXR0b25MYWJlbHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25DbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgYnV0dG9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIGZhbHNlKTtcblxuICAgICAgZGlhbG9nRWxlbWVudC5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChwcm9tcHREaWFsb2cpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhpKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBpbnB1dEVsZW1lbnQgPSBidXR0b25FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGJ1dHRvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSk7XG4gICAgZm9vdGVyRWxlbWVudC5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbkxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGNyZWF0ZUJ1dHRvbihpKTtcbiAgfVxuXG4gIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgZGlhbG9nRWxlbWVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICBkaWFsb2dFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmNlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb21wdERpYWxvZykge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdCgtMSk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkaWFsb2dFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaW5wdXRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIGRpYWxvZ0VsZW1lbnQuc2hvdyh7XG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGlucHV0RWxlbWVudCAmJiBwcm9tcHREaWFsb2cgJiYgYXV0b2ZvY3VzKSB7XG4gICAgICAgIGlucHV0RWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbWVzc2FnZUVsZW1lbnQgPSBmb290ZXJFbGVtZW50ID0gbnVsbDtcblxuICBpZiAobW9kaWZpZXIpIHtcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAnJyk7XG4gICAgZGlhbG9nRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xufTtcblxubm90aWZpY2F0aW9uLl9hbGVydE9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsOiAnT0snLFxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGVydCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKFxuICAgIG9wdGlvbnMudGl0bGUsXG4gICAgb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUwsXG4gICAgW29wdGlvbnMuYnV0dG9uTGFiZWxdLFxuICAgIDAsXG4gICAgb3B0aW9ucy5tb2RpZmllcixcbiAgICBvcHRpb25zLmFuaW1hdGlvbixcbiAgICBvcHRpb25zLmlkLFxuICAgIG9wdGlvbnMuY2FsbGJhY2ssXG4gICAgIW9wdGlvbnMubWVzc2FnZSA/IHRydWUgOiBmYWxzZSxcbiAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnJywgJycsIGZhbHNlLFxuICAgIG9wdGlvbnMuY29tcGlsZVxuICApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFsZXJ0XG4gKiBAc2lnbmF0dXJlIGFsZXJ0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovmloflrZfliJfjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VIVE1MXVxuICogICBbZW5dQWxlcnQgbWVzc2FnZSBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5idXR0b25MYWJlbF1cbiAqICAgW2VuXUxhYmVsIGZvciBjb25maXJtYXRpb24gYnV0dG9uLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSBub3RpZmljYXRpb24uX2FsZXJ0T3JpZ2luYWw7XG5cbm5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsczogWydDYW5jZWwnLCAnT0snXSxcbiAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IDEsXG4gICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgdGl0bGU6ICdDb25maXJtJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICB9O1xuXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtIGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXG4gICAgb3B0aW9ucy50aXRsZSxcbiAgICBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCxcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyxcbiAgICBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCxcbiAgICBvcHRpb25zLm1vZGlmaWVyLFxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxuICAgIG9wdGlvbnMuaWQsXG4gICAgb3B0aW9ucy5jYWxsYmFjayxcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIG9wdGlvbnMuY2FuY2VsYWJsZSxcbiAgICBmYWxzZSwgZmFsc2UsICcnLCAnJywgZmFsc2UsXG4gICAgb3B0aW9ucy5jb21waWxlXG4gICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29uZmlybVxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5kZXggb2YgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXUNvbmZpcm1hdGlvbiBxdWVzdGlvbi5bL2VuXVxuICogICBbamFd56K66KqN44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL44Oh44OD44K744O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXURpYWxvZyBjb250ZW50IGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuIElmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzaW5nIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQ29uZmlybVwiYC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJDb25maXJtXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dXG4gKiAgICAgRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5cbiAqICAgICBBcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGlzIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBrumWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeaKvOOBleOCjOOBn+ODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOBjOa4oeOBleOCjOOBvuOBmeOAglxuICogICAgIOOCguOBl+ODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBry0x44GM5rih44GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24uXG4gKiAgICAgVGhlIGRlZmF1bHQgYnV0dG9uIGxhYmVscyBhcmUgYFwiQ2FuY2VsXCJgIGFuZCBgXCJPS1wiYCBidXQgdGhleSBjYW4gYmUgY3VzdG9taXplZC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0ob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjgavnorroqo3jgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjg4fjgqrjg6vjgajjga7jg5zjgr/jg7Pjg6njg5njg6vjga/jgIFcIkNhbmNlbFwi44GoXCJPS1wi44Gn44GZ44GM44CB44GT44KM44Gv44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gn44Kr44K544K/44Oe44Kk44K644Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uY29uZmlybSA9IG5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsO1xuXG5ub3RpZmljYXRpb24uX3Byb21wdE9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsOiAnT0snLFxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9LFxuICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICBzdWJtaXRPbkVudGVyOiB0cnVlXG4gIH07XG5cbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9tcHQgZGlhbG9nIG11c3QgY29udGFpbiBhIG1lc3NhZ2UuJyk7XG4gIH1cblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhcbiAgICBvcHRpb25zLnRpdGxlLFxuICAgIG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MLFxuICAgIFtvcHRpb25zLmJ1dHRvbkxhYmVsXSxcbiAgICAwLFxuICAgIG9wdGlvbnMubW9kaWZpZXIsXG4gICAgb3B0aW9ucy5hbmltYXRpb24sXG4gICAgb3B0aW9ucy5pZCxcbiAgICBvcHRpb25zLmNhbGxiYWNrLFxuICAgICFvcHRpb25zLm1lc3NhZ2UgPyB0cnVlIDogZmFsc2UsXG4gICAgb3B0aW9ucy5jYW5jZWxhYmxlLFxuICAgIHRydWUsXG4gICAgb3B0aW9ucy5hdXRvZm9jdXMsXG4gICAgb3B0aW9ucy5wbGFjZWhvbGRlcixcbiAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcbiAgICBvcHRpb25zLnN1Ym1pdE9uRW50ZXIsXG4gICAgb3B0aW9ucy5jb21waWxlXG4gICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcHJvbXB0XG4gKiBAc2lnbmF0dXJlIHByb21wdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXVByb21wdCBxdWVzdGlvbi5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL44Oh44OD44K744O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXURpYWxvZyBjb250ZW50IGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxuICogICBbZW5dTGFiZWwgZm9yIGNvbmZpcm1hdGlvbiBidXR0b24uIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGZhbHNlLiBXaGVuIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCB3aWxsIGJlIGNsb3NlZCBpZiB0aGUgdXNlciB0YXBzIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzZXMgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryBmYWxzZSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryBcIkFsZXJ0XCIg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cbiAqICAgW2VuXVBsYWNlaG9sZGVyIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OX44Os44O844K544Ob44Or44OA44Gr6KGo56S644GZ44KL44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXG4gKiAgIFtlbl1EZWZhdWx0IHZhbHVlIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OH44OV44Kp44Or44OI44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxuICogICBbZW5dQXV0b2ZvY3VzIHRoZSBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxuICogICBbamFdaW5wdXTopoHntKDjgavoh6rli5XnmoTjgavjg5Xjgqnjg7zjgqvjgrnjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXVxuICogICAgIEZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuXG4gKiAgICAgQXJndW1lbnQgZm9yIHRoZSBmdW5jdGlvbiBpcyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkIG9yIGBudWxsYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICogICAgIOmWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeOCpOODs+ODl+ODg+ODiOimgee0oOOBruS4reOBruWApOOBjOa4oeOBleOCjOOBvuOBmeOAguODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBr+OAgW51bGzjgYzmuKHjgZXjgozjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXUVudGVy44GM5oq844GV44KM44Gf6Zqb44Gr44Gd44GuZm9ybeOCknN1Ym1pdOOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHdpdGggYSBwcm9tcHQgdG8gYXNrIHRoZSB1c2VyIGEgcXVlc3Rpb24uXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBq+WFpeWKm+OCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnByb21wdCA9IG5vdGlmaWNhdGlvbi5fcHJvbXB0T3JpZ2luYWw7XG5cbmV4cG9ydCBkZWZhdWx0IG5vdGlmaWNhdGlvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuY29uc3QgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gIF92YXJpYWJsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAqL1xuICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyYWlibGUuXG4gICAqL1xuICByZW1vdmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gIH0sXG4gIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBsZXQgYyxcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBlbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gcGFydC5jaGFyQXQoaSk7XG5cbiAgICAgIGlmIChjID09PSAnJCcgJiYgcGFydC5jaGFyQXQoaSArIDEpID09PSAneycpIHtcbiAgICAgICAgaWYgKGluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGVkIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGk7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgaWYgKCFpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ30gbXVzdCBiZSBwcmVjZWVkZWQgYnkgJHsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaSArIDE7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBwYXJ0Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfSxcbiAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBjb25zdCByZSA9IC9eXFwkeyguKj8pfSQvLFxuICAgICAgbWF0Y2ggPSB0b2tlbi5tYXRjaChyZSk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHJldHVybiBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9LFxuICBfcmVwbGFjZVRva2VuczogZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAodGhpcy5fcmVwbGFjZVRva2VuLmJpbmQodGhpcykpO1xuICB9LFxuICBfcGFyc2VFeHByZXNzaW9uOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24uc3BsaXQoJywnKVxuICAgICAgLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLm1hcCh0aGlzLl9wYXJzZVBhcnQuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAodGhpcy5fcmVwbGFjZVRva2Vucy5iaW5kKHRoaXMpKVxuICAgICAgLm1hcCgocGFydCkgPT4gcGFydC5qb2luKCcnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uIEFuIHBhZ2UgYXR0cmlidXRlIGV4cHJlc3Npb24uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZXZhbHVhdGU6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgZGVmYXVsdCB2YXJpYWJsZXMuXG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnbW9iaWxlT1MnLCBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKTtcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdpT1NEZXZpY2UnLCBwbGF0Zm9ybS5nZXRJT1NEZXZpY2UoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgncnVudGltZScsICgpID0+IHtcbiAgcmV0dXJuIHBsYXRmb3JtLmlzV2ViVmlldygpID8gJ2NvcmRvdmEnIDogJ2Jyb3dzZXInO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcblxuY29uc3QgaW50ZXJuYWwgPSB7fTtcblxuaW50ZXJuYWwuY29uZmlnID0ge1xuICBhdXRvU3RhdHVzQmFyRmlsbDogdHJ1ZSxcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZVxufTtcblxuaW50ZXJuYWwubnVsbEVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuaW50ZXJuYWwuaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIHJldHVybiAhIWludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwgPSBodG1sID0+IHtcbiAgaHRtbCA9ICgnJyArIGh0bWwpLnRyaW0oKTtcblxuICBpZiAoIWh0bWwubWF0Y2goL148b25zLXBhZ2UvKSkge1xuICAgIGh0bWwgPSAnPG9ucy1wYWdlIF9tdXRlZD4nICsgaHRtbCArICc8L29ucy1wYWdlPic7XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn07XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5pbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCA9IGFjdGlvbiA9PiB7XG4gIGNvbnN0IG9uUmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKGludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIoKSkge1xuICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG9uUmVhZHkpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gIH0gZWxzZSBpZiAoWydjb21wbGV0ZScsICdpbnRlcmFjdGl2ZSddLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPT09IC0xKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgb25SZWFkeSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9uUmVhZHkoKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiYgcGxhdGZvcm0uaXNXZWJWaWV3KCkgJiYgcGxhdGZvcm0uaXNJT1M3YWJvdmUoKTtcblxuaW50ZXJuYWwudGVtcGxhdGVTdG9yZSA9IHtcbiAgX3N0b3JhZ2U6IHt9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge1N0cmluZy9udWxsfSB0ZW1wbGF0ZVxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHNldChrZXksIHRlbXBsYXRlKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldID0gdGVtcGxhdGU7XG4gIH1cbn07XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdfdGVtcGxhdGVsb2FkZWQnLCBmdW5jdGlvbihlKSB7XG4gIGlmIChlLnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRlbXBsYXRlJykge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KGUudGVtcGxhdGVJZCwgZS50ZW1wbGF0ZSk7XG4gIH1cbn0sIGZhbHNlKTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCJdJyk7XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIocXVlcnkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZXMgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS50ZXh0Q29udGVudCk7XG4gICAgfVxuICB9XG59LCBmYWxzZSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZSA9IGludGVybmFsLnRlbXBsYXRlU3RvcmUuZ2V0KHBhZ2UpO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHR5cGVvZiBjYWNoZSA9PT0gJ3N0cmluZycgPyBjYWNoZSA6IGNhY2hlWzFdO1xuICAgICAgICByZXNvbHZlKGh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYWdlLCB0cnVlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgY29uc3QgaHRtbCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICAgIHJlamVjdChodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYWdlIGlzIG5vdCBmb3VuZDogJHtwYWdlfWApO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICBjb25zdCBwYWdlcyA9IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmV2YWx1YXRlKHBhZ2UpO1xuXG4gIGNvbnN0IGdldFBhZ2UgPSAocGFnZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTXVzdCBzcGVjaWZ5IGEgcGFnZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmMocGFnZSlcbiAgICAgIC50aGVuKFxuICAgICAgICBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC50aGVuKGh0bWwgPT4gaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xuICB9O1xuXG4gIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yRmFjdG9yeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmFuaW1hdG9ycyBUaGUgZGljdGlvbmFyeSBmb3IgYW5pbWF0b3IgY2xhc3Nlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmJhc2VDbGFzcyBUaGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmJhc2VDbGFzc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuZGVmYXVsdEFuaW1hdGlvbl0gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuX2FuaW1hdG9ycyA9IG9wdHMuYW5pbWF0b3JzO1xuICAgIHRoaXMuX2Jhc2VDbGFzcyA9IG9wdHMuYmFzZUNsYXNzO1xuICAgIHRoaXMuX2Jhc2VDbGFzc05hbWUgPSBvcHRzLmJhc2VDbGFzc05hbWUgfHwgb3B0cy5iYXNlQ2xhc3MubmFtZTtcbiAgICB0aGlzLl9hbmltYXRpb24gPSBvcHRzLmRlZmF1bHRBbmltYXRpb24gfHwgJ2RlZmF1bHQnO1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGFuaW1hdGlvbjogJyArIHRoaXMuX2FuaW1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyhqc29uU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBzZXRBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXSBUaGUgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdIFRoZSBhbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdEFuaW1hdG9yIFRoZSBkZWZhdWx0IGFuaW1hdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gYW5pbWF0b3IgaW5zdGFuY2VcbiAgICovXG4gIG5ld0FuaW1hdG9yKG9wdGlvbnMgPSB7fSwgZGVmYXVsdEFuaW1hdG9yKSB7XG5cbiAgICBsZXQgYW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbmltYXRpb247XG4gICAgfVxuXG4gICAgbGV0IEFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBBbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yc1tvcHRpb25zLmFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKCFBbmltYXRvciAmJiBkZWZhdWx0QW5pbWF0b3IpIHtcbiAgICAgIGFuaW1hdG9yID0gZGVmYXVsdEFuaW1hdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBBbmltYXRvciA9IEFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dO1xuXG4gICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICAgIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPyB7ZHVyYXRpb246IDAsIGRlbGF5OiAwfSA6IHt9XG4gICAgICApO1xuXG4gICAgICBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb25PcHRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBhbmltYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbmltYXRvciA9IG5ldyBhbmltYXRvcihhbmltYXRpb25PcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYW5pbWF0b3IgaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJyArIHRoaXMuX2Jhc2VDbGFzc05hbWUgKyAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LmFkZChrbGFzcykpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBjbGFzc0xpc3QucmVtb3ZlKGtsYXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoZSwgcykgPT4gKGUubWF0Y2hlcyB8fCBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlLm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGUsIHMpO1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3IgaW4gc2NoZW1lKSB7XG4gICAgICBpZiAoc2NoZW1lLmhhc093blByb3BlcnR5KHNlbGVjdG9yKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSA/IFtlbGVtZW50XSA6IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgdGFyZ2V0RWxlbWVudHNbaV0uY2xhc3NMaXN0LCBzY2hlbWVbc2VsZWN0b3JdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBvbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICByZXR1cm4gTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xuICAgICAgcmVtb3ZlZDogW10sXG4gICAgICBhZGRlZDogTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKVxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllci50cmltKCkuc3BsaXQoLyArLykuZmlsdGVyKHRva2VuID0+IHRva2VuICE9PSAnJyk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcblxuLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbmNvbnN0IHNjaGVtZSA9IHtcbiAgY3JlYXRlSXRlbUNvbnRlbnQ6ICAge3R5cGU6ICdmdW5jdGlvbicsIHJldHVybnM6IEVsZW1lbnR9LFxuICBjb3VudEl0ZW1zOiAgICAgICAgICB7dHlwZTogJ2Z1bmN0aW9uJywgcmV0dXJuczogJ251bWJlcid9LFxuICBjYWxjdWxhdGVJdGVtSGVpZ2h0OiB7dHlwZTogJ2Z1bmN0aW9uJywgcmV0dXJuczogJ251bWJlcid9LFxuICB1cGRhdGVJdGVtQ29udGVudDogICB7dHlwZTogJ2Z1bmN0aW9uJywgc2FmZUNhbGw6IHRydWV9LFxuICBkZXN0cm95OiAgICAgICAgICAgICB7dHlwZTogJ2Z1bmN0aW9uJywgc2FmZUNhbGw6IHRydWV9LFxuICBkZXN0cm95SXRlbTogICAgICAgICB7dHlwZTogJ2Z1bmN0aW9uJywgc2FmZUNhbGw6IHRydWV9LFxuICBfcmVuZGVyOiAgICAgICAgICAgICB7dHlwZTogJ2Z1bmN0aW9uJywgc2FmZUNhbGw6IHRydWV9XG59O1xuLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcblxuICBjb25zdHJ1Y3Rvcih1c2VyRGVsZWdhdGUsIHRlbXBsYXRlRWxlbWVudCA9IG51bGwpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1dGlsLnZhbGlkYXRlZCgnZGVsZWdhdGUnLCB1c2VyRGVsZWdhdGUsICdvYmplY3QnKTtcbiAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB1dGlsLnZhbGlkYXRlZCgndGVtcGxhdGVFbGVtZW50JywgdGVtcGxhdGVFbGVtZW50LCBbRWxlbWVudCwgJ251bGwnXSk7XG4gIH1cblxuICBnZXQgaXRlbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLml0ZW1IZWlnaHQ7XG4gIH1cblxuICBfdmFsaWRhdGVkKGtleSwgX3NjaGVtZSA9IHNjaGVtZSkge1xuICAgIHJldHVybiB1dGlsLnZhbGlkYXRlZChrZXksIG51bGwsIHV0aWwuZXh0ZW5kKHt9LCBfc2NoZW1lW2tleV0sIHtcbiAgICAgIGR5bmFtaWNDYWxsOiB7b2JqZWN0OiB0aGlzLl91c2VyRGVsZWdhdGUsIGtleX1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1JlbmRlckZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlciAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBfcmVuZGVyKGl0ZW1zLCBoZWlnaHQpIHtcbiAgICB0aGlzLl92YWxpZGF0ZWQoJ19yZW5kZXInKShpdGVtcywgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBBIGZ1bmN0aW9uIHRoYXQgdGFrZSBpdGVtIG9iamVjdCBhcyBwYXJhbWV0ZXIuXG4gICAqL1xuICBwcmVwYXJlSXRlbShpbmRleCwgZG9uZSkge1xuICAgIHJldHVybiBkb25lKHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuX3ZhbGlkYXRlZCgnY3JlYXRlSXRlbUNvbnRlbnQnKShpbmRleCwgdGhpcy5fdGVtcGxhdGVFbGVtZW50KVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlZCgnY291bnRJdGVtcycpKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbS5lbGVtZW50XG4gICAqL1xuICB1cGRhdGVJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlZCgndXBkYXRlSXRlbUNvbnRlbnQnKShpbmRleCwgaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZWQoJ2NhbGN1bGF0ZUl0ZW1IZWlnaHQnKShpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqL1xuICBkZXN0cm95SXRlbShpbmRleCwgaXRlbSkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZWQoJ2Rlc3Ryb3lJdGVtJykoaW5kZXgsIGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3ZhbGlkYXRlZCgnZGVzdHJveScpKCk7XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZSBjb3JlIGZ1bmN0aW9ucyBmb3Igb25zLWxhenktcmVwZWF0LlxuICovXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB3cmFwcGVyRWxlbWVudFxuICAgKiBAcGFyYW0ge0xhenlSZXBlYXREZWxlZ2F0ZX0gZGVsZWdhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdyYXBwZXJFbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSB1dGlsLnZhbGlkYXRlZCgnZGVsZWdhdGUnLCBkZWxlZ2F0ZSwgTGF6eVJlcGVhdERlbGVnYXRlKTtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLnBhZ2VfX2NvbnRlbnQnKTtcblxuICAgIGlmICghdGhpcy5fcGFnZUNvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25zLWxhenktcmVwZWF0IG11c3QgYmUgYSBkZXNjZW5kYW50IG9mIGFuIDxvbnMtcGFnZT4gb3IgYW4gZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl90b3BQb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghL211c3QgYmUgKGF8YW4gaW5zdGFuY2Ugb2YpIGZ1bmN0aW9uLy50ZXN0KCcnICsgZSkpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICB9XG5cbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgIHRoaXMuX2RlbGVnYXRlLnByZXBhcmVJdGVtKDAsICh7ZWxlbWVudH0pID0+IHtcbiAgICAgIGlmICh0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHN0YXRpY0l0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgfHwgdGhpcy5faXRlbUhlaWdodDtcbiAgfVxuXG4gIF9jb3VudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gIH1cblxuICBfZ2V0SXRlbUhlaWdodChpKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBfcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrSXRlbUhlaWdodCh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0luVmlldygpO1xuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLl9yZW5kZXIoaXRlbXMsIHRoaXMuX2xpc3RIZWlnaHQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qga2VlcCA9IHt9O1xuXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaXRlbSk7XG4gICAgICBrZWVwW2l0ZW0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fbGlzdEhlaWdodCArICdweCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0uaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0udG9wXG4gICAqL1xuICBfcmVuZGVyRWxlbWVudCh7aW5kZXgsIHRvcH0pIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLnVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pOyAvLyB1cGRhdGUgaWYgaXQgZXhpc3RzXG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5wcmVwYXJlSXRlbShpbmRleCwgKGl0ZW0pID0+IHtcbiAgICAgIHV0aWwuZXh0ZW5kKGl0ZW0uZWxlbWVudC5zdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBfcmVtb3ZlRWxlbWVudChpbmRleCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcblxuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgIGlmIChpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gIH1cblxuICBfcmVtb3ZlQWxsRWxlbWVudHMoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4gdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSB0aGlzLl9pdGVtQ291bnQgLSAxO1xuXG4gICAgaWYgKHRoaXMuc3RhdGljSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KC1jdXJyZW50IC8gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciBpbmRleCBhdCB0b3Agb2Ygc2NyZWVuIHNvIHdlIGNhbiBzcGVlZCB1cCByZW5kZXJpbmcuXG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnQgKyB0aGlzLl90b3BQb3NpdGlvbnNbbWlkZGxlXTtcblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwICYmIHZhbHVlICsgdGhpcy5fZ2V0SXRlbUhlaWdodChtaWRkbGUpID4gMCkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPj0gMCkge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucygpIHtcbiAgICBjb25zdCBsID0gTWF0aC5taW4odGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCwgdGhpcy5faXRlbUNvdW50KTtcbiAgICB0aGlzLl90b3BQb3NpdGlvbnNbMF0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAxLCBsOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaSAtIDFdICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbXNJblZpZXcoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIGNvbnN0IGxpbWl0ID0gNCAqIHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcblxuICAgIGlmIChjb3VudCAhPT0gdGhpcy5faXRlbUNvdW50KXtcbiAgICAgIHRoaXMuX2l0ZW1Db3VudCA9IGNvdW50O1xuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoKTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IE1hdGgubWF4KDAsIHRoaXMuX2NhbGN1bGF0ZVN0YXJ0SW5kZXgob2Zmc2V0KSAtIDMwKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgaXRlbXMucHVzaCh7dG9wLCBpbmRleDogaX0pO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2xpc3RIZWlnaHQgPSB0b3A7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBfZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBfZG91YmxlRmlyZU9uVG91Y2hlbmQoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fZGVib3VuY2UodGhpcy5fcmVuZGVyLmJpbmQodGhpcyksIDEwMCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdXRpbC5iaW5kTGlzdGVuZXJzKHRoaXMsIFsnX29uQ2hhbmdlJywgJ19kb3VibGVGaXJlT25Ub3VjaGVuZCddKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fZGVib3VuY2UodGhpcy5fYm91bmRPbkNoYW5nZSwgMzApO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kLCB0cnVlKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IHtMYXp5UmVwZWF0UHJvdmlkZXIsIExhenlSZXBlYXREZWxlZ2F0ZX0gZnJvbSAnLi9sYXp5LXJlcGVhdCc7XG5cbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbmludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcblxuICAvKipcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICogQGNhdGVnb3J5IHV0aWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBjb25zdCBvYmogPSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzLlsvZW5dXG4gICAgICogICBbamFd44OH44OQ44Kk44K544Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd54++5Zyo44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAc2lnbmF0dXJlIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgZPjga7jgqTjg5njg7Pjg4jjgYznmbrngavjgZXjgozjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvbmNlXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCdzIG9ubHkgdHJpZ2dlcmVkIG9uY2UuWy9lbl1cbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHNpZ25hdHVyZSBvZmYoZXZlbnROYW1lLCBbbGlzdGVuZXJdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgdHlwZSB3aWxsIGJlIHJlbW92ZWQuWy9lbl1cbiAgICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAguOCguOBl+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBquOBi+OBo+OBn+WgtOWQiOOBq+OBr+OAgeOBneOBruOCpOODmeODs+ODiOOBq+e0kOOBpeOBj+WFqOOBpuOBruOCpOODmeODs+ODiOODquOCueODiuODvOOBjOWJiumZpOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd5YmK6Zmk44GZ44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8vIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0byBkZXRlY3QgaWYgd2hldGhlciBjdXJyZW50IHNjcmVlbiBpcyBwb3J0cmFpdCBvciBub3RcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAc2lnbmF0dXJlIGlzUG9ydHJhaXQoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0sXG5cbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHRoaXMuX2lzUG9ydHJhaXQoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIG9mIEFuZHJvaWQgaW5jb25zaXN0ZW5jeS5cbiAgICAgIGxldCBuSXRlciA9IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbkl0ZXIrKztcblxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcbiAgICAgICAgICAgKCFpc1BvcnRyYWl0ICYmIHcgPj0gaCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfVxuICB9O1xuXG4gIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlKCkuX2luaXQoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG5jb25zdCBvblNob3cgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSB0cnVlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcbn07XG5cbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2hpZGUnKTtcbn07XG5cbmNvbnN0IGJpbmRFdmVudHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbm1vc2UvY29yZG92YS1rZXlib2FyZC9ibG9iLzk1ZjNkYTNhMzhkOGY4ZTFmYTQxZmJmNDAxNDUzNTJjMTM1MzVhMDAvUkVBRE1FLm1kXG4gICAgS2V5Ym9hcmQub25zaG93ID0gb25TaG93O1xuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG5vUGx1Z2luRXJyb3IgPSAoKSA9PiB7XG4gIGNvbnNvbGUud2Fybignb25zLWtleWJvYXJkOiBDb3Jkb3ZhIEtleWJvYXJkIHBsdWdpbiBpcyBub3QgcHJlc2VudC4nKTtcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICBpZiAoIWJpbmRFdmVudHMoKSkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWFjdGl2ZV0nKSB8fFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgIH1cblxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29mdHdhcmVLZXlib2FyZDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHV0aWwuX29uRE9NQ29udGVudExvYWRlZCgpLCBmYWxzZSk7XG5cbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xuICBfc3RvcmU6IHt9LFxuXG4gIF9nZW5JZDogKCgpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpID0+IGkrKztcbiAgfSkoKSxcblxuICBzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgfVxufTtcblxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLnJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlIGEgJ2JhY2tidXR0b24nIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYmFja2J1dHRvbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2NhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRMaXN0ZW5lcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0sXG5cbiAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCkgPT09IHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpO1xuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChwYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2NhcHR1cmVUcmVlKCkge1xuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJlZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZihlbGVtZW50LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMoY2hpbGRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMocmVzdWx0LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlPZih0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGFyZ2V0W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSkge1xuICAgIHJldHVybiBmaW5kKHRyZWUpO1xuXG4gICAgZnVuY3Rpb24gZmluZChub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaW5kKG5vZGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUuZWxlbWVudDtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZWZ0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxlZnQsICcnKS56SW5kZXgsIDEwKTtcbiAgICAgICAgY29uc3QgcmlnaHRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUocmlnaHQsICcnKS56SW5kZXgsIDEwKTtcblxuICAgICAgICBpZiAoIWlzTmFOKGxlZnRaKSAmJiAhaXNOYU4ocmlnaHRaKSkge1xuICAgICAgICAgIHJldHVybiBsZWZ0WiA+IHJpZ2h0WiA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwdHVyaW5nIGJhY2tidXR0b24taGFuZGxlciBpcyBmYWlsdXJlLicpO1xuICAgICAgfSwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcigpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxubGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAnY2hldnJvbic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgaWYgKCEvb25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtcHJvZ3Jlc3MvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgIS9tYXRlcmlhbC8udGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkpIHtcblxuICAgIGNvbnN0IG9sZE1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG5cbiAgICBjb25zdCBuZXdNb2RpZmllciA9IG9sZE1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IG1vZGlmaWVyc01hcC5oYXNPd25Qcm9wZXJ0eShlKSA/IG1vZGlmaWVyc01hcFtlXSA6IGUpO1xuICAgIG5ld01vZGlmaWVyLnVuc2hpZnQoJ21hdGVyaWFsJyk7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllci5qb2luKCcgJykudHJpbSgpKTtcbiAgfVxuXG4gIC8vIEVmZmVjdHNcbiAgaWYgKC9vbnMtYnV0dG9ufG9ucy1saXN0LWl0ZW18b25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtdGFiJC8udGVzdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpXG4gICAgJiYgIXV0aWwuZmluZENoaWxkKGVsZW1lbnQsICdvbnMtcmlwcGxlJykpIHtcblxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgfVxuICB9XG59O1xuXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XG5cbiAvLyBNb2RpZmllcnNcbiBpZiAoL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xuICAgdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKTtcblxuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcbiAgICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbGFyZ2UnKSkgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgfVxuXG4gICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgfVxuIH1cblxuIC8vIEVmZmVjdHNcbiBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICB9XG5cbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiB9XG59O1xuXG5jb25zdCB1bmxvY2tlZCA9IHtcbiAgYW5kcm9pZDogdHJ1ZVxufTtcblxuY29uc3QgcHJlcGFyZUF1dG9TdHlsZSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHBsYXRmb3Jtc1ttb2JpbGVPU10oZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzRW5hYmxlZDogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCxcbiAgZW5hYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZSxcbiAgZGlzYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IGZhbHNlLFxuICBwcmVwYXJlOiBwcmVwYXJlQXV0b1N0eWxlXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRG9vckxvY2s7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuY29uc3QgcmVhZHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcXVldWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc0NvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVhZHlNYXAuaGFzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICByZWFkeU1hcC5zZXQoZWxlbWVudCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKSB7XG4gIGlmICghcXVldWVNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgcXVldWVNYXAuc2V0KGVsZW1lbnQsIFtdKTtcbiAgfVxuICBxdWV1ZU1hcC5nZXQoZWxlbWVudCkucHVzaChmbik7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVRdWV1ZShlbGVtZW50KSB7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlTWFwLmdldChlbGVtZW50LCBbXSkgfHwgW107XG4gIHF1ZXVlTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRlbnRSZWFkeShlbGVtZW50LCBmbikge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuL29yaWVudGF0aW9uJztcbmltcG9ydCBzb2Z0d2FyZUtleWJvYXJkIGZyb20gJy4vc29mdHdhcmUta2V5Ym9hcmQnO1xuaW1wb3J0IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlciBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAb2JqZWN0IG9uc1xuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFdT25zZW4gVUnjgafliKnnlKjjgafjgY3jgovjgrDjg63jg7zjg5Djg6vjgarjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogICBbZW5dQSBnbG9iYWwgb2JqZWN0IHRoYXQncyB1c2VkIGluIE9uc2VuIFVJLiBbL2VuXVxuICovXG5jb25zdCBvbnMgPSB7fTtcblxub25zLl91dGlsID0gdXRpbDtcbm9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcbm9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3I7XG5vbnMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbm9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcbm9ucy5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xub25zLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5vbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xub25zLl9hbmltYXRpb25PcHRpb25zUGFyc2VyID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlcjtcbm9ucy5fYXV0b1N0eWxlID0gYXV0b1N0eWxlO1xub25zLl9Eb29yTG9jayA9IERvb3JMb2NrO1xub25zLl9jb250ZW50UmVhZHkgPSBjb250ZW50UmVhZHk7XG5cbm9ucy5fcmVhZHlMb2NrID0gbmV3IERvb3JMb2NrKCk7XG5cbm9ucy5wbGF0Zm9ybS5zZWxlY3QoKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goL3BsYXRmb3JtPShbXFx3LV0rKS8pIHx8IFtdKVsxXSk7XG5cbndhaXREZXZpY2VSZWFkeSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsIE9uc2VuIFVJIGhhcyBiZWVuIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44GM5oq844GV44KM44Gf5pmC44Gr5a6f6KGM44GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgZ/jgoHjga7jg4fjg5Xjgqnjg6vjg4jjga7jg4/jg7Pjg4njg6njgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgarjgYTjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkueEoeWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZW5hYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhbmltYXRpb25zIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtIE5ldyBwbGF0Zm9ybSB0byBzdHlsZSB0aGUgZWxlbWVudHMuXG4gKi9cbm9ucy5mb3JjZVBsYXRmb3JtU3R5bGluZyA9IG5ld1BsYXRmb3JtID0+IHtcbiAgb25zLmVuYWJsZUF1dG9TdHlsaW5nKCk7XG4gIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xuXG4gIG9ucy5fdXRpbC5hcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1pZicpIHtcbiAgICAgICAgZWxlbWVudC5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLm1hdGNoKC9eb25zLS9pKSkge1xuICAgICAgICBvbnMuX2F1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLXBvcG92ZXIvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1wb3BvdmVyPiR7aHRtbH08L29ucy1wb3BvdmVyPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBwb3BvdmVyID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wb3BvdmVyJyk7XG4gICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShwb3BvdmVyKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsocG9wb3Zlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcG92ZXI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVBvcG92ZXJcbiAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xub25zLl9jcmVhdGVEaWFsb2dPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLWRpYWxvZy9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLWRpYWxvZz4ke2h0bWx9PC9vbnMtZGlhbG9nPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBkaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWRpYWxvZycpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZGlhbG9nKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhkaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVEaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZURpYWxvZyA9IG9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1hbGVydC1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1hbGVydC1kaWFsb2c+JHtodG1sfTwvb25zLWFsZXJ0LWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgYWxlcnREaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWFsZXJ0LWRpYWxvZycpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoYWxlcnREaWFsb2cpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWxlcnREaWFsb2cpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsoYWxlcnREaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGVydERpYWxvZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtYWxlcnQtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFsZXJ0IGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgYWxlcnQgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZUFsZXJ0RGlhbG9nID0gb25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gKi9cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgbGluaykge1xuICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50c1xuICAgICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gZWxlbWVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsO1xuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlbGVtZW50LCBwYWdlLCBsaW5rKSB7XG4gIGxpbmsgPSBsaW5rIHx8IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHsgZG9uZSgpOyB9O1xuICBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50KTtcblxuICAgIGxpbmsoY29udGVudEVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0pO1xuXG4gIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgKCkgPT4ge1xuICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59XG5cbndpbmRvdy5fc3VwZXJTZWNyZXRPbnMgPSBvbnM7XG5leHBvcnQgZGVmYXVsdCBvbnM7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBCYXNlRWxlbWVudCA9ICgpID0+IHt9O1xuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUVsZW1lbnQgZXh0ZW5kcyBnZXRFbGVtZW50Q2xhc3MoKSB7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gKiBAY2F0ZWdvcnkgdGVtcGxhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuXG4gKlxuICogICAgIFRoZXNlIHRlbXBsYXRlcyBjYW4gYmUgbG9hZGVkIGFzIHBhZ2VzIGluIGA8b25zLW5hdmlnYXRvcj5gLCBgPG9ucy10YWJiYXI+YCBhbmQgYDxvbnMtc3BsaXR0ZXI+YC4gVGhleSBjYW4gYWxzbyBiZSB1c2VkIHRvIGdlbmVyYXRlIGRpYWxvZ3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgajjgZfjgabkvb/nlKjjgZnjgovjgZ/jgoHjga5IVE1M44OV44Op44Kw44Oh44Oz44OI44KS5a6a576p44GX44G+44GZ44CC44GT44Gu6KaB57Sg44GnSFRNTOOCkuWuo+iogOOBmeOCi+OBqOOAgWlk5bGe5oCn44Gr5oyH5a6a44GX44Gf5ZCN5YmN44KScGFnZeOBrlVSTOOBqOOBl+OBpm9ucy1uYXZpZ2F0b3Ljgarjganjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgYvjgonlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIFBhZ2UgY29udGVudFxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+XG4gKiA8L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgZXZlbnQudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIGV2ZW50LnRlbXBsYXRlSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxud2luZG93Lk9uc1RlbXBsYXRlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRlbXBsYXRlJywge1xuICBwcm90b3R5cGU6IFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJ29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pZlxuICogQGNhdGVnb3J5IGNvbmRpdGlvbmFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbmRpdGlvbmFsbHkgZGlzcGxheSBjb250ZW50IGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0sIGRldmljZSBvcmllbnRhdGlvbiBvciBib3RoLlxuICpcbiAqICAgICBTb21ldGltZXMgaXQgaXMgdXNlZnVsIHRvIGNvbmRpdGlvbmFsbHkgaGlkZSBvciBzaG93IGNlcnRhaW4gY29tcG9uZW50cyBiYXNlZCBvbiBwbGF0Zm9ybS4gV2hlbiBydW5uaW5nIG9uIGlPUyB0aGUgYDxvbnMtaWY+YCBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGhpZGUgdGhlIGA8b25zLWZhYj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIFV0aWxpdHlBUElzXG4gKiAgIFtlbl1PdGhlciB1dGlsaXR5IEFQSXNbL2VuXVxuICogICBbamFd5LuW44Gu44Om44O844OG44Kj44Oq44OG44KjQVBJWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtaWYgb3JpZW50YXRpb249XCJsYW5kc2NhcGVcIj5cbiAqICAgICBMYW5kc2NhcGUgdmlldyFcbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJhbmRyb2lkXCI+XG4gKiAgICAgVGhpcyBpcyBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImlvcyBvdGhlclwiPlxuICogICAgIFRoaXMgaXMgbm90IEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuY2xhc3MgQ29uZGl0aW9uYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYXRmb3JtXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGFjZS1zZXBhcmF0ZWQgcGxhdGZvcm0gbmFtZXMuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiaW9zXCJgLCBgXCJhbmRyb2lkXCJgLCBgXCJ3aW5kb3dzXCJgIGFuZCBgXCJvdGhlclwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9yaWVudGF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVpdGhlciBgXCJwb3J0cmFpdFwiYCBvciBgXCJsYW5kc2NhcGVcImAuWy9lbl1cbiAgICogIFtqYV1wb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBl+OBvuOBmVsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHBsYXRmb3JtLl9yZW5kZXJQbGF0Zm9ybSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gJ29yaWVudGF0aW9uJykge1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIF9wbGF0Zm9ybVVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBfaXNBbGxvd2VkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgfVxuXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb3JpZW50YXRpb24nKSAmJiB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25hbE9yaWVudGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gKGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbikgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc0NvbmRpdGlvbmFsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWlmJywge1xuICBwcm90b3R5cGU6IENvbmRpdGlvbmFsRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGNsYXNzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7QWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLW9uZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLW9uZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbC0tKicsXG4gICcuYWxlcnQtZGlhbG9nLW1hc2snOiAnYWxlcnQtZGlhbG9nLW1hc2stLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnbm9uZSc6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFsZXJ0LWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBbGVydCBkaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50IHNjcmVlbi4gVXNlZnVsIGZvciBkaXNwbGF5aW5nIHF1ZXN0aW9ucywgd2FybmluZ3Mgb3IgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIHVzZXIuIFRoZSB0aXRsZSwgY29udGVudCBhbmQgYnV0dG9ucyBjYW4gYmUgZWFzaWx5IGN1c3RvbWl6ZWQgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBzd2l0Y2ggc3R5bGUgYmFzZWQgb24gdGhlIHBsYXRmb3JtLlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVBbGVydERpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBRd3d4eXBcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgVXNpbmdBbGVydFxuICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7kvb/jgYTmlrnjga7op6PoqqzjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5db25zLWRpYWxvZyBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5db25zLXBvcG92ZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLm5vdGlmaWNhdGlvblxuICogICBbZW5dVXNpbmcgb25zLm5vdGlmaWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL44Gr44Gv44CBb25zLm5vdGlmaWNhdGlvbuOCquODluOCuOOCp+OCr+ODiOOBruODoeOCveODg+ODieOCkuS9v+OBhuOBk+OBqOOCguOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hbGVydC1kaWFsb2cgaWQ9XCJhbGVydC1kaWFsb2dcIj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPldhcm5pbmchPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgPGJ1dHRvbiBpZD1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj5PSzwvYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGVydC1kaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuY2xhc3MgQWxlcnREaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gc2hvd2luZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gaGlkaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCiOOBhuOBqOOBmeOCi+OBruOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjgafjga9cIm5vbmVcIuOBi1wiZGVmYXVsdFwi44GM5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CC5L6L77yae2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIFwicmdiYSgwLCAwLCAwLCAwLjIpXCIuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9kaWFsb2coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nJyk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF90aXRsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctdGl0bGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gIH1cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHJlc3VsdCBhZnRlciBjb21waWxlOlxuICAgICAqXG4gICAgICogPG9ucy1hbGVydC1kaWFsb2cgc3R5bGU9XCJub25lXCI+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2dcIj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250YWluZXJcIj4uLi48L2Rpdj5cbiAgICAgKiAgIDwvZGl2PlxuICAgICAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBpZiAoIXRoaXMuX21hc2sgJiYgIXRoaXMuX2RpYWxvZykge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RpYWxvZykge1xuICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShkaWFsb2csIG51bGwpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLCAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInKSkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgdGhpcy5fZGlhbG9nLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5fZGlhbG9nLnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKSkge1xuICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44Gu44Gv44CBXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1BIGBQcm9taXNlYCBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XG4gICAgICBhbGVydERpYWxvZzogdGhpcyxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHNob3cnLCB7YWxlcnREaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5U2hvdygpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVzaG93IGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODgOOCpOOCouODreOCsOOBjOmWieOBmOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWhpZGUnLCB7XG4gICAgICBhbGVydERpYWxvZzogdGhpcyxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgY29uc3QgdHJ5SGlkZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmhpZGUodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0aGlkZScsIHthbGVydERpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHJpZXZlIHRoZSBiYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOCkuWPluW+l+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSAmJiAhdGhpcy5fcnVubmluZykge1xuICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICB0aGlzLmhpZGUoe1xuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IE9uc0FsZXJ0RGlhbG9nRWxlbWVudCA9IHdpbmRvdy5PbnNBbGVydERpYWxvZ0VsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1hbGVydC1kaWFsb2cnLCB7XG4gIHByb3RvdHlwZTogQWxlcnREaWFsb2dFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RGlhbG9nQW5pbWF0b3J9IEFuaW1hdG9yXG4gKi9cbk9uc0FsZXJ0RGlhbG9nRWxlbWVudC5yZWdpc3RlckFuaW1hdG9yID0gZnVuY3Rpb24obmFtZSwgQW5pbWF0b3IpIHtcbiAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zQWxlcnREaWFsb2dFbGVtZW50LkFsZXJ0RGlhbG9nQW5pbWF0b3InKTtcbiAgfVxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG59O1xuXG5PbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvciA9IEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxudmFyIHNjaGVtZSA9IHtcbiAgJyc6ICdiYWNrLWJ1dHRvbi0tKicsXG4gICcuYmFjay1idXR0b25fX2ljb24nOiAnYmFjay1idXR0b24tLSpfX2ljb24nLFxuICAnLmJhY2stYnV0dG9uX19sYWJlbCc6ICdiYWNrLWJ1dHRvbi0tKl9fbGFiZWwnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1iYWNrLWJ1dHRvblxuICogQGNhdGVnb3J5IHRvb2xiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQmFjayBidXR0b24gY29tcG9uZW50IGZvciBgPG9ucy10b29sYmFyPmAuIFB1dCBpdCBpbiB0aGUgbGVmdCBwYXJ0IG9mIHRoZSBgPG9ucy10b29sYmFyPmAuXG4gKlxuICogICAgIEl0IHdpbGwgZmluZCB0aGUgcGFyZW50IGA8b25zLW5hdmlnYXRvcj5gIGVsZW1lbnQgYW5kIHBvcCBhIHBhZ2Ugd2hlbiBjbGlja2VkLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc3BlY2lmeWluZyB0aGUgYG9uQ2xpY2tgIHByb3BlcnR5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1vbnMtbmF2aWdhdG9yIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbmF2aWdhdG9y44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBBZGRpbmdhdG9vbGJhclxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQGd1aWRlIFJldHVybmluZ2Zyb21hcGFnZVxuICogICBbZW5dUmV0dXJuaW5nIGZyb20gYSBwYWdlWy9lbl1cbiAqICAgW2phXeS4gOOBpOWJjeOBruODmuODvOOCuOOBq+aIu+OCi1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIFRpdGxlXG4gKiAgIDxkaXY+XG4gKiA8L29ucy10b29sYmFyPlxuICovXG5cbmNsYXNzIEJhY2tCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYmFjay1idXR0b24nKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnKSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9fbGFiZWwnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGljb24sIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgXCItaW9zXCIgb3IgXCItbWRcIlxuICAgKiAgICAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBcImxpZnQtaW9zXCIsIFwibGlmdC1tZFwiLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIFwic2xpZGUtaW9zXCIgYW5kIFwiZmFkZS1tZFwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkNsaWNrXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFjayBidXR0b24gYmVoYXZpb3IuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIF9vbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMub25DbGljay5hcHBseSh0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuYXZpZ2F0b3IgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1uYXZpZ2F0b3InKTtcbiAgICAgIGlmIChuYXZpZ2F0b3IpIHtcbiAgICAgICAgbmF2aWdhdG9yLnBvcFBhZ2UodGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxufVxuXG53aW5kb3cuT25zQmFja0J1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1iYWNrLWJ1dHRvbicsIHtcbiAgcHJvdG90eXBlOiBCYWNrQnV0dG9uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXJcbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJvdHRvbS10b29sYmFyPlxuICogICBDb250ZW50XG4gKiA8L29ucy1ib3R0b20tdG9vbGJhcj5cbiAqL1xuY2xhc3MgQm90dG9tVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7opovjgZ/nm67jga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdib3R0b20tYmFyJyk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPSBwYWdlKSB7XG4gICAgICBwYWdlLl9yZWdpc3RlckJvdHRvbVRvb2xiYXIodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbn1cblxud2luZG93Lk9uc0JvdHRvbVRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtYm90dG9tLXRvb2xiYXInLCB7XG4gIHByb3RvdHlwZTogQm90dG9tVG9vbGJhckVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnYnV0dG9uLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJ1dHRvblxuICogQGNhdGVnb3J5IGJ1dHRvblxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG91dGxpbmUgYW5kIHRyYW5zcGFyZW50IGJhY2tncm91bmRbL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS5oyB44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsaWdodFxuICogICBbZW5dQnV0dG9uIHRoYXQgZG9lc24ndCBzdGFuZCBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBn+OBquOBhOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgcXVpZXRcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG5vIG91dGxpbmUgYW5kIG9yIGJhY2tncm91bmQuLlsvZW5dXG4gKiAgIFtqYV3mnqDnt5rjgoTog4zmma/jgYznhKHjgYTmloflrZfjgaDjgZHjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGN0YVxuICogICBbZW5dQnV0dG9uIHRoYXQgcmVhbGx5IHN0YW5kcyBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBpOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2VcbiAqICAgW2VuXUxhcmdlIGJ1dHRvbiB0aGF0IGNvdmVycyB0aGUgd2lkdGggb2YgdGhlIHNjcmVlbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KL5aSn44GN44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tcXVpZXRcbiAqICAgW2VuXUxhcmdlIHF1aWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLcXVpZXTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1jdGFcbiAqICAgW2VuXUxhcmdlIGNhbGwgdG8gYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLY3Rh44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7NbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsLS1mbGF0XG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gZmxhdCBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OV44Op44OD44OI44Oc44K/44OzWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQnV0dG9uIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gcGxhY2UgYSBidXR0b24gaW4gYSB0b29sYmFyLCB1c2UgYDxvbnMtdG9vbGJhci1idXR0b24+YCBvciBgPG9ucy1iYWNrLWJ1dHRvbj5gIGluc3RlYWQuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIGJ1dHRvbiB3aXRoIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlxuICogICBbL2VuXVxuICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGhMYXl4XG4gKiBAZ3VpZGUgQnV0dG9uIFtlbl1HdWlkZSBmb3IgYDxvbnMtYnV0dG9uPmBbL2VuXVtqYV08b25zLWJ1dHRvbj7jga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIE92ZXJyaWRpbmdDU1NzdHlsZXMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsYXJnZS0tY3RhXCI+XG4gKiAgIFRhcCBNZVxuICogPC9vbnMtYnV0dG9uPlxuICovXG5cbmNsYXNzIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYnV0dG9uIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYnV0dG9uJyk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG59XG5cbndpbmRvdy5PbnNCdXR0b25FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtYnV0dG9uJywge1xuICBwcm90b3R5cGU6IEJ1dHRvbkVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuY29uc3Qgc2NoZW1lID0geycnOiAnY2Fyb3VzZWwtaXRlbS0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJvdXNlbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY2Fyb3VzZWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ2Fyb3VzZWwgaXRlbSBjb21wb25lbnQuIFVzZWQgYXMgYSBjaGlsZCBvZiB0aGUgYDxvbnMtY2Fyb3VzZWw+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHNlZWFsc28gb25zLWNhcm91c2VsXG4gKiAgIFtlbl1gPG9ucy1jYXJvdXNlbD5gIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdPG9ucy1jYXJvdXNlbD7jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuY2xhc3MgQ2Fyb3VzZWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNDYXJvdXNlbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtY2Fyb3VzZWwtaXRlbScsIHtcbiAgcHJvdG90eXBlOiBDYXJvdXNlbEl0ZW1FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuXG5jb25zdCBWZXJ0aWNhbE1vZGVUcmFpdCA9IHtcblxuICBfZ2V0U2Nyb2xsRGVsdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICB9LFxuXG4gIF9nZXRTY3JvbGxWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVk7XG4gIH0sXG5cbiAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uKHNjcm9sbCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoMHB4LCAnICsgLXNjcm9sbCArICdweCwgMHB4KSc7XG4gIH0sXG5cbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSAodGhpcy5fZGltZW5zaW9ucy5oZWlnaHQgfHwgMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nVG9wLCAxMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nQm90dG9tLCAxMCk7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAtKGhlaWdodCAtIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSkgLyAyO1xuICAgIH1cbiAgfSxcblxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5oZWlnaHQgPSBzaXplQXR0cjtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgfVxufTtcblxuY29uc3QgSG9yaXpvbnRhbE1vZGVUcmFpdCA9IHtcblxuICBfZ2V0U2Nyb2xsRGVsdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICB9LFxuXG4gIF9nZXRTY3JvbGxWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVg7XG4gIH0sXG5cbiAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICB9LFxuXG4gIF9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybTogZnVuY3Rpb24oc2Nyb2xsKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgLXNjcm9sbCArICdweCwgMHB4LCAwcHgpJztcbiAgfSxcblxuICBfdXBkYXRlRGltZW5zaW9uRGF0YTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIF91cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuY2VudGVyZWQpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gKHRoaXMuX2RpbWVuc2lvbnMud2lkdGggfHwgMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nTGVmdCwgMTApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ1JpZ2h0LCAxMCk7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAtKHdpZHRoIC0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpKSAvIDI7XG4gICAgfVxuICB9LFxuXG4gIF9sYXlvdXRDYXJvdXNlbEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCk7XG5cbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndpZHRoID0gc2l6ZUF0dHI7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IChpICogc2l6ZUluZm8ubnVtYmVyKSArIHNpemVJbmZvLnVuaXQ7XG4gICAgfVxuICB9LFxuXG4gIF9zZXR1cDogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25EYXRhKCk7XG4gICAgdGhpcy5fdXBkYXRlT2Zmc2V0KCk7XG4gICAgdGhpcy5fbGF5b3V0Q2Fyb3VzZWxJdGVtcygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJvdXNlbFxuICogQGNhdGVnb3J5IGNhcm91c2VsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENhcm91c2VsIGNvbXBvbmVudC4gQSBjYXJvdXNlbCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IHNldmVyYWwgaXRlbXMgaW4gdGhlIHNhbWUgc3BhY2UuXG4gKlxuICogICAgIFRoZSBjb21wb25lbnQgc3VwcG9ydHMgZGlzcGxheWluZyBjb250ZW50IGJvdGggaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LiBUaGUgdXNlciBjYW4gc2Nyb2xsIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IGRyYWdnaW5nIGFuZCBpdCBjYW4gYWxzbyBiZSBjb250cm9sbGVyIHByb2dyYW1tYXRpY2FsbHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgVXNpbmdDYXJvdXNlbFxuICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgY2Fyb3VzZWwgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1jYXJvdXNlbOOCs+ODs+ODneODvOODjeODs+ODiOOBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5jbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX3Njcm9sbCA9IDA7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSAwO1xuXG4gICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fbWl4aW4odGhpcy5faXNWZXJ0aWNhbCgpID8gVmVydGljYWxNb2RlVHJhaXQgOiBIb3Jpem9udGFsTW9kZVRyYWl0KTtcblxuICAgIHRoaXMuX3NldHVwKCk7XG4gICAgdGhpcy5fc2V0dXBJbml0aWFsSW5kZXgoKTtcblxuICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcbiAgfVxuXG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIF9vbkRpcmVjdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICdhdXRvJztcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dZID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dYID0gJyc7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIF9zYXZlTGFzdFN0YXRlKCkge1xuICAgIHRoaXMuX2xhc3RTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnRTaXplOiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCksXG4gICAgICBjYXJvdXNlbEVsZW1lbnRDb3VudDogdGhpcy5pdGVtQ291bnQsXG4gICAgICB3aWR0aDogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5pdGVtQ291bnRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1TaXplKCkge1xuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcblxuICAgIGlmIChzaXplSW5mby51bml0ID09PSAnJScpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNpemVJbmZvLm51bWJlciAvIDEwMCAqIGVsZW1lbnRTaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemVJbmZvLnVuaXQgPT09ICdweCcpIHtcbiAgICAgIHJldHVybiBzaXplSW5mby5udW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0SW5pdGlhbEluZGV4KCkge1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2luaXRpYWwtaW5kZXgnKSwgMTApO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluZGV4KSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9ICdpdGVtLScgKyAodGhpcy5faXNWZXJ0aWNhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnKTtcbiAgICBjb25zdCBpdGVtU2l6ZUF0dHIgPSAoJycgKyB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpLnRyaW0oKTtcblxuICAgIHJldHVybiBpdGVtU2l6ZUF0dHIubWF0Y2goL15cXGQrKHB4fCUpJC8pID8gaXRlbVNpemVBdHRyIDogJzEwMCUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gc2l6ZS5tYXRjaCgvXihcXGQrKShweHwlKS8pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgdW5pdDogbWF0Y2hlc1syXSxcbiAgICB9O1xuICB9XG5cbiAgX3NldHVwSW5pdGlhbEluZGV4KCkge1xuICAgIHRoaXMuX3Njcm9sbCA9ICh0aGlzLl9vZmZzZXQgfHwgMCkgKyB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgKiB0aGlzLl9nZXRJbml0aWFsSW5kZXgoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJbml0aWFsSW5kZXgoKTtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlSW5kZXhcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVJbmRleChpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHRoYXQgdGhlIGNhcm91c2VsIHNob3VsZCBiZSBzZXQgdG8uWy9lbl1cbiAgICogICBbamFdY2Fyb3VzZWzopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBpbmRleCBvZiB0aGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIHRvIHNob3cuWy9lbl1cbiAgICogICBbamFd6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpJpbmRleOOBp+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIHsgZHVyYXRpb246IDAuMywgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyB9LFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fVxuICAgICk7XG5cbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpKTtcbiAgICBjb25zdCBzY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogaW5kZXg7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gKHRoaXMuX29mZnNldCB8fCAwKTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuaXRlbUNvdW50O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG5cbiAgICBpZiAoc2Nyb2xsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWF4IGNhcm91c2VsIGluZGV4XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBuZXh0XG4gICAqIEBzaWduYXR1cmUgbmV4dChbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbmV4dCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5qyh44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbmV4dChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgodGhpcy5nZXRBY3RpdmVJbmRleCgpICsgMSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwcmV2XG4gICAqIEBzaWduYXR1cmUgcHJldihbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgcHJldmlvdXMgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeWJjeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHByZXYob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSAtIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNFbmFibGVkQ2hhbmdlRXZlbnQoKSB7XG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuICAgIGNvbnN0IGNhcm91c2VsSXRlbVNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG5cbiAgICByZXR1cm4gdGhpcy5hdXRvU2Nyb2xsICYmIGVsZW1lbnRTaXplID09PSBjYXJvdXNlbEl0ZW1TaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgX3ByZXBhcmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDF9KTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuXG4gICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgdGhpcy5fdXBkYXRlQXV0b1JlZnJlc2goKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG5cbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF91cGRhdGVTd2lwZWFibGUoKSB7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgaWYgKHRoaXMuc3dpcGVhYmxlKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUF1dG9SZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKSB7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldEFjdGl2ZUluZGV4KCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdEFjdGl2ZUluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgIGNvbnN0IGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IGN1cnJlbnRJbmRleDtcblxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xuICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgYWN0aXZlSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgbGFzdEFjdGl2ZUluZGV4OiBsYXN0QWN0aXZlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmRpcmVjdGlvbjtcbiAgICBpZiAoKHRoaXMuX2lzVmVydGljYWwoKSAmJiAoZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSkgfHwgKCF0aGlzLl9pc1ZlcnRpY2FsKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gZXZlbnQ7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCk7XG4gICAgdGhpcy5fc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KSAhPT0gMCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzT3ZlclNjcm9sbCh0aGlzLl9zY3JvbGwpKSB7XG4gICAgICBsZXQgd2FpdEZvckFjdGlvbiA9IGZhbHNlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xuICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgYWN0aXZlSW5kZXg6IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCksXG4gICAgICAgIHdhaXRUb1JldHVybjogKHByb21pc2UpID0+IHtcbiAgICAgICAgICB3YWl0Rm9yQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghd2FpdEZvckFjdGlvbikge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdERyYWdFdmVudCA9IG51bGw7XG5cbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYWl0XG4gICAqL1xuICBfbWl4aW4odHJhaXQpIHtcbiAgICBPYmplY3Qua2V5cyh0cmFpdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXNba2V5XSA9IHRyYWl0W2tleV07XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIF9zdGFydE1vbWVudHVtU2Nyb2xsKCkge1xuICAgIGlmICh0aGlzLl9sYXN0RHJhZ0V2ZW50KSB7XG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRoaXMuX2dldFNjcm9sbFZlbG9jaXR5KHRoaXMuX2xhc3REcmFnRXZlbnQpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSAwLjM7XG4gICAgICBjb25zdCBzY3JvbGxEZWx0YSA9IGR1cmF0aW9uICogMTAwICogdmVsb2NpdHk7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbihcbiAgICAgICAgdGhpcy5fc2Nyb2xsICsgKHRoaXMuX2dldFNjcm9sbERlbHRhKHRoaXMuX2xhc3REcmFnRXZlbnQpID4gMCA/IC1zY3JvbGxEZWx0YSA6IHNjcm9sbERlbHRhKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5fc2Nyb2xsID0gc2Nyb2xsO1xuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKHRoaXMuX3Njcm9sbClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIF9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbihzY3JvbGwpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgIGlmICghdGhpcy5hdXRvU2Nyb2xsKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICB9XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG4gICAgY29uc3QgbmJyT2ZJdGVtcyA9IHRoaXMuaXRlbUNvdW50O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYnJPZkl0ZW1zOyBpKyspIHtcbiAgICAgIGlmIChpICogc2l6ZSArIHRoaXMuX29mZnNldCA8IG1heCkge1xuICAgICAgICBhcnIucHVzaChpICogc2l6ZSArIHRoaXMuX29mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFyci5wdXNoKG1heCk7XG5cbiAgICBhcnIuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgbGVmdCA9IE1hdGguYWJzKGxlZnQgLSBzY3JvbGwpO1xuICAgICAgcmlnaHQgPSBNYXRoLmFicyhyaWdodCAtIHNjcm9sbCk7XG5cbiAgICAgIHJldHVybiBsZWZ0IC0gcmlnaHQ7XG4gICAgfSk7XG5cbiAgICBhcnIgPSBhcnIuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIHBvcykge1xuICAgICAgcmV0dXJuICFwb3MgfHwgaXRlbSAhPSBhcnJbcG9zIC0gMV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ICogc2l6ZSArIHRoaXMuX29mZnNldDtcbiAgICBjb25zdCBzY3JvbGxSYXRpbyA9IE1hdGguYWJzKHNjcm9sbCAtIGxhc3RTY3JvbGwpIC8gc2l6ZTtcbiAgICBsZXQgcmVzdWx0ID0gYXJyWzBdO1xuXG4gICAgaWYgKHNjcm9sbFJhdGlvIDw9IHRoaXMuYXV0b1Njcm9sbFJhdGlvKSB7XG4gICAgICByZXN1bHQgPSBsYXN0U2Nyb2xsO1xuICAgIH0gZWxzZSBpZiAoc2Nyb2xsUmF0aW8gPCAxLjApIHtcbiAgICAgIGlmIChhcnJbMF0gPT09IGxhc3RTY3JvbGwgJiYgYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHJlc3VsdCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtY2Fyb3VzZWwtaXRlbScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFxuICAgKi9cbiAgX3Njcm9sbFRvKHNjcm9sbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaXNPdmVyc2Nyb2xsYWJsZSA9IHRoaXMub3ZlcnNjcm9sbGFibGU7XG5cbiAgICBjb25zdCBub3JtYWxpemVTY3JvbGwgPSAoc2Nyb2xsKSA9PiB7XG4gICAgICBjb25zdCByYXRpbyA9IDAuMzU7XG5cbiAgICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICAgIHJldHVybiBpc092ZXJzY3JvbGxhYmxlID8gTWF0aC5yb3VuZChzY3JvbGwgKiByYXRpbykgOiAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcbiAgICAgIGlmIChtYXhTY3JvbGwgPCBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGlzT3ZlcnNjcm9sbGFibGUgPyBtYXhTY3JvbGwgKyBNYXRoLnJvdW5kKChzY3JvbGwgLSBtYXhTY3JvbGwpICogcmF0aW8pIDogbWF4U2Nyb2xsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2Nyb2xsO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKG5vcm1hbGl6ZVNjcm9sbChzY3JvbGwpKVxuICAgICAgICB9LCBvcHRpb25zLmFuaW1hdGlvbiAgIT09ICdub25lJyA/IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA6IHt9KVxuICAgICAgICAucGxheSgoKSA9PiB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2NhbGN1bGF0ZU1heFNjcm9sbCgpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLml0ZW1Db3VudCAqIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAtIHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChtYXggPCAwID8gMCA6IG1heCk7IC8vIE5lZWQgdG8gcmV0dXJuIGFuIGludGVnZXIgdmFsdWUuXG4gIH1cblxuICBfaXNPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIGlmIChzY3JvbGwgPCAwIHx8IHNjcm9sbCA+IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbCA8PSAwID8gJ3VwJyA6ICdkb3duJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbCA8PSAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gIH1cblxuICBfc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IDAuNDtcblxuICAgIGlmICh0aGlzLl9zY3JvbGwgPCAwKSB7XG4gICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKDApXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNCwgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICAgIHRoaXMuX3Njcm9sbCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICBpZiAobWF4U2Nyb2xsIDwgdGhpcy5fc2Nyb2xsKSB7XG4gICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKG1heFNjcm9sbClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAucGxheSgpO1xuICAgICAgdGhpcy5fc2Nyb2xsID0gbWF4U2Nyb2xsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaXRlbUNvdW50XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIG51bWJlciBvZiBjYXJvdXNlbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vopoHntKDjga7mlbDjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGl0ZW1Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIC8vIEJ1ZyBmaXhcbiAgICBpZiAodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWl4aW4odGhpcy5faXNWZXJ0aWNhbCgpID8gVmVydGljYWxNb2RlVHJhaXQgOiBIb3Jpem9udGFsTW9kZVRyYWl0KTtcbiAgICB0aGlzLl9zZXR1cCgpO1xuXG4gICAgaWYgKHRoaXMuX2xhc3RTdGF0ZSAmJiB0aGlzLl9sYXN0U3RhdGUud2lkdGggPiAwKSB7XG4gICAgICBsZXQgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsOy8vIC0gdGhpcy5fb2Zmc2V0O1xuXG4gICAgICBpZiAodGhpcy5faXNPdmVyU2Nyb2xsKHNjcm9sbCkpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Njcm9sbCkge1xuICAgICAgICAgIHNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKHNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zY3JvbGxUbyhzY3JvbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVmcmVzaCcsIHtjYXJvdXNlbDogdGhpc30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZmlyc3RcbiAgICogQHNpZ25hdHVyZSBmaXJzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgZmlyc3QgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGZpcnN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCgwLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxhc3RcbiAgICogQHNpZ25hdHVyZSBsYXN0KClcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGxhc3Qgb25zLWNhcm91c2VsIGl0ZW0uWy9lbl1cbiAgICogICBbamFd5pyA5b6M44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbGFzdChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRBY3RpdmVJbmRleChcbiAgICAgIE1hdGgubWF4KHRoaXMuaXRlbUNvdW50IC0gMSwgMCksIG9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuX3NldHVwKCk7XG4gICAgdGhpcy5fc2V0dXBJbml0aWFsSW5kZXgoKTtcblxuICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcblxuICAgIC8vIEZpeCByZW5kZXJpbmcgZ2xpdGNoIG9uIEFuZHJvaWQgNC4xXG4gICAgaWYgKHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVTd2lwZWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl91cGRhdGVBdXRvUmVmcmVzaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgIHRoaXMuX29uRGlyZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBhdXRvU2Nyb2xsUmF0aW9cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGF1dG8gc2Nyb2xsIHJhdGlvLiBbL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjga5yYXRpb+WApOOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbFJhdGlvKCkge1xuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nKTtcblxuICAgIGlmICghYXR0cikge1xuICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxSYXRpbyA9IHBhcnNlRmxvYXQoYXR0cik7XG4gICAgaWYgKHNjcm9sbFJhdGlvIDwgMC4wIHx8IHNjcm9sbFJhdGlvID4gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmFOKHNjcm9sbFJhdGlvKSA/IDAuNSA6IHNjcm9sbFJhdGlvO1xuICB9XG5cbiAgc2V0IGF1dG9TY3JvbGxSYXRpbyhyYXRpbykge1xuICAgIGlmIChyYXRpbyA8IDAuMCB8fCByYXRpbyA+IDEuMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhdGlvLicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycsIHJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5ddHJ1ZSBpZiB0aGUgY2Fyb3VzZWwgaXMgc3dpcGVhYmxlLlsvZW5dXG4gICAqICAgW2phXXN3aXBlYWJsZeOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHN3aXBlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICB9XG5cbiAgc2V0IHN3aXBlYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3dpcGVhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBhdXRvU2Nyb2xsXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5ddHJ1ZSBpZiBhdXRvIHNjcm9sbCBpcyBlbmFibGVkLlsvZW5dXG4gICAqICAgW2phXeOCquODvOODiOOCueOCr+ODreODvOODq+OBjOacieWKueOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXNjcm9sbCcpO1xuICB9XG5cbiAgc2V0IGF1dG9TY3JvbGwodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2F1dG8tc2Nyb2xsJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG92ZXJzY3JvbGxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXW92ZXJzY3JvbGzjgafjgY3jgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvdmVyc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ292ZXJzY3JvbGxhYmxlJyk7XG4gIH1cblxuICBzZXQgb3ZlcnNjcm9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ292ZXJzY3JvbGxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjZW50ZXJlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1jZW50ZXJlZOeKtuaFi+OBq+OBquOBo+OBpuOBhOOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGNlbnRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2VudGVyZWQnKTtcbiAgfVxuXG4gIHNldCBjZW50ZXJlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2VudGVyZWQnLCB2YWx1ZSk7XG4gIH1cbn1cblxud2luZG93Lk9uc0Nhcm91c2VsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWNhcm91c2VsJywge1xuICBwcm90b3R5cGU6IENhcm91c2VsRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSBsYXlvdXRpbmcgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmNsYXNzIENvbHVtbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnd2lkdGgnKSB7XG4gICAgICB0aGlzLl91cGRhdGVXaWR0aCgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICBpZiAodHlwZW9mIHdpZHRoICA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdpZHRoID0gKCcnICsgd2lkdGgpLnRyaW0oKTtcbiAgICAgIHdpZHRoID0gd2lkdGgubWF0Y2goL15cXGQrJC8pID8gd2lkdGggKyAnJScgOiB3aWR0aDtcblxuICAgICAgdGhpcy5zdHlsZS53ZWJraXRCb3hGbGV4ID0gJzAnO1xuICAgICAgdGhpcy5zdHlsZS53ZWJraXRGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1vekJveEZsZXggPSAnMCc7XG4gICAgICB0aGlzLnN0eWxlLm1vekZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubXNGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLmZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubWF4V2lkdGggPSB3aWR0aDtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc0NvbEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1jb2wnLCB7XG4gIHByb3RvdHlwZTogQ29sdW1uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGNsYXNzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IHRpbWluZztcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0RpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAzMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWRlRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtMzUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHtEaWFsb2dBbmltYXRvciwgSU9TRGlhbG9nQW5pbWF0b3IsIEFuZHJvaWREaWFsb2dBbmltYXRvciwgU2xpZGVEaWFsb2dBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuaW1wb3J0IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmRpYWxvZyc6ICdkaWFsb2ctLSonLFxuICAnLmRpYWxvZy1jb250YWluZXInOiAnZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuZGlhbG9nLW1hc2snOiAnZGlhbG9nLW1hc2stLSonXG59O1xuXG5jb25zdCB0ZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1jb250YWluZXJcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3IsXG4gICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXG4gICdub25lJzogRGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLiBBcyBvcHBvc2VkIHRvIHRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50LCB0aGlzIGNvbXBvbmVudCBjYW4gY29udGFpbiBhbnkga2luZCBvZiBjb250ZW50LlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYDxvbnMuY3JlYXRlRGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgICBUaGUgZGlhbG9nIGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBtZW51cywgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciB0byBhc2sgdGhlIHVzZXIgdG8gbWFrZSBhIGRlY2lzaW9uLlxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZGlzcGxheWVkIGFzIE1hdGVyaWFsIERlc2lnbiB3aGVuIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBkZXZpY2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHp4eGFHYVxuICogQGd1aWRlIFVzaW5nRGlhbG9nXG4gKiAgIFtlbl1MZWFybiBob3cgdG8gdXNlIHRoZSBkaWFsb2cgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWFsZXJ0LWRpYWxvZ1xuICogICBbZW5dYDxvbnMtYWxlcnQtZGlhbG9nPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBvcG92ZXJcbiAqICAgW2VuXWA8b25zLXBvcG92ZXI+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBvcG92ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtZGlhbG9nIGlkPVwiZGlhbG9nXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBkaWFsb2chPC9wPlxuICogPC9vbnMtZGlhbG9nPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuY2xhc3MgRGlhbG9nRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBrumdnuihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgoLjgZfjgY/jga9cImRlZmF1bHRcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgYFwicmdiYSgwLCAwLCAwLCAwLjIpXCJgLlsvZW5dXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9kaWFsb2coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuZGlhbG9nJyk7XG4gIH1cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgaWYgKHRoaXMuX2RpYWxvZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNvbnN0IGRpYWxvZyA9IHRlbXBsYXRlLmNoaWxkcmVuWzFdO1xuXG4gICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgZGlhbG9nLmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRlbXBsYXRlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlhbG9nLnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJywgJycpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXRyaWV2ZSB0aGUgYmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgpLlj5blvpfjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2FuY2VsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlc2hvdycsIHtcbiAgICAgIGRpYWxvZzogdGhpcyxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHNob3cnLCB7ZGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeVNob3coKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAsIGBcImZhZGVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgT25zRGlhbG9nRWxlbWVudCA9IHdpbmRvdy5PbnNEaWFsb2dFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZGlhbG9nJywge1xuICBwcm90b3R5cGU6IERpYWxvZ0VsZW1lbnQucHJvdG90eXBlXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAqL1xuT25zRGlhbG9nRWxlbWVudC5yZWdpc3RlckFuaW1hdG9yID0gZnVuY3Rpb24obmFtZSwgQW5pbWF0b3IpIHtcbiAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0RpYWxvZ0VsZW1lbnQuRGlhbG9nQW5pbWF0b3InKTtcbiAgfVxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG59O1xuXG5PbnNEaWFsb2dFbGVtZW50LkRpYWxvZ0FuaW1hdG9yID0gRGlhbG9nQW5pbWF0b3I7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSonLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZmFiXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50IGlzIGEgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiB0aGF0IGRpc3BsYXlzIGEgbWVudSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuY2xhc3MgRmFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uLiBTaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBgXCJib3R0b20gcmlnaHRcImAgb3IgYFwidG9wIGxlZnRcImAuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWInKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiJyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZmFiX19pY29uJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZS50cmFuc2Zvcm0gPT09ICdzY2FsZSgxKScgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG59XG5cbndpbmRvdy5PbnNGYWJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZmFiJywge1xuICBwcm90b3R5cGU6IEZhYkVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1nZXN0dXJlLWRldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdG8gZGV0ZWN0IGZpbmdlciBnZXN0dXJlcyB3aXRoaW4gdGhlIHdyYXBwZWQgZWxlbWVudC4gU2VlIHRoZSBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLlsvZW5dXG4gKiAgIFtqYV3opoHntKDlhoXjga7jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjgpLmpJznn6XjgZfjgb7jgZnjgILoqbPjgZfjgY/jga/jgqzjgqTjg4njgpLlj4LnhafjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICogQGd1aWRlIERldGVjdGluZ0Zpbmdlckdlc3R1cmVzXG4gKiAgIFtlbl1EZXRlY3RpbmcgZmluZ2VyIGdlc3R1cmVzWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOBruaknOefpVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1nZXN0dXJlLWRldGVjdG9yIHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTtcIj5cbiAqICAgLi4uXG4gKiA8L29ucy1nZXN0dXJlLWRldGVjdG9yPlxuICovXG5jbGFzcyBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzKTtcbiAgfVxufVxuXG53aW5kb3cuT25zR2VzdHVyZURldGVjdG9yRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWdlc3R1cmUtZGV0ZWN0b3InLCB7XG4gIHByb3RvdHlwZTogR2VzdHVyZURldGVjdG9yRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWNvblxuICogQGNhdGVnb3J5IGljb25cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheXMgYW4gaWNvbi4gVGhlIGZvbGxvd2luZyBpY29uIHN1aXRlcyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20vKVxuICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geEFodmdcbiAqIEBndWlkZSBVc2luZ0ljb25zIFtlbl1Vc2luZyBpY29uc1svZW5dW2phXeOCouOCpOOCs+ODs+OCkuS9v+OBhlsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pY29uXG4gKiAgIGljb249XCJtZC1jYXJcIlxuICogICBzaXplPVwiMjBweFwiXG4gKiAgIHN0eWxlPVwiY29sb3I6IHJlZFwiPlxuICogPC9vbnMtaWNvbj5cbiAqXG4gKiA8b25zLWJ1dHRvbj5cbiAqICAgPG9ucy1pY29uIGljb249XCJtZC1jYXJcIj48L29ucy1pY29uPlxuICogICBDYXJcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuY2xhc3MgSWNvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lLiBgXCJtZC1cImAgcHJlZml4IGZvciBNYXRlcmlhbCBJY29ucywgYFwiZmEtXCJgIGZvciBGb250IEF3ZXNvbWUgYW5kIGBcImlvbi1cImAgcHJlZml4IGZvciBJb25pY29ucy5cbiAgICpcbiAgICogICAgIFNlZSBhbGwgYXZhaWxhYmxlIGljb25zIG9uIHRoZWlyIHJlc3BlY3RpdmUgc2l0ZXM6XG4gICAqXG4gICAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gICAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbSlcbiAgICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gICAqXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlOlxuICAgKlxuICAgKiAgICAgYGBgXG4gICAqICAgICA8b25zLWljb25cbiAgICogICAgICAgaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIGRpc3BsYXkgYFwibWQtZWRpdFwiYCBmb3IgTWF0ZXJpYWwgRGVzaWduIGFuZCBgXCJpb24tZWRpdFwiYCBhcyB0aGUgZGVmYXVsdCBpY29uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdFwiXG4gICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHNwaW5uaW5nLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fZ2V0QXR0cmlidXRlKCdpY29uJyksIHRoaXMuX2dldEF0dHJpYnV0ZSgnc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX2dldEF0dHJpYnV0ZShhdHRyKSB7XG4gICAgY29uc3QgcGFydHMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgJycpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcbiAgICBsZXQgbWQgPSBwYXJ0c1sxXTtcbiAgICBtZCA9IChtZCB8fCAnJykuc3BsaXQoL1xccyo6XFxzKi8pO1xuICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgKi9cbiAgX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKSB7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiAvXihmYSR8ZmEtfGlvbi18em1kaS0pLy50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd6bWRpJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvbnMtaWNvbi0taW9uJyk7XG4gIH1cblxuICBfYnVpbGRDbGFzc0FuZFN0eWxlKGljb25OYW1lLCBzaXplKSB7XG4gICAgY29uc3QgY2xhc3NMaXN0ID0gWydvbnMtaWNvbiddO1xuICAgIGNvbnN0IHN0eWxlID0ge307XG5cbiAgICAvLyBJY29uXG4gICAgaWYgKGljb25OYW1lLmluZGV4T2YoJ2lvbi0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS1pb24nKTtcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lLmluZGV4T2YoJ2ZhLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEnKTtcbiAgICB9IGVsc2UgaWYoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC9cXC0oLispPy8pWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEtJyArIGljb25OYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cbn1cblxud2luZG93Lk9uc0ljb25FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtaWNvbicsIHtcbiAgcHJvdG90eXBlOiBJY29uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCB7TGF6eVJlcGVhdERlbGVnYXRlLCBMYXp5UmVwZWF0UHJvdmlkZXJ9IGZyb20gJ29ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxhenktcmVwZWF0XG4gKiBAY2F0ZWdvcnkgbGF6eS1yZXBlYXRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXNpbmcgdGhpcyBjb21wb25lbnQgYSBsaXN0IHdpdGggbWlsbGlvbnMgb2YgaXRlbXMgY2FuIGJlIHJlbmRlcmVkIHdpdGhvdXQgYSBkcm9wIGluIHBlcmZvcm1hbmNlLlxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcbiAqICAgICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBET00gd2hlbiB0aGV5IGFyZSBub3QgdmlzaWJsZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOWGheOBp+aPj+eUu+OBleOCjOOCi+OCouOCpOODhuODoOOBrkRPTeimgee0oOOBruiqreOBv+i+vOOBv+OBr+OAgeeUu+mdouOBq+imi+OBiOOBneOBhuOBq+OBquOBo+OBn+aZguOBvuOBp+iHquWLleeahOOBq+mBheW7tuOBleOCjOOAgVxuICogICAgIOeUu+mdouOBi+OCieimi+OBiOOBquOBj+OBquOBo+OBn+WgtOWQiOOBq+OBr+OBneOBruimgee0oOOBr+WLleeahOOBq+OCouODs+ODreODvOODieOBleOCjOOBvuOBmeOAglxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXdyR0JtXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBVc2luZ0xhenlSZXBlYXRcbiAqICAgW2VuXUhvdyB0byB1c2UgTGF6eSBSZXBlYXRbL2VuXVxuICogICBbamFd44Os44Kk44K444O844Oq44OU44O844OI44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24odGhpcyk7XG5cbiAgICAvLyBub3QgdmVyeSBnb29kIGlkZWEgYW5kIGFsc28gbm90IGRvY3VtZW50ZWRcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RlbGVnYXRlJykpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB3aW5kb3dbdGhpcy5nZXRBdHRyaWJ1dGUoJ2RlbGVnYXRlJyldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBhIGRlbGVnYXRlIG9iamVjdCB0byBsb2FkIGFuZCB1bmxvYWQgaXRlbSBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXeimgee0oOOBruODreODvOODieOAgeOCouODs+ODreODvOODieOBquOBqeOBruWHpueQhuOCkuWnlOitsuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgSFRNTEVsZW1lbnRgLlxuICAgKlxuICAgKiAgICAgVG8gaGVscCByZW5kZXJpbmcgdGhlIGVsZW1lbnQsIHRoZSBjdXJyZW50IGluZGV4IGFuZCBhIHRlbXBsYXRlIGlzIHN1cHBsaWVkIGFzIGFyZ3VtZW50cy4gVGhlIHRlbXBsYXRlIGlzIHRoZSBpbml0aWFsIGNvbnRlbnQgb2YgdGhlIGA8b25zLWxhenktcmVwZWF0PmAgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNvdW50SXRlbXNcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNob3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiBhbiBpdGVtLiBUaGUgaW5kZXggaXMgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG4gICAqXG4gICAqICAgICBUaGlzIGlzIGltcG9ydGFudCB3aGVuIHJlbmRlcmluZyBsaXN0cyB3aGVyZSB0aGUgaXRlbXMgaGF2ZSBkaWZmZXJlbnQgaGVpZ2h0LlxuICAgKlxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGFuZCBpZiBpdCBpc24ndCBwcmVzZW50IHRoZSBoZWlnaHQgb2YgdGhlIGZpcnN0IGl0ZW0gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYW5kIHVzZWQgZm9yIGFsbCBvdGhlciBpdGVtcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmRlc3Ryb3lJdGVtXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uIFRoZSBpbmRleCBhbmQgRE9NIGVsZW1lbnQgaXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzLlxuICAgKlxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGJ1dCBtYXkgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBzZXQgZGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRWxlbWVudCAmJiB0aGlzLmNoaWxkcmVuWzBdKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGVnYXRlID0gbmV3IExhenlSZXBlYXREZWxlZ2F0ZSh1c2VyRGVsZWdhdGUsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCB8fCBudWxsKTtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBuZXcgTGF6eVJlcGVhdFByb3ZpZGVyKHRoaXMucGFyZW50RWxlbWVudCwgZGVsZWdhdGUpO1xuICB9XG5cbiAgZ2V0IGRlbGVnYXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwcm9wZXJ0eSBjYW4gb25seSBiZSB1c2VkIHRvIHNldCB0aGUgZGVsZWdhdGUgb2JqZWN0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAc2lnbmF0dXJlIHJlZnJlc2goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVmcmVzaCB0aGUgbGlzdC4gVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGRhdGEgaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5yZWZyZXNoKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbndpbmRvdy5PbnNMYXp5UmVwZWF0RWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxhenktcmVwZWF0Jywge1xuICBwcm90b3R5cGU6IExhenlSZXBlYXRFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3RfX2hlYWRlci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWhlYWRlclxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSGVhZGVyIGVsZW1lbnQgZm9yIGxpc3QgaXRlbXMuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFd44Oq44K544OI6KaB57Sg44Gr5L2/55So44GZ44KL44OY44OD44OA44O855So44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3TjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgVXNpbmdMaXN0IFtlbl1Vc2luZyBsaXN0c1svZW5dW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGxpc3QgaGVhZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuY2xhc3MgTGlzdEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0IGhlYWRlci5bL2VuXVxuICAgKiAgIFtqYV3jg5jjg4Pjg4Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2hlYWRlcicpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNMaXN0SGVhZGVyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxpc3QtaGVhZGVyJywge1xuICBwcm90b3R5cGU6IExpc3RIZWFkZXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmxpc3RfX2l0ZW0nOiAnbGlzdF9faXRlbS0tKicsXG4gICcubGlzdF9faXRlbV9fbGVmdCc6ICdsaXN0X19pdGVtLS0qX19sZWZ0JyxcbiAgJy5saXN0X19pdGVtX19jZW50ZXInOiAnbGlzdF9faXRlbS0tKl9fY2VudGVyJyxcbiAgJy5saXN0X19pdGVtX19yaWdodCc6ICdsaXN0X19pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdF9faXRlbV9fbGFiZWwnOiAnbGlzdF9faXRlbS0tKl9fbGFiZWwnLFxuICAnLmxpc3RfX2l0ZW1fX3RpdGxlJzogJ2xpc3RfX2l0ZW0tLSpfX3RpdGxlJyxcbiAgJy5saXN0X19pdGVtX19zdWJ0aXRsZSc6ICdsaXN0X19pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdF9faXRlbV9fdGh1bWJuYWlsJzogJ2xpc3RfX2l0ZW0tLSpfX3RodW1ibmFpbCcsXG4gICcubGlzdF9faXRlbV9faWNvbic6ICdsaXN0X19pdGVtLS0qX19pY29uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1pdGVtXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIHRhcHBhYmxlXG4gKiAgIFtlbl1NYWtlIHRoZSBsaXN0IGl0ZW0gY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiBpdCdzIHRhcHBlZC4gT24gaU9TIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIFwidGFwcGFibGVcIiBhbmQgXCJ0YXAtYmFja2dyb3VuZC1jb2xvclwiIGF0dHJpYnV0ZSBmb3IgYmV0dGVyIGJlaGF2aW9yIHdoZW4gc2Nyb2xsaW5nLlsvZW5dXG4gKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZfjgZ/mmYLjgavlirnmnpzjgYzooajnpLrjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNoZXZyb25cbiAqICAgW2VuXURpc3BsYXkgYSBjaGV2cm9uIGF0IHRoZSByaWdodCBlbmQgb2YgdGhlIGxpc3QgaXRlbSBhbmQgbWFrZSBpdCBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIHRhcHBlZC4gVGhlIGNoZXZyb24gaXMgbm90IGRpc3BsYXllZCBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbG9uZ2RpdmlkZXJcbiAqICAgW2VuXURpc3BsYXlzIGEgbG9uZyBob3Jpem9udGFsIGRpdmlkZXIgYmV0d2VlbiBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBub2RpdmlkZXJcbiAqICAgW2VuXVJlbW92ZXMgdGhlIGRpdmlkZXIgYmV0d2VlbiBsaXN0IGl0ZW1zLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGxpc3QgaXRlbS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgcmVwcmVzZW50cyBlYWNoIGl0ZW0gaW4gdGhlIGxpc3QuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5cbiAqXG4gKiAgICAgVGhlIGxpc3QgaXRlbSBpcyBjb21wb3NlZCBvZiB0aHJlZSBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgIGFuZCBgcmlnaHRgIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbXMgaXMgcHJvcGVybHkgYWxpZ25lZC5cbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5DZW50ZXI8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlJpZ2h0PC9kaXY+XG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGVyZSBpcyBhbHNvIGEgbnVtYmVyIG9mIGNsYXNzZXMgKHByZWZpeGVkIHdpdGggYGxpc3RfX2l0ZW1fXypgKSB0aGF0IGhlbHAgd2hlbiBwdXR0aW5nIHRoaW5ncyBsaWtlIGljb25zIGFuZCB0aHVtYm5haWxzIGludG8gdGhlIGxpc3QgaXRlbXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXW9ucy1saXN0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBVc2luZ0xpc3RcbiAqICAgW2VuXVVzaW5nIGxpc3RzWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdC1pdGVtPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwibWQtZmFjZVwiIGNsYXNzPVwibGlzdF9faXRlbV9faWNvblwiPjwvb25zLWljb24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3RfX2l0ZW1fX3RpdGxlXCI+VGl0bGU8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdF9faXRlbV9fc3VidGl0bGVcIj5TdWJ0aXRsZTwvZGl2PlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy1zd2l0Y2g+PC9vbnMtc3dpdGNoPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWxpc3QtaXRlbT5cbiAqL1xuY2xhc3MgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeWQhOimgee0oOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxvY2stb24tZHJhZ1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2hlbiB0aGUgdXNlciBkcmFncyBob3Jpem9udGFsbHkuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44Om44O844K244O844GM44GT44Gu6KaB57Sg44KS5qiq5pa55ZCR44Gr44OJ44Op44OD44Kw44GX44Gm44GE44KL5pmC44Gr44CB57im5pa55ZCR44Gu44K544Kv44Ot44O844Or44GM6LW344GN44Gq44GE44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwcGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlcyB0aGUgZWxlbWVudCByZWFjdCB0byB0YXBzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW0nKTtcblxuICAgIGxldCBsZWZ0LCBjZW50ZXIsIHJpZ2h0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19sZWZ0Jyk7XG4gICAgICAgIGxlZnQgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgICAgY2VudGVyID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3JpZ2h0JykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fcmlnaHQnKTtcbiAgICAgICAgcmlnaHQgPSBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIGNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCkge1xuICAgICAgICAgICAgY2VudGVyLmluc2VydEJlZm9yZShlbCwgY2VudGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xuICAgIH1cblxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fY2VudGVyJyk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XG5cbiAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gIH1cblxuICBnZXQgX3RyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuICdiYWNrZ3JvdW5kLWNvbG9yIDAuMHMgbGluZWFyIDAuMDJzLCBib3gtc2hhZG93IDAuMHMgbGluZWFyIDAuMDJzJztcbiAgfVxuXG4gIGdldCBfdGFwcGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpO1xuICB9XG5cbiAgZ2V0IF90YXBCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0YXAtYmFja2dyb3VuZC1jb2xvcicpIHx8ICcjZDlkOWQ5JztcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XG4gICAgLy8gUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgaWYgdGhlIHVzZXJzIHBhbnMgbGVmdCBvciByaWdodC5cbiAgICBpZiAodGhpcy5fc2hvdWxkTG9ja09uRHJhZygpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaCgpIHtcbiAgICBpZiAodGhpcy50YXBwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcHBlZCA9IHRydWU7XG5cbiAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG4gICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcblxuICAgIGlmICh0aGlzLl90YXBwYWJsZSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fdGFwQmFja2dyb3VuZENvbG9yO1xuICAgICAgdGhpcy5zdHlsZS5ib3hTaGFkb3cgPSBgMHB4IC0xcHggMHB4IDBweCAke3RoaXMuX3RhcEJhY2tncm91bmRDb2xvcn1gO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoKSB7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xuICAgIHRoaXMuc3R5bGUuTW96VHJhbnNpdGlvbiA9ICcnO1xuXG4gICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9ICcnO1xuICB9XG5cbiAgX3Nob3VsZExvY2tPbkRyYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdsb2NrLW9uLWRyYWcnKTtcbiAgfVxufVxuXG53aW5kb3cuT25zTGlzdEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbGlzdC1pdGVtJywge1xuICBwcm90b3R5cGU6IExpc3RJdGVtRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3RcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgaW5zZXRcbiAqICAgW2VuXUluc2V0IGxpc3QgdGhhdCBkb2Vzbid0IGNvdmVyIHRoZSB3aG9sZSB3aWR0aCBvZiB0aGUgcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3opqropoHntKDjga7nlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgonjgarjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgIFtlbl1BIGxpc3Qgd2l0aCBubyBib3JkZXJzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ29tcG9uZW50IHRvIGRlZmluZSBhIGxpc3QsIGFuZCB0aGUgY29udGFpbmVyIGZvciBvbnMtbGlzdC1pdGVtKHMpLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLooajnj77jgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdC1pdGVt44Gu44Kz44Oz44OG44OK44Go44GX44Gm5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXW9ucy1saXN0LWl0ZW0gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgVXNpbmdMaXN0XG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmNsYXNzIExpc3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdCcpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNMaXN0RWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxpc3QnLCB7XG4gIHByb3RvdHlwZTogTGlzdEVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRleHQtaW5wdXQnOiAndGV4dC1pbnB1dC0tKicsXG4gICcudGV4dC1pbnB1dF9fbGFiZWwnOiAndGV4dC1pbnB1dC0tKl9fbGFiZWwnLFxuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnLFxuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21heGxlbmd0aCcsXG4gICdtaW4nLFxuICAnbWlubGVuZ3RoJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndHlwZScsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pbnB1dFxuICogQGNhdGVnb3J5IGlucHV0XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgdGV4dCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQW4gaW5wdXQgZWxlbWVudC4gVGhlIGB0eXBlYCBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbnB1dCB0eXBlLiBBbGwgdGV4dCBpbnB1dCB0eXBlcyBhcyB3ZWxsIGFzIGBjaGVja2JveGAgYW5kIGByYWRpb2AgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuLlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBvalF4TGpcbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBVc2luZ0Zvcm1Db21wb25lbnRzXG4gKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSBFdmVudEhhbmRsaW5nXG4gKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxuICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cbiAqIDxvbnMtaW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD48L29ucy1pbnB1dD5cbiAqL1xuY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QbGFjZWhvbGRlciB0ZXh0LiBJbiBNYXRlcmlhbCBEZXNpZ24sIHRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBhIGZsb2F0aW5nIGxhYmVsLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZsb2F0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHByZXNlbnQsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIGFuaW1hdGVkIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+aZguOAgeODqeODmeODq+OBr+OCouODi+ODoeODvOOCt+ODp+ODs+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIFNwZWNpZnkgdGhlIGlucHV0IHR5cGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIFwidHlwZVwiIGF0dHJpYnV0ZSBmb3Igbm9ybWFsIGlucHV0cy4gSG93ZXZlciwgZm9yIFwicmFuZ2VcIiB5b3Ugc2hvdWxkIGluc3RlYWQgdXNlIDxvbnMtcmFuZ2U+IGVsZW1lbnQuXG4gICAqXG4gICAqICAgIFBsZWFzZSB0YWtlIGEgbG9vayBhdCBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci10eXBlKSBmb3IgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBhbmQgYnJvd3NlciB2ZXJzaW9uIHNvbWUgb2YgdGhlc2UgbWlnaHQgbm90IHdvcmsuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIDxpbnB1dD4gZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyA8bGFiZWwgZm9yPVwiLi4uXCI+IGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29udGVudC1sZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBIVE1MIGNvbnRlbnQgb2YgYDxvbnMtaW5wdXQ+YCBpcyBwbGFjZWQgYmVmb3JlIHRoZSBhY3R1YWwgaW5wdXQgYXMgYSBsYWJlbC4gT21pdCB0aGlzIHRvIGRpc3BsYXkgaXQgYWZ0ZXIgdGhlIGlucHV0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnY2hlY2tlZCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdjaGVja2VkJykpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYm91bmRPbklucHV0ID0gdGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Gb2N1c2luID0gdGhpcy5fb25Gb2N1c2luLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkZvY3Vzb3V0ID0gdGhpcy5fb25Gb2N1c291dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGhlbHBlci5jbGFzc0xpc3QuYWRkKCdfaGVscGVyJyk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcblxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2lucHV0LWxhYmVsJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KSk7XG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3hfX2NoZWNrbWFyaycpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdyYWRpby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19jaGVja21hcmsnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0Jyk7XG4gICAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19sYWJlbCcpO1xuICAgICAgICB0aGlzLl9pbnB1dC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2NvbnRhaW5lcicpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbnB1dC1pZCcpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbnB1dC1pZCcpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3BsYWNlaG9sZGVyJykge1xuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVMYWJlbCgpKTtcbiAgICB9IGlmIChuYW1lID09PSAnaW5wdXQtaWQnKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5faW5wdXQuaWQgPSBjdXJyZW50KTtcbiAgICB9IGlmIChuYW1lID09PSAnY2hlY2tlZCcpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICByZXR1cm4gY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faW5wdXQudHlwZSAhPT0gJ2NoZWNrYm94JyAmJiB0aGlzLl9pbnB1dC50eXBlICE9PSAncmFkaW8nKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9ib3VuZE9uRm9jdXNvdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX2JvdW5kT25Gb2N1c291dCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXRMYWJlbCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faGVscGVyLnRleHRDb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5faGVscGVyLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYWJlbCgpIHtcbiAgICB0aGlzLl9zZXRMYWJlbCh0aGlzLmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIDogJycpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVMYWJlbENvbG9yKCkge1xuICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5wdXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2hlbHBlci5zdHlsZS5jb2xvciA9ICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2hlbHBlci5zdHlsZS5jb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuNSknO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYWJlbENsYXNzKCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtaW5wdXRfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWxlZ2F0ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICBfb25JbnB1dChldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XG4gIH1cblxuICBfb25Gb2N1c2luKGV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcbiAgfVxuXG4gIF9vbkZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDb2xvcigpO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLl9oZWxwZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dCA9PT0gbnVsbFxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgOiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWwpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fb25JbnB1dCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGNoZWNrZWQgb3Igbm90LiBPbmx5IHdvcmtzIGZvciBgcmFkaW9gIGFuZCBgY2hlY2tib3hgIHR5cGUgaW5wdXRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBnZXQgX2lzVGV4dElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09ICdyYWRpbycgJiYgdGhpcy50eXBlICE9PSAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gIH1cbn1cblxud2luZG93Lk9uc0lucHV0RWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWlucHV0Jywge1xuICBwcm90b3R5cGU6IElucHV0RWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDAuMjtcblxuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgdGhpcy50aW1pbmc7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogdGhpcy5kZWxheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMyc7XG4gICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ21vZGFsLS0qJyxcbiAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBNb2RhbEFuaW1hdG9yLFxuICAnZmFkZSc6IEZhZGVNb2RhbEFuaW1hdG9yLFxuICAnbm9uZSc6IE1vZGFsQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW1vZGFsXG4gKiBAY2F0ZWdvcnkgbW9kYWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgTW9kYWwgY29tcG9uZW50IHRoYXQgbWFza3MgY3VycmVudCBzY3JlZW4uIFVuZGVybHlpbmcgY29tcG9uZW50cyBhcmUgbm90IHN1YmplY3QgdG8gYW55IGV2ZW50cyB3aGlsZSB0aGUgbW9kYWwgY29tcG9uZW50IGlzIHNob3duLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBibG9jayB1c2VyIGlucHV0IHdoaWxlIHNvbWUgb3BlcmF0aW9uIGlzIHJ1bm5pbmcgb3IgdG8gc2hvdyBzb21lIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg55S76Z2i5YWo5L2T44KS44Oe44K544Kv44GZ44KL44Oi44O844OA44Or55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC5LiL5YG044Gr44GC44KL44Kz44Oz44Od44O844ON44Oz44OI44Gv44CBXG4gKiAgICAg44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gm44GE44KL6ZaT44Gv44Kk44OZ44Oz44OI6YCa55+l44GM6KGM44KP44KM44G+44Gb44KT44CCXG4gKiAgIFsvamFdXG4gKiBAZ3VpZGUgVXNpbmdNb2RhbFxuICogICBbZW5dVXNpbmcgb25zLW1vZGFsIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcbiAqICAgW2VuXVVzaW5nIG5hdmlnYXRvciBmcm9tIEphdmFTY3JpcHRbL2VuXVxuICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5jbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTW9kYWxBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdNb2RhbEFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgaGFuZGxlcik7XG4gICAgdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uID0gaGFuZGxlcjtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgLy8gRG8gbm90aGluZyBhbmQgc3RvcCBkZXZpY2UtYmFja2J1dHRvbiBoYW5kbGVyIGNoYWluLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ21vZGFsJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcubW9kYWxfX2NvbnRlbnQnKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdtb2RhbF9fY29udGVudCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBzZXRJbW1lZGlhdGUodGhpcy5fZW5zdXJlTm9kZVBvc2l0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKSk7XG4gIH1cblxuICBfZW5zdXJlTm9kZVBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgdmFyIHBhZ2UgPSB0aGlzO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBwYWdlID0gcGFnZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtcGFnZScpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFnZS5fcmVnaXN0ZXJFeHRyYUVsZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgbW9kYWwgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc01vZGFsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLW1vZGFsJywge1xuICBwcm90b3R5cGU6IE1vZGFsRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICovXG53aW5kb3cuT25zTW9kYWxFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNNb2RhbEVsZW1lbnQuTW9kYWxBbmltYXRvcicpO1xuICB9XG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNNb2RhbEVsZW1lbnQuTW9kYWxBbmltYXRvciA9IE1vZGFsQW5pbWF0b3I7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG5cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAyXCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKHBhZ2UpO1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUodG9vbGJhcik7XG4gICAgY29uc3QgbGVmdCA9IHRvb2xiYXIuX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50KCk7XG4gICAgY29uc3QgcmlnaHQgPSB0b29sYmFyLl9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKTtcblxuICAgIGNvbnN0IGV4Y2x1ZGVCYWNrQnV0dG9uTGFiZWwgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgY29uc3QgaWNvbkVsZW1lbnQgPSBlbGVtZW50c1tpXS5xdWVyeVNlbGVjdG9yKCcuYmFjay1idXR0b25fX2ljb24nKTtcbiAgICAgICAgICBpZiAoaWNvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGljb25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b25MYWJlbChsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbkxhYmVsKHJpZ2h0LmNoaWxkcmVuKSk7XG5cbiAgICBjb25zdCBwYWdlTGFiZWxzID0gW1xuICAgICAgdG9vbGJhci5fZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpLFxuICAgICAgdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKVxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZUxhYmVsczogcGFnZUxhYmVscyxcbiAgICAgIG90aGVyOiBvdGhlcixcbiAgICAgIGNvbnRlbnQ6IHBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksXG4gICAgICBiYWNrZ3JvdW5kOiBwYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpLFxuICAgICAgdG9vbGJhcjogdG9vbGJhcixcbiAgICAgIGJvdHRvbVRvb2xiYXI6IHBhZ2UuX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KClcbiAgICB9O1xuICB9XG5cbiAgX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZSwgbGVhdmVQYWdlKSB7XG4gICAgY29uc3QgYm90aFBhZ2VIYXNUb29sYmFyID1cbiAgICAgIGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG5cbiAgICB2YXIgbm9NYXRlcmlhbFRvb2xiYXIgPVxuICAgICAgIWVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ25hdmlnYXRpb24tYmFyLS1tYXRlcmlhbCcpICYmXG4gICAgICAhbGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJyk7XG5cbiAgICByZXR1cm4gYm90aFBhZ2VIYXNUb29sYmFyICYmIG5vTWF0ZXJpYWxUb29sYmFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IGRlbHRhID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBsZWF2ZVBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMikgKiAwLjYpO1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDAuMVxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG5cbiAgICAgICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlKTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCBkZWx0YSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBsZWF2ZVBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMikgKiAwLjYpO1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMC4xLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ucGFnZUxhYmVscylcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDF9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQoMClcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5wYWdlTGFiZWxzKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZGVsYXk6IDBcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQoMC42KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCgwLjQpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbi8qKlxuICogRmFkZS1pbiBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgZHVyYXRpb246ICcwLjQnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoW2VudGVyUGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgZW50ZXJQYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpXSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIGxlYXZlUGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKV0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJyxcbiAgICAgIGRlbGF5OiAwXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgei1pbmRleDogMjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+XG4gICAgYCk7XG4gICAgdGhpcy5ibGFja01hc2tPcGFjaXR5ID0gMC40O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAud2FpdCgwLjIpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHksXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZGVsYXk6IDAuMDVcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQoMC42KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDApXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCgwLjQpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG4vKipcbiAqIEZhZGUtaW4gKyBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnZWFzZS1vdXQnLFxuICAgICAgZHVyYXRpb246ICcwLjI1JyxcbiAgICAgIGRlbGF5OiAnMC4yMCdcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCA0MnB4LCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjE1KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMzhweCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4wNClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL25vbmUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUtaW9zJzogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0LWlvcyc6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0LW1kJzogTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ25vbmUnOiBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KG5hdmlnYXRvckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JFbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKG5hdmlnYXRvckVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1uYXZpZ2F0b3JcbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcGFnZSBzdGFjayBtYW5hZ2VtZW50IGFuZCBuYXZpZ2F0aW9uLiBTdGFjayBuYXZpZ2F0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbiBuYXZpZ2F0aW9uIHBhdHRlcm4gZm9yIG1vYmlsZSBhcHBzLlxuICpcbiAqICAgICBXaGVuIGEgcGFnZSBpcyBwdXNoZWQgb24gdG9wIG9mIHRoZSBzdGFjayBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gYW5pbWF0aW9uLiBXaGVuIHRoZSB1c2VyIHJldHVybnMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgdGhlIHRvcCBwYWdlIHdpbGwgYmUgcG9wcGVkIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIGhpZGRlbiB3aXRoIGFuIG9wcG9zaXRlIHRyYW5zaXRpb24gYW5pbWF0aW9uLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHlyaHR2XG4gKiBAZ3VpZGUgUGFnZU5hdmlnYXRpb25cbiAqICAgW2VuXUd1aWRlIGZvciBwYWdlIG5hdmlnYXRpb25bL2VuXVxuICogICBbamFd44Oa44O844K444OK44OT44Ky44O844K344On44Oz44Gu5qaC6KaBWy9qYV1cbiAqIEBndWlkZSBDYWxsaW5nQ29tcG9uZW50QVBJc2Zyb21KYXZhU2NyaXB0XG4gKiAgIFtlbl1Vc2luZyBuYXZpZ2F0b3IgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cbiAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxuICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcbiAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXG4gKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBBbm90aGVyIHBhZ2VcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvb25zLXRvb2xiYXI+XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9ib3VuZE9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX2JvdW5kT25EZXZpY2VCYWNrQnV0dG9uKTtcblxuICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgncGFnZScpKSB7XG4gICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSwge2FuaW1hdGlvbjogJ25vbmUnfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlc1tpXS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2hpbGRyZW4gb2YgPG9ucy1uYXZpZ2F0b3I+IG5lZWQgdG8gYmUgb2YgdHlwZSA8b25zLXBhZ2U+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b3BQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwb3BQYWdlXG4gICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWZyZXNoXVxuICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwb3BVcGRhdGUgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLl9kZXN0cm95KCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKCFvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAyO1xuXG4gICAgaWYgKCF0aGlzLnBhZ2VzW2luZGV4XS5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcGFnZXMgZGlyZWN0bHkgaW5zaWRlIHRoZSBOYXZpZ2F0b3IuIFVzZSBvbnMtdGVtcGxhdGUgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHRoaXMucGFnZXNbaW5kZXhdLm5hbWUpLnRoZW4odGVtcGxhdGVIVE1MID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZXh0ZW5kKHRoaXMuX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCksIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIHRoaXMucGFnZXNbaW5kZXhdLm9wdGlvbnMsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMucGFnZXNbaW5kZXhdID8gdGhpcy5wYWdlc1tpbmRleF0gOiBudWxsKTtcbiAgICAgICAgICB0aGlzLnBhZ2VzW2luZGV4ICsgMV0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSkudGhlbigoKSA9PiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSkpO1xuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksIHBhZ2VzID0gW10pIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5wYWdlc1tsIC0gMl0udXBkYXRlQmFja0J1dHRvbigobCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsIC0gMV07XG4gICAgICB2YXIgZW50ZXJQYWdlID0gdGhpcy5wYWdlc1tsIC0gMl07XG4gICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMuYW5pbWF0aW9uIHx8IG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMsIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBwYWdlcy5wb3AoKTtcbiAgICAgICAgdXBkYXRlKHBhZ2VzLCB0aGlzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHBvcCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgIGFuaW1hdG9yLnBvcCh0aGlzLnBhZ2VzW2wgLSAyXSwgdGhpcy5wYWdlc1tsIC0gMV0sIGNhbGxiYWNrKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHB1c2hQYWdlXG4gICAqIEBzaWduYXR1cmUgcHVzaFBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhZ2VdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gT25seSBuZWNlc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBvbWl0dGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0FueX0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBwdXNoZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2suWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwdXNoUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgcGFnZSk7XG4gICAgY29uc3QgcnVuID0gdGVtcGxhdGVIVE1MID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gcnVuKG9wdGlvbnMucGFnZUhUTUwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMob3B0aW9ucy5wYWdlKS50aGVuKHJ1bikpO1xuICB9XG5cbiAgX3B1c2hQYWdlKG9wdGlvbnMgPSB7fSwgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksIHBhZ2VzID0gW10sIHBhZ2UgPSB7fSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCB7YW5pbWF0aW9uT3B0aW9uc30sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICBwYWdlcy5wdXNoKHBhZ2UpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZShwYWdlcywgdGhpcykudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBlbnRlclBhZ2UgID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMl07XG5cbiAgICAgIGlmIChlbnRlclBhZ2Uubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGVsZW1lbnRzIG9mIHR5cGUgPG9ucy1wYWdlPiBjYW4gYmUgcHVzaGVkIHRvIHRoZSBuYXZpZ2F0b3InKTtcbiAgICAgIH1cblxuICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24ocGFnZUxlbmd0aCAtIDEpO1xuXG4gICAgICBlbnRlclBhZ2UuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIGVudGVyUGFnZS5uYW1lID0gb3B0aW9ucy5wYWdlO1xuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHZhciBkb25lID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgICAgbGVhdmVQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgdmFyIHB1c2ggPSAoKSA9PiAge1xuICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICBpZiAobGVhdmVQYWdlKSB7XG4gICAgICAgICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdGlvbnMuX2xpbmtlZCA/IHB1c2goKSA6IHJld3JpdGFibGVzLmxpbmsodGhpcywgZW50ZXJQYWdlLCBvcHRpb25zLCBwdXNoKTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXG4gICAqIEBzaWduYXR1cmUgcmVwbGFjZVBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBwYWdlKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICBvcHRpb25zLmNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMl0uX2Rlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2Uob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnNlcnRQYWdlXG4gICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBpbnNlcnRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5zZXJ0IHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjayB3aXRoIGF0IGEgcG9zaXRpb24gZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS44Oa44O844K444K544K/44OD44Kv44GuaW5kZXjjgafmjIflrprjgZfjgZ/kvY3nva7jgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMsIHBhZ2UpO1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ID49IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBydW4gPSB0ZW1wbGF0ZUhUTUwgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZXh0ZW5kKHRoaXMuX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCksIHtcbiAgICAgICAgbmFtZTogb3B0aW9ucy5wYWdlLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgIHB1c2hlZE9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKHRydWUpO1xuXG4gICAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gcnVuKG9wdGlvbnMucGFnZUhUTUwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhvcHRpb25zLnBhZ2UpLnRoZW4ocnVuKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZXNldFRvUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlc2V0VG9QYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2xlYXJzIHBhZ2Ugc3RhY2sgYW5kIGFkZHMgdGhlIHNwZWNpZmllZCBwYWdlIHRvIHRoZSBzdGFjay4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgpLjg6rjgrvjg4Pjg4jjgZfjgIHmjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVzZXRUb1BhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMsIHBhZ2UpO1xuXG4gICAgaWYgKCFvcHRpb25zLmFuaW1hdG9yICYmICFvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgb3B0aW9ucy5jYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdoaWxlICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5wYWdlc1swXS5fZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZ2VzWzBdLnVwZGF0ZUJhY2tCdXR0b24oZmFsc2UpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLnBhZ2UgJiYgIW9wdGlvbnMucGFnZUhUTUwgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3BhZ2UnKSkge1xuICAgICAgb3B0aW9ucy5wYWdlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJyaW5nUGFnZVRvcFxuICAgKiBAc2lnbmF0dXJlIGJyaW5nUGFnZVRvcChpdGVtLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbVxuICAgKiAgIFtlbl1QYWdlIFVSTCBvciBpbmRleCBvZiBhbiBleGlzdGluZyBwYWdlIGluIG5hdmlnYXRvcidzIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBrlVSTOOBi+OCguOBl+OBj+OBr29ucy1uYXZpZ2F0b3Ljga7jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CcmluZ3MgdGhlIGdpdmVuIHBhZ2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBzdGFjayBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvciBwdXNoZXMgaXQgaW50byB0aGUgc3RhY2sgaWYgZG9lc24ndC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7kuIDnlarkuIrjgavnp7vli5XjgZfjgb7jgZnjgILjgoLjgZfmjIflrprjgZfjgZ/jg5rjg7zjgrjjgYznhKHjgYvjgaPjgZ/loLTlkIjmlrDjgZfjgY9wdXNo44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGJyaW5nUGFnZVRvcChpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZih0eXBlb2YgaXRlbSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInID8gdGhpcy5fbm9ybWFsaXplSW5kZXgoaXRlbSkgOiB0aGlzLl9sYXN0SW5kZXhPZlBhZ2UoaXRlbSk7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5wYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhZ2UpO1xuICAgIH1cbiAgICBpZiAoIXBhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgaXRlbSAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgdXRpbC5leHRlbmQob3B0aW9ucywge1xuICAgICAgcGFnZTogcGFnZS5uYW1lLFxuICAgICAgX2xpbmtlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgcGFnZS5zZXRBdHRyaWJ1dGUoJ19za2lwaW5pdCcsICcnKTtcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMgPSB7fSwgcGFnZSkge1xuICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ29iamVjdCcgJiYgcGFnZSAhPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHBhZ2U7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG4gICAgcGFnZSA9IHBhZ2UgfHwgb3B0aW9ucy5wYWdlO1xuXG4gICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHtwYWdlfSk7XG4gIH1cblxuICBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VzW2luZGV4XS51cGRhdGVCYWNrQnV0dG9uKGluZGV4ID4gMCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE1hdGguYWJzKHRoaXMucGFnZXMubGVuZ3RoICsgaW5kZXgpICUgdGhpcy5wYWdlcy5sZW5ndGg7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wb3BQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBpZiAodGhpcy5wYWdlc1tpbmRleF0ubmFtZSA9PT0gcGFnZU5hbWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIF9lbWl0UHJlRXZlbnQobmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlJyArIG5hbWUsIHV0aWwuZXh0ZW5kKHtcbiAgICAgIG5hdmlnYXRvcjogdGhpcyxcbiAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0sXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSwgZGF0YSkpO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfZW1pdFByZVB1c2hFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwdXNoJyk7XG4gIH1cblxuICBfZW1pdFByZVBvcEV2ZW50KCkge1xuICAgIGNvbnN0IGwgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwb3AnLCB7XG4gICAgICBsZWF2ZVBhZ2U6IHRoaXMucGFnZXNbbCAtIDFdLFxuICAgICAgZW50ZXJQYWdlOiB0aGlzLnBhZ2VzW2wgLSAyXVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuXG4gICAgaWYgKHBhZ2VFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIFwib25zLXBhZ2VcIiBlbGVtZW50IHRvIFwib25zLW5hdmlnYXRvclwiLicpO1xuICAgIH1cblxuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUocGFnZUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHBhZ2VFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VzXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTENvbGxlY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1OYXZpZ2F0b3IncyBwYWdlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURlZmF1bHQgb3B0aW9ucyBvYmplY3QuIEF0dHJpYnV0ZXMgaGF2ZSBwcmlvcml0eSBvdmVyIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLnJlZnJlc2hcbiAgICogQGRlZmF1bHQgIGZhbHNlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwYXJhbWV0ZXIgaXMgYHRydWVgLCB0aGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgYHBvcFBhZ2UoKWAgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICBzZXQgX2lzUnVubmluZyh2YWx1ZSkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gIH1cbiAgZ2V0IF9pc1J1bm5pbmcoKSB7XG4gICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnKSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICB0aGlzLnRvcFBhZ2UuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICB0aGlzLnRvcFBhZ2UuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wYWdlc1tpXS5fZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxufVxuXG53aW5kb3cuT25zTmF2aWdhdG9yRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLW5hdmlnYXRvcicsIHtcbiAgcHJvdG90eXBlOiBOYXZpZ2F0b3JFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gKi9cbndpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc05hdmlnYXRvckVsZW1lbnQuTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yJyk7XG4gIH1cblxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG59O1xuXG53aW5kb3cuT25zTmF2aWdhdG9yRWxlbWVudC5yZXdyaXRhYmxlcyA9IHJld3JpdGFibGVzO1xud2luZG93Lk9uc05hdmlnYXRvckVsZW1lbnQuTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yID0gTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdwYWdlLS0qJyxcbiAgJy5wYWdlX19jb250ZW50JzogJ3BhZ2UtLSpfX2NvbnRlbnQnLFxuICAnLnBhZ2VfX2JhY2tncm91bmQnOiAncGFnZS0tKl9fYmFja2dyb3VuZCdcbn07XG5cbmNvbnN0IG51bGxUb29sYmFyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy10b29sYmFyJyk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXBhZ2VcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IG9mIGVhY2ggcGFnZS4gSWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2UgaXQgd2lsbCBiZWNvbWUgc2Nyb2xsYWJsZS5cbiAqXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjlrprnvqnjga7jgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7lhoXlrrnjga/jgrnjgq/jg63jg7zjg6vjgYzoqLHlj6/jgZXjgozjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIE1hbmFnaW5nTXVsdGlwbGVQYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSBQYWdlbGlmZWN5Y2xlXG4gKiAgIFtlbl1QYWdlIGxpZmUgY3ljbGUgZXZlbnRzWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOODqeOCpOODleOCteOCpOOCr+ODq+OCpOODmeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgSGFuZGxpbmdCYWNrQnV0dG9uXG4gKiAgIFtlbl1IYW5kbGluZyBiYWNrIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjgavlr77lv5zjgZnjgotbL2phXVxuICogQGd1aWRlIE92ZXJyaWRpbmdDU1NzdHlsZXNcbiAqICAgW2VuXU92ZXJyaWRpbmcgQ1NTIHN0eWxlc1svZW5dXG4gKiAgIFtqYV1DU1Pjgrnjgr/jgqTjg6vjga7jgqrjg7zjg5Djg7zjg6njgqTjg4lbL2phXVxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIC8vIEluZmluaXRlIFNjcm9sbCBoYW5kbGVyXG4gKiBwYWdlLm9uSW5maW5pdGVTY3JvbGwgPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqIH07XG4gKi9cbmNsYXNzIFBhZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaW5pdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgYXR0YWNoZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM44Ki44K/44OD44OB44GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGRlc3Ryb3lcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSBpcyBkZXN0cm95ZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM56C05qOE44GV44KM44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cbiAgICogICBbamFd44K544K/44Kk44Or5a6a576p44KS44Kr44K544K/44Oe44Kk44K644GZ44KL44Gf44KB44Gu5ZCN5YmN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb24taW5maW5pdGUtc2Nyb2xsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYXRoIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGxpbmcuIEV4YW1wbGU6IGBhcHAubG9hZERhdGFgLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BhZ2UnKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XG4gICAgICB0aGlzLl9za2lwSW5pdCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgIHRoaXMucHVzaGVkT3B0aW9ucyA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9za2lwSW5pdCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdpbml0JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVCYWNrQnV0dG9uKHNob3cpIHtcbiAgICBpZiAodGhpcy5iYWNrQnV0dG9uKSB7XG4gICAgICBzaG93ID8gdGhpcy5iYWNrQnV0dG9uLnNob3coKSA6IHRoaXMuYmFja0J1dHRvbi5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5hbWUoc3RyKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBzdHIpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgX3RyeVRvRmlsbFN0YXR1c0Jhcigpe1xuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgIWZpbGxlZCAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoKSB8fCAhdGhpcy5faGFzQVBhZ2VDb250cm9sQ2hpbGQoKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhc0FQYWdlQ29udHJvbENoaWxkKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZSA9PiBlLm5vZGVOYW1lLm1hdGNoKC9vbnMtKHNwbGl0dGVyfHNsaWRpbmctbWVudXxuYXZpZ2F0b3J8dGFiYmFyKS9pKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uSW5maW5pdGVTY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudCB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgb25JbmZpbml0ZVNjcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25JbmZpbml0ZVNjcm9sbCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX29uSW5maW5pdGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xuICAgIH1cbiAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25JbmZpbml0ZVNjcm9sbDtcbiAgfVxuXG4gIF9vblNjcm9sbCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgaWYgKHRoaXMuX29uSW5maW5pdGVTY3JvbGwgJiYgIXRoaXMuX2xvYWRpbmdDb250ZW50ICYmIG92ZXJMaW1pdCkge1xuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCgoKSA9PiB0aGlzLl9sb2FkaW5nQ29udGVudCA9IGZhbHNlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldENvbnRlbnRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2NhbkFuaW1hdGVUb29sYmFyKCkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2JhY2tncm91bmRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykgfHwgbnVsbFRvb2xiYXJFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIF9yZWdpc3RlclRvb2xiYXIoZWxlbWVudCkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMuY2hpbGRyZW5bMF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIF9yZWdpc3RlckJvdHRvbVRvb2xiYXIoZWxlbWVudCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGFnZS13aXRoLWJvdHRvbS10b29sYmFyJyk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfbXV0ZWQnKSB7XG4gICAgICB0aGlzLl9pc011dGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19tdXRlZCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19za2lwaW5pdCcpIHtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uLWluZmluaXRlLXNjcm9sbCcpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSAoZG9uZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgIGYoZG9uZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpIHx8ICF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKSkge1xuXG4gICAgICBjb25zdCBiYWNrZ3JvdW5kID0gdXRpbC5jcmVhdGUoJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX3JlZ2lzdGVyRXh0cmFFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgZXh0cmEgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2V4dHJhJyk7XG4gICAgaWYgKCFleHRyYSkge1xuICAgICAgZXh0cmEgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2V4dHJhJywge3pJbmRleDogMTAwMDF9KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZXh0cmEpO1xuICAgIH1cblxuICAgIGV4dHJhLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfc2hvdycpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2hpZGUnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfaGlkZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuX2hpZGUoKTtcblxuICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub25EZXZpY2VCYWNrQnV0dG9uKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfZGVzdHJveScpO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxud2luZG93Lk9uc1BhZ2VFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcGFnZScsIHtcbiAgcHJvdG90eXBlOiBQYWdlRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuY2xhc3MgUG9wb3ZlckFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxuICAgICAgZHVyYXRpb246IDAuMixcbiAgICAgIGRlbGF5OiAwXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX2FuaW1hdGUoZWxlbWVudCwge2Zyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaywgcmVzdG9yZSA9IGZhbHNlLCBhbmltYXRpb259KSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xuICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uID0gYW5pbWl0KGVsZW1lbnQpO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KG9wdGlvbnMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgIGNzczogdG8sXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIHRpbWluZzogb3B0aW9ucy50aW1pbmdcbiAgICB9KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIF9hbmltYXRlQWxsKGVsZW1lbnQsIGFuaW1hdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCkpO1xuICB9XG5cbn1cblxuY29uc3QgZmFkZSA9IHtcbiAgb3V0OiB7XG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXG4gICAgdG86IHtvcGFjaXR5OiAwfVxuICB9LFxuICBpbjoge1xuICAgIGZyb206IHtvcGFjaXR5OiAwfSxcbiAgICB0bzoge29wYWNpdHk6IDEuMH1cbiAgfVxufTtcblxuY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5pbiwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBNREZhZGVQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtQb3BvdmVyQW5pbWF0b3IsIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIE1ERmFkZVBvcG92ZXJBbmltYXRvcn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBhbmltYXRvcnMgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnBvcG92ZXInOiAncG9wb3Zlci0tKicsXG4gICcucG9wb3Zlci1tYXNrJzogJ3BvcG92ZXItbWFzay0tKicsXG4gICcucG9wb3Zlcl9fY29udGFpbmVyJzogJ3BvcG92ZXJfX2NvbnRhaW5lci0tKicsXG4gICcucG9wb3Zlcl9fY29udGVudCc6ICdwb3BvdmVyX19jb250ZW50LS0qJyxcbiAgJy5wb3BvdmVyX19hcnJvdyc6ICdwb3BvdmVyX19hcnJvdy0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBhbmltYXRvcnMuTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogYW5pbWF0b3JzLklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdub25lJzogYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogYW5pbWF0b3JzLklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogYW5pbWF0b3JzLk1ERmFkZVBvcG92ZXJBbmltYXRvclxufTtcblxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2NvbnRlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fYXJyb3dcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgcG9zaXRpb25zID0ge1xuICB1cDogJ2JvdHRvbScsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIGRvd246ICd0b3AnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG5jb25zdCBkaXJlY3Rpb25zID0gT2JqZWN0LmtleXMocG9zaXRpb25zKTtcbi8qKlxuICogQGVsZW1lbnQgb25zLXBvcG92ZXJcbiAqIEBjYXRlZ29yeSBwb3BvdmVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGRpc3BsYXlzIGEgcG9wb3ZlciBuZXh0IHRvIGFuIGVsZW1lbnQuIFRoZSBwb3BvdmVyIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgZXh0cmEgaW5mb3JtYXRpb24gYWJvdXQgYSBjb21wb25lbnQgb3IgYSB0b29sdGlwLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfcG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyX19jb250YWluZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9pbml0QW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdQb3BvdmVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpIHx8ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIHRoaXMuX2FuaW1hdG9yID0gKG9wdGlvbnMpID0+IGZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICBjb25zdCB7X3JhZGl1czogcmFkaXVzLCBfY29udGVudDogZWwsIF9tYXJnaW46IG1hcmdpbn0gPSB0aGlzO1xuICAgIGNvbnN0IHBvcyA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc01EID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBjb3ZlciA9IGlzTUQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyLXRhcmdldCcpO1xuXG4gICAgY29uc3QgZGlzdGFuY2UgPSB7XG4gICAgICB0b3A6IHBvcy50b3AgLSBtYXJnaW4sXG4gICAgICBsZWZ0OiBwb3MubGVmdCAtIG1hcmdpbixcbiAgICAgIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCAtIHBvcy5yaWdodCAtIG1hcmdpbixcbiAgICAgIGJvdHRvbTogd2luZG93LmlubmVySGVpZ2h0IC0gcG9zLmJvdHRvbSAtIG1hcmdpblxuICAgIH07XG5cbiAgICBjb25zdCB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX0gPSB0aGlzLl9jYWxjdWxhdGVEaXJlY3Rpb25zKGRpc3RhbmNlKTtcbiAgICB0aGlzLl9wb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItLScgKyBwcmltYXJ5KTtcblxuICAgIGNvbnN0IG9mZnNldCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHBvcy5oZWlnaHQgOiBwb3Mud2lkdGgpICsgKGlzTUQgPyAwIDogMTQpO1xuICAgIHRoaXMuc3R5bGVbcHJpbWFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtwcmltYXJ5XSArIG9mZnNldCkgKyBtYXJnaW4gKyAncHgnO1xuICAgIGVsLnN0eWxlW3ByaW1hcnldID0gMDtcblxuICAgIGNvbnN0IGwgPSB2ZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICBjb25zdCBzaXplcyA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcbiAgICB9KSkod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpKTtcblxuICAgIGVsLnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtzZWNvbmRhcnldIC0gKHNpemVzW2xdIC0gcG9zW2xdKSAvIDIpICsgJ3B4JztcbiAgICB0aGlzLl9hcnJvdy5zdHlsZVtzZWNvbmRhcnldID0gTWF0aC5tYXgocmFkaXVzLCBkaXN0YW5jZVtzZWNvbmRhcnldICsgcG9zW2xdIC8gMikgKyAncHgnO1xuXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKGRpc3RhbmNlLCBzaXplcywgcG9zLCBwcmltYXJ5KTtcblxuICAgIC8vIFByZXZlbnQgYW5pbWl0IGZyb20gcmVzdG9yaW5nIHRoZSBzdHlsZS5cbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWl0LW9yaWctc3R5bGUnKTtcbiAgfVxuXG4gIF9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpIHtcbiAgICBjb25zdCBjYWxjID0gKGEsIG8sIGwpID0+IHByaW1hcnkgPT09IGEgPyBzaXplc1tsXSAvIDIgOiBkaXN0YW5jZVthXSArIChwcmltYXJ5ID09PSBvID8gLXNpemVzW2xdIDogc2l6ZXNbbF0gLSBwb3NbbF0pIC8gMjtcbiAgICBjb25zdCBbeCwgeV0gPSBbY2FsYygnbGVmdCcsICdyaWdodCcsICd3aWR0aCcpICsgJ3B4JywgY2FsYygndG9wJywgJ2JvdHRvbScsICdoZWlnaHQnKSArICdweCddO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuX3BvcG92ZXIuc3R5bGUsIHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogeCArICcgJyArIHksXG4gICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5YOiB4LFxuICAgICAgd2Via2l0VHJhbnNmb3JtT3JpZ2luWTogeVxuICAgIH0pO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURpcmVjdGlvbnMoZGlzdGFuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSB8fCAndXAgZG93biBsZWZ0IHJpZ2h0Jykuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBwb3NpdGlvbnNbZV0pO1xuICAgIGNvbnN0IHByaW1hcnkgPSBvcHRpb25zLnNvcnQoKGEsIGIpID0+IGRpc3RhbmNlW2FdIC0gZGlzdGFuY2VbYl0pWzBdO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwcmltYXJ5KSAhPT0gLTE7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuc3R5bGVbZV0gPSAnJztcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZShgcG9wb3Zlci0tJHtlfWApO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGhpcy5fY3VycmVudFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucygncG9wb3ZlcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyJyk7XG5cbiAgICBjb25zdCBoYXNEZWZhdWx0Q29udGFpbmVyID0gdGhpcy5fcG9wb3ZlciAmJiB0aGlzLl9jb250ZW50O1xuXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLW1hc2snKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9hcnJvdykge1xuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyX19hcnJvdycpO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgIShvcHRpb25zLmFuaW1hdGlvbiBpbiBfYW5pbWF0b3JEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRvciAke29wdGlvbnMuYW5pbWF0aW9ufSBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgKTtcbiAgfVxuXG4gIF9leGVjdXRlQWN0aW9uKGFjdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB7YWN0aW9uLCBiZWZvcmUsIGFmdGVyfSA9IGFjdGlvbnM7XG5cbiAgICB0aGlzLl9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBzeW5jaHJvbm91c1xuICAgICAgcG9wb3ZlcjogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG5cbiAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0b3Iob3B0aW9ucylbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhZnRlciAmJiBhZnRlcigpO1xuXG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwb3N0JHthY3Rpb259YCwge3BvcG92ZXI6IHRoaXN9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyh0YXJnZXQsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR8SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC4gQ2FuIGJlIGVpdGhlciBhIENTUyBzZWxlY3RvciwgYW4gZXZlbnQgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44K/44O844Ky44OD44OI44Go44Gq44KL6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCQ1NT44K744Os44Kv44K/44GLZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgYtET03opoHntKDjga7jgYTjgZrjgozjgYvjgpLmuKHjgZvjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gdGhlIHBvcG92ZXIgYW5kIHBvaW50IGl0IGF0IGEgdGFyZ2V0LiBUaGUgdGFyZ2V0IGNhbiBiZSBlaXRoZXIgYW4gZXZlbnQsIGEgQ1NTIHNlbGVjdG9yIG9yIGEgRE9NIGVsZW1lbnQuLlsvZW5dXG4gICAqICAgW2phXeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAgnRhcmdldOW8leaVsOOBq+OBr+OAgSRldmVudOOCquODluOCuOOCp+OCr+ODiOOChERPTeOCqOODrOODoeODs+ODiOOChENTU+OCu+ODrOOCr+OCv+OCkua4oeOBmeOBk+OBqOOBjOWHuuadpeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRhcmdldDtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdzaG93JyxcbiAgICAgIGJlZm9yZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIHRoZSBwb3BvdmVyLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9leGVjdXRlQWN0aW9uKHtcbiAgICAgIGFjdGlvbjogJ2hpZGUnLFxuICAgICAgYWZ0ZXI6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZSBvciBub3QuXG4gICAqXG4gICAqICAgICBXaGVuIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHJpZXZlIHRoZSBiYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOCkuWPluW+l+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJykpO1xuICAgICAgdGhpcy5fcmFkaXVzID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXJhZGl1cycpKTtcblxuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3BvcG92ZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIHRoaXMuX3BvcG92ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmRPbkNoYW5nZSgpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc1BvcG92ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcG9wb3ZlcicsIHtcbiAgcHJvdG90eXBlOiBQb3BvdmVyRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAqL1xud2luZG93Lk9uc1BvcG92ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBhbmltYXRvcnMuUG9wb3ZlckFuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBQb3BvdmVyQW5pbWF0b3InKTtcbiAgfVxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG59O1xuXG53aW5kb3cuT25zUG9wb3ZlckVsZW1lbnQuUG9wb3ZlckFuaW1hdG9yID0gYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcjtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgcHJvZ3Jlc3NcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB6dlFiR2pcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWNpcmN1bGFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKi9cbmNsYXNzIFByb2dyZXNzQmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1iYXItLWRldGVybWluYXRlYCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgdGhpcy5fcHJpbWFyeS5zdHlsZS53aWR0aCA9ICh0aGlzLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlY29uZGFyeVZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgc2Vjb25kYXJ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScsICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1szXTtcbiAgICB0aGlzLl9zZWNvbmRhcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzFdO1xuXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG59XG5cbndpbmRvdy5PbnNQcm9ncmVzc0JhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1iYXInLCB7XG4gIHByb3RvdHlwZTogUHJvZ3Jlc3NCYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnByb2dyZXNzLWNpcmN1bGFyJzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeSc6ICdwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeS0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5LS0qJ1xufTtcblxuY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICA8c3ZnIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJcIj5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDAlXCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxMCVcIiBzdHJva2UtbWl0ZXJsaW1pdD1cIjEwXCIvPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDAlXCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxMCVcIiBzdHJva2UtbWl0ZXJsaW1pdD1cIjEwXCIvPlxuICA8L3N2Zz5cbmApO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogQGNhdGVnb3J5IHByb2dyZXNzXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLiBJdCBjYW4gZWl0aGVyIGJlIHVzZWQgdG8gc2hvdyBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkIG9yIHRvIHNob3cgYSBsb29waW5nIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBFVnpNalJcbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKi9cbmNsYXNzIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1jaXJjdWxhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1jaXJjdWxhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVZhbHVlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgY29uc3QgcGVyID0gTWF0aC5jZWlsKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcbiAgICAgIGNvbnN0IHBlciA9ICBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHNlY29uZGFyeVZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnLCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbM107XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1sxXTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxufVxuXG53aW5kb3cuT25zUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIHtcbiAgcHJvdG90eXBlOiBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IFNUQVRFX0lOSVRJQUwgPSAnaW5pdGlhbCc7XG5jb25zdCBTVEFURV9QUkVBQ1RJT04gPSAncHJlYWN0aW9uJztcbmNvbnN0IFNUQVRFX0FDVElPTiA9ICdhY3Rpb24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wdWxsLWhvb2tcbiAqIEBjYXRlZ29yeSBwdWxsLWhvb2tcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgYWRkcyAqKlB1bGwgdG8gcmVmcmVzaCoqIGZ1bmN0aW9uYWxpdHkgdG8gYW4gYDxvbnMtcGFnZT5gIGVsZW1lbnQuXG4gKlxuICogICAgIEl0IGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gYSB0YXNrIHdoZW4gdGhlIHVzZXIgcHVsbHMgZG93biBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLiBBIGNvbW1vbiB1c2FnZSBpcyB0byByZWZyZXNoIHRoZSBkYXRhIGRpc3BsYXllZCBpbiBhIHBhZ2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gV2JKb2dNXG4gKiBAZ3VpZGUgVXNpbmdQdWxsSG9va1xuICogICBbZW5dSG93IHRvIHVzZSBQdWxsIEhvb2tbL2VuXVxuICogICBbamFd44OX44Or44OV44OD44Kv44KS5L2/44GGWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtcHVsbC1ob29rPlxuICogICAgIFJlbGVhc2UgdG8gcmVmcmVzaFxuICogICA8L29ucy1wdWxsLWhvb2s+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wdWxsLWhvb2snKS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDApO1xuICogICB9O1xuICogPC9zY3JpcHQ+XG4gKi9cbmNsYXNzIFB1bGxIb29rRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZXN0YXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLiBUaGUgc3RhdGUgY2FuIGJlIGVpdGhlciBcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiBvciBcImFjdGlvblwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrueKtuaFi+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAgueKtuaFi+OBr+OAgVwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiLCBcImFjdGlvblwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucHVsbEhvb2tcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuc3RhdGVcbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7nirbmhYvlkI3jgpLlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBcInB1bGwtdG8tcmVmcmVzaFwiIGZ1bmN0aW9uYWxpdHkgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50LiBXaGVuIHB1bGxlZCBkb3duIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlIGl0IHdpbGwgc3dpdGNoIHRvIHRoZSBcInByZWFjdGlvblwiIHN0YXRlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjY0cHhcIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7pq5jjgZXku6XkuIrjgatwdWxsIGRvd27jgZnjgovjgahcInByZWFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gu5YCk44GvXCI2NHB4XCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0aHJlc2hvbGQtaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gdGhlIFwiYWN0aW9uXCIgc3RhdGUgd2hlbiBwdWxsZWQgZnVydGhlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiOTZweFwiLiBBIG5lZ2F0aXZlIHZhbHVlIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBoZWlnaHQgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFd6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5YCk44Gn5oyH5a6a44GX44Gf6auY44GV44KI44KK44KCcHVsbCBkb3du44GZ44KL44Go44CB44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gv6Ieq5YuV55qE44GrXCJhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZpeGVkLWNvbnRlbnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgcGFnZSB3aWxsIG5vdCBtb3ZlIHdoZW4gcHVsbGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgabjgYTjgovmmYLjgavjgoLjgrPjg7Pjg4bjg7Pjg4Tjga/li5XjgY3jgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gMDtcblxuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwsIHRydWUpO1xuICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gIH1cblxuICBfY3JlYXRlU2Nyb2xsRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2Nyb2xsJykpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInNjcm9sbFwiPjxkaXY+Jyk7XG5cbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcblxuICAgIHNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgd2hpbGUgKHBhZ2VFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHBhZ2VFbGVtZW50LmFwcGVuZENoaWxkKHNjcm9sbEVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHNjcm9sbEVsZW1lbnQ7XG4gIH1cblxuICBfc2V0U3R5bGUoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB0aGlzLnN0eWxlLnRvcCA9ICctJyArIGhlaWdodCArICdweCc7XG4gICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuc3R5bGUubGluZUhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUzZCgwcHgsICcgKyBzY3JvbGwgKyAncHgsIDBweCknO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHdoZW4gZHJhZ2dpbmcgbGVmdCBhbmQgcmlnaHQuXG4gICAgaWYgKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYWNrIHRvIG1ha2UgaXQgd29yayBvbiBBbmRyb2lkIDQuNCBXZWJWaWV3LiBTY3JvbGxzIG1hbnVhbGx5IG5lYXIgdGhlIHRvcCBvZiB0aGUgcGFnZSBzb1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcbiAgICAvLyBraWxsIGFsbCAndG91Y2htb3ZlJyBldmVudHMuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fc3RhcnRTY3JvbGwgLSBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09PSAwICYmIHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggPSBldmVudC5nZXN0dXJlLmRlbHRhWTtcblxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uO1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbCA9IE1hdGgubWF4KGV2ZW50Lmdlc3R1cmUuZGVsdGFZIC0gdGhpcy5fc3RhcnRTY3JvbGwsIDApO1xuXG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSAmJiBzY3JvbGwgPj0gdGhpcy50aHJlc2hvbGRIZWlnaHQpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUuc3RvcERldGVjdCgpO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xuICAgIH0gZWxzZSBpZiAoc2Nyb2xsID49IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9QUkVBQ1RJT04pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydFNjcm9sbCA9IHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKTtcbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG5cbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgX2ZpbmlzaCgpIHtcbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9BQ1RJT04pO1xuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHRoaXMuaGVpZ2h0LCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub25BY3Rpb24gfHwgKGRvbmUgPT4gZG9uZSgpKTtcbiAgICBhY3Rpb24oKCkgPT4ge1xuICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA2NHB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGAke3ZhbHVlfXB4YCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJzY0JywgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0aHJlc2hvbGRIZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB0aHJlc2hvbGRIZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA5NnB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IHRocmVzaG9sZEhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0aHJlc2hvbGQgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICB9XG5cbiAgX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSB7XG4gICAgY29uc3QgdGggPSB0aGlzLnRocmVzaG9sZEhlaWdodDtcbiAgICByZXR1cm4gdGggPiAwICYmIHRoID49IHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgIGlmICghbm9FdmVudCAmJiBsYXN0U3RhdGUgIT09IHRoaXMuX2dldFN0YXRlKCkpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XG4gICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzdGF0ZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIF9nZXRDdXJyZW50U2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHB1bGxEaXN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IG51bWJlciBvZiBwaXhlbHMgdGhlIHB1bGwgaG9vayBoYXMgbW92ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gf6Led6Zui44KS44OU44Kv44K744Or5pWw44CCWy9qYV1cbiAgICovXG4gIGdldCBwdWxsRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfaXNDb250ZW50Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdmaXhlZC1jb250ZW50Jyk7XG4gIH1cblxuICBfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29udGVudEZpeGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICovXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT0gMCAmJiBzY3JvbGwgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnBsYXkoZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0pXG4gICAgICAgIC5wbGF5KGRvbmUpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRNaW5pbXVtU2Nyb2xsKCkge1xuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSB0aGlzLl9wYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gc2Nyb2xsSGVpZ2h0ID4gcGFnZUhlaWdodCA/IC0oc2Nyb2xsSGVpZ2h0IC0gcGFnZUhlaWdodCkgOiAwO1xuICB9XG5cbiAgX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZycsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcblxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWcnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zY3JvbGxFbGVtZW50ICYmIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVTY3JvbGxFbGVtZW50KCk7XG5cbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgIGlmICghdGhpcy5fcGFnZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19jb250ZW50JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignPG9ucy1wdWxsLWhvb2s+IG11c3QgYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGVzdHJveUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG59XG5cbndpbmRvdy5PbnNQdWxsSG9va0VsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wdWxsLWhvb2snLCB7XG4gIHByb3RvdHlwZTogUHVsbEhvb2tFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbndpbmRvdy5PbnNQdWxsSG9va0VsZW1lbnQuU1RBVEVfQUNUSU9OID0gU1RBVEVfQUNUSU9OO1xud2luZG93Lk9uc1B1bGxIb29rRWxlbWVudC5TVEFURV9JTklUSUFMID0gU1RBVEVfSU5JVElBTDtcbndpbmRvdy5PbnNQdWxsSG9va0VsZW1lbnQuU1RBVEVfUFJFQUNUSU9OID0gU1RBVEVfUFJFQUNUSU9OO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTYgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5cbi8qKlxuICogQGNsYXNzIEFuaW1hdG9yQ1NTIC0gaW1wbGVtZW50YXRpb24gb2YgQW5pbWF0b3IgY2xhc3MgdXNpbmcgY3NzIHRyYW5zaXRpb25zXG4gKi9cbmNsYXNzIEFuaW1hdG9yQ1NTIHtcblxuICAvKipcbiAgICogQG1ldGhvZCBhbmltYXRlXG4gICAqIEBkZXNjIG1haW4gYW5pbWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZmluYWxDU1NcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdIC0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQudGhlbihjYWxsYmFjaykgLSBzZXRzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnN0b3Aob3B0aW9ucykgLSBzdG9wcyB0aGUgYW5pbWF0aW9uOyBpZiBvcHRpb25zLnN0b3BOZXh0IGlzIHRydWUgdGhlbiBpdCBkb2Vzbid0IGNhbGwgdGhlIGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuZmluaXNoKG1zKSAtIGZpbmlzaGVzIHRoZSBhbmltYXRpb24gaW4gdGhlIHNwZWNpZmllZCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnNwZWVkKG1zKSAtIHNldHMgdGhlIGFuaW1hdGlvbiBzcGVlZCBzbyB0aGF0IGl0IGZpbmlzaGVzIGFzIGlmIHRoZSBvcmlnaW5hbCBkdXJhdGlvbiB3YXMgdGhlIG9uZSBzcGVjaWZpZWQgaGVyZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBgXG4gICAqICB2YXIgcmVzdWx0ID0gYW5pbWF0b3IuYW5pbWF0ZShlbCwge29wYWNpdHk6IDAuNX0sIDEwMDApO1xuICAgKlxuICAgKiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICogICAgcmVzdWx0LnNwZWVkKDIwMCkudGhlbihmdW5jdGlvbigpe1xuICAgKiAgICAgIGNvbnNvbGUubG9nKCdkb25lJyk7XG4gICAqICAgIH0pO1xuICAgKiAgfSwgMzAwKTtcbiAgICogYGBgYFxuICAgKi9cbiAgYW5pbWF0ZShlbCwgZmluYWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgdmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgaW5pdGlhbCA9IHt9LFxuICAgICAgICBzdG9wcGVkID0gZmFsc2UsXG4gICAgICAgIG5leHQgPSBmYWxzZSxcbiAgICAgICAgdGltZW91dCA9IGZhbHNlLFxuICAgICAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoZmluYWwpO1xuXG4gICAgdmFyIHVwZGF0ZVN0eWxlcyA9ICgpID0+IHtcbiAgICAgIGxldCBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHMuZ2V0UHJvcGVydHlWYWx1ZS5iaW5kKHMpKTtcbiAgICAgIHMgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzdG9wOiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB2YXIgayA9IE1hdGgubWluKDEsICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb24pO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOZXh0KSB7XG4gICAgICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0aGVuOiAoY2IpID0+IHtcbiAgICAgICAgbmV4dCA9IGNiO1xuICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgc3BlZWQ6IChuZXdEdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgICAgIG5ld0R1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICAgIGNvbnN0IHBhc3NlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcbiAgICAgICAgICBjb25zdCAgayA9IHBhc3NlZCAvIGR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IG5ld0R1cmF0aW9uICogKDEgLSBrKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdXBkYXRlU3R5bGVzKCk7XG5cbiAgICAgICAgICBzdGFydCA9IGVsLnNwZWVkVXBUaW1lO1xuICAgICAgICAgIGR1cmF0aW9uID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogKG1pbGxpc2Vjb25kcyA9IDUwKSA9PiB7XG4gICAgICAgIHZhciBrID0gKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcblxuICAgICAgICByZXN1bHQuc3BlZWQobWlsbGlzZWNvbmRzIC8gKDEgLSBrKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgc3RvcHBlZCB8fCBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICBjb25zdCB2ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGUpKTtcbiAgICAgIGluaXRpYWxbZV0gPSBpc05hTih2KSA/IDAgOiB2O1xuICAgIH0pO1xuXG5cbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHByb3BlcnRpZXMuam9pbignLCcpO1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW2VdID0gZmluYWxbZV0gKyAoZSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9vblN0b3BBbmltYXRpb25zKGVsLCByZXN1bHQuc3RvcCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gIH1cblxuICBfb25TdG9wQW5pbWF0aW9ucyhlbCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB2YXIgaSA9IHRoaXMuX2luZGV4Kys7XG4gICAgcXVldWVbZWxdID0gcXVldWVbZWxdIHx8IFtdO1xuICAgIHF1ZXVlW2VsXVtpXSA9IChvcHRpb25zKSA9PiB7XG4gICAgICBkZWxldGUgcXVldWVbZWxdW2ldO1xuICAgICAgaWYgKHF1ZXVlW2VsXSAmJiBxdWV1ZVtlbF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgZGVsZXRlIHF1ZXVlW2VsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcihvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQW5pbWF0aW9uc1xuICAqIEBkZXNjIHN0b3BzIGFjdGl2ZSBhbmltYXRpb25zIG9uIGEgc3BlY2lmaWVkIGVsZW1lbnRcbiAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsZW1lbnQgLSBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICByZXR1cm4gZWwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKHRoaXMuX3F1ZXVlW2VsXSB8fCBbXSkuZm9yRWFjaChlID0+IHsgZShvcHRpb25zIHx8IHt9KTsgfSk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbGxcbiAgKiBAZGVzYyBzdG9wcyBhbGwgYWN0aXZlIGFuaW1hdGlvbnNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbGwob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhPYmplY3Qua2V5cyh0aGlzLl9xdWV1ZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBmYWRlXG4gICogQGRlc2MgZmFkZXMgdGhlIGVsZW1lbnQgKHNob3J0IHZlcnNpb24gZm9yIGFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSkpXG4gICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdXG4gICovXG4gIGZhZGUoZWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9LCBkdXJhdGlvbik7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRvckNTUztcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci1jc3MnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yaXBwbGVcbiAqIEBjYXRlZ29yeSByaXBwbGVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWRkcyBhIE1hdGVyaWFsIERlc2lnbiBcInJpcHBsZVwiIGVmZmVjdCB0byBhbiBlbGVtZW50LiBUaGUgcmlwcGxlIGVmZmVjdCB3aWxsIHNwcmVhZCBmcm9tIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgdXNlciB0YXBzLlxuICpcbiAqICAgICBTb21lIGVsZW1lbnRzIHN1Y2ggYXMgYDxvbnMtYnV0dG9uPmAgYW5kIGA8b25zLWZhYj5gICBzdXBwb3J0IGEgYHJpcHBsZWAgYXR0cmlidXRlLlxuICogICBbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oq44OD44OX44Or5Yq55p6c44KSRE9N6KaB57Sg44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHdLUVdkWlxuICogQGV4YW1wbGVcbiAqIDxkaXYgY2xhc3M9XCJteS1kaXZcIj5cbiAqICA8b25zLXJpcHBsZT48L29ucy1yaXBwbGU+XG4gKiA8L2Rpdj5cbiAqXG4gKiA8b25zLWJ1dHRvbiByaXBwbGU+Q2xpY2sgbWUhPC9vbnMtYnV0dG9uPlxuICovXG5jbGFzcyBSaXBwbGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBiYWNrZ3JvdW5kXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7oibLjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBr+eEoeWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3JpcHBsZScpO1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JhY2tncm91bmQgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fYmFja2dyb3VuZCcpWzBdO1xuICAgICAgdGhpcy5fd2F2ZSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX193YXZlJylbMF07XG4gICAgfVxuXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuICAgIFsnY29sb3InLCAnY2VudGVyJywgJ3N0YXJ0LXJhZGl1cycsICdiYWNrZ3JvdW5kJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIFsnX3dhdmUnLCAnX2JhY2tncm91bmQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpc1tlXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpc1tlXS5jbGFzc0xpc3QuYWRkKCdyaXBwbGVfJyArIGUpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzW2VdKTtcbiAgICB9KTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUNvb3JkcyhlKSB7XG4gICAgdmFyIHgsIHksIGgsIHcsIHI7XG4gICAgdmFyIGIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICh0aGlzLl9jZW50ZXIpIHtcbiAgICAgIHggPSBiLndpZHRoIC8gMjtcbiAgICAgIHkgPSBiLmhlaWdodCAvIDI7XG4gICAgICByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKGUuY2xpZW50WCB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xuICAgICAgeSA9IChlLmNsaWVudFkgfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZKSAtIGIudG9wO1xuICAgICAgaCA9IE1hdGgubWF4KHksIGIuaGVpZ2h0IC0geSk7XG4gICAgICB3ID0gTWF0aC5tYXgoeCwgYi53aWR0aCAtIHgpO1xuICAgICAgciA9IE1hdGguc3FydChoICogaCArIHcgKiB3KTtcbiAgICB9XG4gICAgcmV0dXJuIHt4LCB5LCByfTtcbiAgfVxuXG4gIF9yaXBwbGVBbmltYXRpb24oZSwgZHVyYXRpb24gPSAzMDApIHtcbiAgICB2YXJcbiAgICAgIHtfYW5pbWF0b3IsIF93YXZlLCBfYmFja2dyb3VuZCwgX21pblJ9ID0gdGhpcyxcbiAgICAgIHt4LCB5LCByfSA9IHRoaXMuX2NhbGN1bGF0ZUNvb3JkcyhlKTtcblxuICAgIF9hbmltYXRvci5zdG9wQWxsKHtzdG9wTmV4dDogMX0pO1xuICAgIF9hbmltYXRvci5hbmltYXRlKF9iYWNrZ3JvdW5kLCB7b3BhY2l0eTogMX0sIGR1cmF0aW9uKTtcblxuICAgIHV0aWwuZXh0ZW5kKF93YXZlLnN0eWxlLCB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdG9wOiB5IC0gX21pblIgKyAncHgnLFxuICAgICAgbGVmdDogeCAtIF9taW5SICsgJ3B4JyxcbiAgICAgIHdpZHRoOiAyICogX21pblIgKyAncHgnLFxuICAgICAgaGVpZ2h0OiAyICogX21pblIgKyAncHgnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2FuaW1hdG9yLmFuaW1hdGUoX3dhdmUsIHtcbiAgICAgIHRvcDogeSAtIHIsXG4gICAgICBsZWZ0OiB4IC0gcixcbiAgICAgIGhlaWdodDogMiAqIHIsXG4gICAgICB3aWR0aDogMiAqIHJcbiAgICB9LCBkdXJhdGlvbik7XG4gIH1cblxuICBfdXBkYXRlUGFyZW50KCkge1xuICAgIGlmICghdGhpcy5fcGFyZW50VXBkYXRlZCAmJiB0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnBhcmVudE5vZGUpO1xuICAgICAgaWYgKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIF9vblRhcChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgIHRoaXMuX3JpcHBsZUFuaW1hdGlvbihlLmdlc3R1cmUuc3JjRXZlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX3dhdmUpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgIHRoaXMuX2hvbGRpbmcgPSB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50LCAyMDAwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gICAgfVxuICB9XG5cbiAgX29uUmVsZWFzZShlKSB7XG4gICAgaWYgKHRoaXMuX2hvbGRpbmcpIHtcbiAgICAgIHRoaXMuX2hvbGRpbmcuc3BlZWQoMzAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9ob2xkaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuX2hvbGRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vblJlbGVhc2UoZSk7XG4gICAgfVxuICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pICE9IC0xKSB7XG4gICAgICB0aGlzLl9vblRhcChlKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3BhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgdGhpcy5fYm91bmRPblRhcCA9IHRoaXMuX29uVGFwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkhvbGQgPSB0aGlzLl9vbkhvbGQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX2JvdW5kT25UYXApO1xuICAgICAgdGhpcy5fcGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fYm91bmRPbkhvbGQpO1xuICAgICAgdGhpcy5fcGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICB9XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3BhcmVudE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fYm91bmRPbkhvbGQpO1xuICAgIHRoaXMuX3BhcmVudE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdTdGFydCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnc3RhcnQtcmFkaXVzJykge1xuICAgICAgdGhpcy5fbWluUiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoY3VycmVudCkgfHwgMCk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnY29sb3InICYmIGN1cnJlbnQpIHtcbiAgICAgIHRoaXMuX3dhdmUuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJiAoY3VycmVudCB8fCBsYXN0KSkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09ICdub25lJykge1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnY2VudGVyJykge1xuICAgICAgdGhpcy5fY2VudGVyID0gY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQgIT0gJ2ZhbHNlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG59XG5cbndpbmRvdy5PbnNSaXBwbGVFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcmlwcGxlJywge1xuICBwcm90b3R5cGU6IFJpcHBsZUVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJvd1xuICogQGNhdGVnb3J5IGdyaWRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIHJvdyBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIGA8b25zLWNvbD5gIHRvIGxheW91dCBjb21wb25lbnRzLlsvZW5dXG4gKiAgIFtqYV3jgrDjg6rjg4Pjg4njgrfjgrnjg4bjg6DjgavjgabooYzjgpLlrprnvqnjgZfjgb7jgZnjgIJvbnMtY29s44Go44Go44KC44Gr5L2/55So44GX44CB44Kz44Oz44Od44O844ON44Oz44OI44Gu6YWN572u44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICogQGd1aWRlIExheW91dGluZ1xuICogICBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1cbiAqICAgW2phXeODrOOCpOOCouOCpuODiOiqv+aVtFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtY29sXG4gKiAgIFtlbl1UaGUgYDxvbnMtY29sPmAgY29tcG9uZW50IGlzIHVzZWQgYXMgY2hpbGRyZW4gb2YgYDxvbnMtcm93PmAuWy9lbl1cbiAqICAgW2phXW9ucy1jb2zjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQG5vdGVcbiAqICAgW2VuXUZvciBBbmRyb2lkIDQuMyBhbmQgZWFybGllciwgYW5kIGlPUzYgYW5kIGVhcmxpZXIsIHdoZW4gdXNpbmcgbWl4ZWQgYWxpZ25tZW50IHdpdGggb25zLXJvdyBhbmQgb25zLWNvbCwgdGhleSBtYXkgbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuIFlvdSBjYW4gdXNlIG9ubHkgb25lIHZlcnRpY2FsLWFsaWduLlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbOOCkue1hOOBv+WQiOOCj+OBm+OBpuOBneOCjOOBnuOCjOOBrm9ucy1jb2zopoHntKDjga52ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+WIpeOAheOBruWApOOCkuaMh+WumuOBmeOCi+OBqOOAgeaPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAgnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr44Gv5LiA44Gk44Gu5YCk44Gg44GR44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJvdz5cbiAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XG4gKiAgIDxvbnMtY29sPlRleHQ8L29ucy1jb2w+XG4gKiA8L29ucy1yb3c+XG4gKi9cblxuLyoqXG4gKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TaG9ydCBoYW5kIGF0dHJpYnV0ZSBmb3IgYWxpZ25pbmcgdmVydGljYWxseS4gVmFsaWQgdmFsdWVzIGFyZSB0b3AsIGJvdHRvbSwgYW5kIGNlbnRlci5bL2VuXVxuICogICBbamFd57im44Gr5pW05YiX44GZ44KL44Gf44KB44Gr5oyH5a6a44GX44G+44GZ44CCdG9w44CBYm90dG9t44CBY2VudGVy44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqL1xud2luZG93Lk9uc1Jvd0VsZW1lbnQgPSB3aW5kb3cuT25zUm93RWxlbWVudCA/IHdpbmRvdy5PbnNSb3dFbGVtZW50IDogZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcm93Jyk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbF9faXRlbS0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqIEBjYXRlZ29yeSBzcGVlZC1kaWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIHRoZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgTWF0ZXJpYWwgRGVzaWduIFNwZWVkIGRpYWwgY29tcG9uZW50LlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAgTWF0ZXJpYWwgRGVzaWdu44GuU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOePvuOBmeOCi+imgee0oOOBp+OBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gZFlRWUxnXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5jbGFzcyBTcGVlZERpYWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1taW5pJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZC1kaWFsX19pdGVtJyk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cbn1cblxud2luZG93Lk9uc1NwZWVkRGlhbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbC1pdGVtJywge1xuICBwcm90b3R5cGU6IFNwZWVkRGlhbEl0ZW1FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbC0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsXG4gKiBAY2F0ZWdvcnkgc3BlZWQtZGlhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cbiAqXG4gKiAgICAgVGhlIFNwZWVkIGRpYWwgbG9va3MgbGlrZSBhIGA8b25zLWZhYj5gIGVsZW1lbnQgYnV0IHdpbGwgZXhwYW5kIGEgbWVudSB3aGVuIHRhcHBlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5jbGFzcyBTcGVlZERpYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqICAgICBJLmUuIHRvIGRpc3BsYXkgaXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIgc3BlY2lmeSBcInJpZ2h0IHRvcFwiLlxuICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44Gu5oyH5a6a44Gr44Gv44CBcmlnaHTjgahsZWZ044CBdG9w44GoYm90dG9t44GM44Gd44KM44Ge44KM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOimgee0oOOBjOihqOekuuOBmeOCi+aWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAgnVwLCBkb3duLCBsZWZ0LCByaWdodOOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3BlZWRfX2RpYWwnKTtcblxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKGN1cnJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5oYXNBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIDogJ3VwJyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnb25zLXNwZWVkLWRpYWwtaXRlbScpKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5fc2hvd24pIHtcbiAgICAgIHRoaXMudG9nZ2xlSXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIGNvbnN0IGZhYiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG5cbiAgICBpZiAoZmFiKSB7XG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZSgncmlwcGxlJykgPyBmYWIuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJykgOiBmYWIucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAyNSAqIGkgKyAnbXMnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUud2Via2l0VHJhbnNpdGlvbkRlbGF5ID0gMjUgKiBpICsgJ21zJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmJvdHRvbSA9ICdhdXRvJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICB9XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmJvdHRvbSA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnOHB4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1mYWInKS5zaG93KCk7XG4gICAgdGhpcy5fc2hvd24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1mYWInKS5oaWRlKCk7XG4gICAgfSwgMjAwKTtcbiAgICB0aGlzLl9zaG93biA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93SXRlbXMoKSB7XG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gMjUgKiBpICsgJ21zJztcbiAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUud2Via2l0VHJhbnNpdGlvbkRlbGF5ID0gMjUgKiBpICsgJ21zJztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXRlbVNob3duID0gdHJ1ZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgaGlkZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlSXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKSArICdtcyc7XG4gICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EZWxheSA9IDI1ICogKGNoaWxkcmVuLmxlbmd0aCAtIGkpICsgJ21zJztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjbG9zZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfVxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZSA9PiB7XG4gICAgICB1dGlsLm1hdGNoKGUsICcuZmFiJykgJiYgdXRpbC50b2dnbGVBdHRyaWJ1dGUoZSwgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGlubGluZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGlubGluZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44Kk44Oz44Op44Kk44Oz6KaB57Sg44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvd24gJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc09wZW5cbiAgICogQHNpZ25hdHVyZSBpc09wZW4oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtZW51IGlzIG9wZW4gb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1TaG93bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlSXRlbXNcbiAgICogQHNpZ25hdHVyZSB0b2dnbGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgaXRlbSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlSXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvd0l0ZW1zKCk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNTcGVlZERpYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbCcsIHtcbiAgcHJvdG90eXBlOiBTcGVlZERpYWxFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRnJhZ21lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgbGluayhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICogQGNhdGVnb3J5IHNwbGl0dGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBlbGVtZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5jbGFzcyBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHVybCBvZiB0aGUgY29udGVudCBwYWdlLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB1c2VkIHRoZSBjb250ZW50IHdpbGwgYmUgbG9hZGVkIGZyb20gYSBgPG9ucy10ZW1wbGF0ZT5gIHRhZyBvciBhIHJlbW90ZSBmaWxlLlxuICAgKlxuICAgKiAgICAgSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwdXQgYDxvbnMtcGFnZT5gIGVsZW1lbnQgYXMgYSBjaGlsZCBvZiB0aGUgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIm9ucy1zcGxpdHRlci1jb250ZW50XCIgbXVzdCBoYXZlIFwib25zLXNwbGl0dGVyXCIgYXMgcGFyZW50Tm9kZS5gKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ3BhZ2UnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7fVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdwYWdlJyAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB0aGlzLmxvYWQoY3VycmVudCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBlbGVtZW50IGxvYWRlZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIHJldHVybiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKSwgb3B0aW9ucywgZnJhZ21lbnQgPT4ge1xuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cbiAgICAgICAgdGhpcy5fc2hvdygpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICByZXNvbHZlKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxufVxuXG53aW5kb3cuT25zU3BsaXR0ZXJDb250ZW50RWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyLWNvbnRlbnQnLCB7XG4gIHByb3RvdHlwZTogU3BsaXR0ZXJDb250ZW50RWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG53aW5kb3cuT25zU3BsaXR0ZXJDb250ZW50RWxlbWVudC5yZXdyaXRhYmxlcyA9IHJld3JpdGFibGVzO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG5jbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfb25DbGljayhldmVudCkge1xuICAgIGlmICh1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3NpZGVzLmZvckVhY2goc2lkZSA9PiBzaWRlLmNsb3NlKCdsZWZ0JykuY2F0Y2goKCkgPT4ge30pKTtcbiAgICB9XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gIH1cbn1cblxud2luZG93Lk9uc1NwbGl0dGVyTWFza0VsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1zcGxpdHRlci1tYXNrJywge1xuICBwcm90b3R5cGU6IFNwbGl0dGVyTWFza0VsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgIGR1cmF0aW9uOiAnMC4zJyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHVwZGF0ZU9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdXRpbC5leHRlbmQodGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5fdGltaW5nID0gdGhpcy5fb3B0aW9ucy50aW1pbmc7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLmR1cmF0aW9uO1xuICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5fb3B0aW9ucy5kZWxheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNpZGVFbGVtZW50XG4gICAqL1xuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2lkZSA9IHNpZGVFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGVudCA9IHNwbGl0dGVyLmNvbnRlbnQ7XG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcbiAgICB9KTtcbiAgfVxuXG4gIGluYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IHRoaXMuX3NpZGUgPSB0aGlzLl9tYXNrID0gbnVsbDtcbiAgfVxuXG4gIGdldCBtaW51cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5fc2lkZSA9PT0gJ3JpZ2h0JyA/ICctJyA6ICcnO1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXN9MTAwJSwgMHB4LCAwcHgpYFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy5fdGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXJcbiAqIEBjYXRlZ29yeSBzcGxpdHRlclxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBlbmFibGVzIHJlc3BvbnNpdmUgbGF5b3V0IGJ5IGltcGxlbWVudGluZyBib3RoIGEgdHdvLWNvbHVtbiBsYXlvdXQgYW5kIGEgc2xpZGluZyBtZW51IGxheW91dC5cbiAqXG4gKiAgICBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IGV4cGFuZCBpbnRvIGEgY29sdW1uIGxheW91dCBvbiBsYXJnZSBzY3JlZW5zIGFuZCBjb2xsYXBzZSB0aGUgbWVudSBvbiBzbWFsbGVyIHNjcmVlbnMuIFdoZW4gdGhlIG1lbnUgaXMgY29sbGFwc2VkIHRoZSB1c2VyIGNhbiBvcGVuIGl0IGJ5IHN3aXBpbmcuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgQ2FsbGluZ0NvbXBvbmVudEFQSXNmcm9tSmF2YVNjcmlwdFxuICogICBbZW5dVXNpbmcgY29tcG9uZW50cyBmcm9tIEphdmFTY3JpcHRbL2VuXVxuICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlciBpZD1cInNwbGl0dGVyXCI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2Ugc3dpcGVhYmxlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNwbGl0dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0dGVyJyk7XG4gKiAgIHNwbGl0dGVyLmxlZnQub3BlbigpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmNsYXNzIFNwbGl0dGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfZ2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGUgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZSwgJ29ucy1zcGxpdHRlci1zaWRlJykgJiYgZS5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcbiAgICB9KTtcbiAgICBlbGVtZW50ICYmIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlZnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUxlZnQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdsZWZ0Jyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSByaWdodFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmlnaHQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgncmlnaHQnKTtcbiAgfVxuXG4gIGdldCBfc2lkZXMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxlZnQsIHRoaXMucmlnaHRdLmZpbHRlcihlID0+IGUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY29udGVudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHJpZXZlIHRoZSBiYWNrIGJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlcuimgee0oOOBq+e0kOS7mOOBhOOBpuOBhOOCi+ODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOCkuWPluW+l+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgIHRoaXMuX3NpZGVzLnNvbWUocyA9PiBzLmlzT3BlbiA/IHMuY2xvc2UoKSA6IGZhbHNlKSB8fCBoYW5kbGVyLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gIH1cblxuICBfb25Nb2RlQ2hhbmdlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfbGF5b3V0KCkge1xuICAgIHRoaXMuX3NpZGVzLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbc2lkZS5fc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLl93aWR0aCA6IDA7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYm91bmRPbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uTW9kZUNoYW5nZSA9IHRoaXMuX29uTW9kZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLm1hc2spIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgdGhpcy5fYm91bmRPbkRldmljZUJhY2tCdXR0b24pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fYm91bmRPbk1vZGVDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIF9zaG93KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG59XG5cbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1zcGxpdHRlcicsIHtcbiAgcHJvdG90eXBlOiBTcGxpdHRlckVsZW1lbnQucHJvdG90eXBlXG59KTtcblxud2luZG93Lk9uc1NwbGl0dGVyRWxlbWVudC5fYW5pbWF0b3JEaWN0ID0ge1xuICBkZWZhdWx0OiBTcGxpdHRlckFuaW1hdG9yLFxuICBvdmVybGF5OiBTcGxpdHRlckFuaW1hdG9yXG59O1xuXG53aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvciBpbnN0YW5jZW9mIFNwbGl0dGVyQW5pbWF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xuICB9XG4gIHdpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xufTtcblxud2luZG93Lk9uc1NwbGl0dGVyRWxlbWVudC5TcGxpdHRlckFuaW1hdG9yID0gU3BsaXR0ZXJBbmltYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgT25zU3BsaXR0ZXJFbGVtZW50O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL29ucy1zcGxpdHRlci9hbmltYXRvcic7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgT25zU3BsaXR0ZXJFbGVtZW50IGZyb20gJy4vb25zLXNwbGl0dGVyJztcblxuY29uc3QgU1BMSVRfTU9ERSA9ICdzcGxpdCc7XG5jb25zdCBDT0xMQVBTRV9NT0RFID0gJ2NvbGxhcHNlJztcbmNvbnN0IENMT1NFRF9TVEFURSA9ICdjbG9zZWQnO1xuY29uc3QgT1BFTl9TVEFURSA9ICdvcGVuJztcbmNvbnN0IENIQU5HSU5HX1NUQVRFID0gJ2NoYW5naW5nJztcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwbGl0dGVyU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHNwbGl0dGVyU2lkZUVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEZyYWdtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGxpbmsoc3BsaXR0ZXJTaWRlRWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gIH1cbn07XG5cbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGFyZ2V0ICYmIHRoaXMuY2hhbmdlVGFyZ2V0KHRhcmdldCk7XG4gIH1cblxuICBjaGFuZ2VUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXS5pbmRleE9mKHRhcmdldCkgIT09IC0xO1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9tYXRjaCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldCA9PT0gKHZhbHVlLmlzUG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubWF0Y2hlcztcbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUodGhpcy5fbWF0Y2godmFsdWUpID8gQ09MTEFQU0VfTU9ERSA6IFNQTElUX01PREUpO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvbnMub3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2Uoe2lzUG9ydHJhaXQ6IG9ucy5vcmllbnRhdGlvbi5pc1BvcnRyYWl0KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSB3aW5kb3cubWF0Y2hNZWRpYSh0aGlzLl90YXJnZXQpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQuYWRkTGlzdGVuZXIodGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLl9xdWVyeVJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIG9ucy5vcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcXVlcnlSZXN1bHQpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKHBhcmVudC5vZmZzZXRXaWR0aCAqIHZhbHVlIC8gMTAwKTtcbn07XG5cbmNsYXNzIENvbGxhcHNlTW9kZSB7XG4gIGdldCBfYW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuX2FuaW1hdG9yO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2xvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICBoYW5kbGVHZXN0dXJlKGUpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9sb2NrLmlzTG9ja2VkKCkgfHwgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vbkRyYWdTdGFydChlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBlLnR5cGUgPT09ICdkcmFnZW5kJyA/IHRoaXMuX29uRHJhZ0VuZChlKSA6IHRoaXMuX29uRHJhZyhlKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBzY3JvbGxpbmcgPSAhL2xlZnR8cmlnaHQvLnRlc3QoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24pO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZWxlbWVudC5fc2lkZSA9PT0gJ2xlZnQnID8gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WCA6IHdpbmRvdy5pbm5lcldpZHRoIC0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fZWxlbWVudC5fc3dpcGVUYXJnZXRXaWR0aDtcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3BlbigpO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBzY3JvbGxpbmcgfHwgKGFyZWEgJiYgZGlzdGFuY2UgPiBhcmVhICYmICFpc09wZW4pO1xuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFRvUHgodGhpcy5fZWxlbWVudC5fd2lkdGgsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gaXNPcGVuID8gdGhpcy5fd2lkdGggOiAwO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSk7XG4gICAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qge19kaXN0YW5jZTogZGlzdGFuY2UsIF93aWR0aDogd2lkdGgsIF9lbGVtZW50OiBlbH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcbiAgICBjb25zdCBzaG91bGRPcGVuID0gZWwuX3NpZGUgIT09IGRpcmVjdGlvbiAmJiBkaXN0YW5jZSA+IHdpZHRoICogZWwuX3RocmVzaG9sZDtcbiAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScpO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnRlciBjb2xsYXBzZSBtb2RlXG4gIGVudGVyTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhpdCBjb2xsYXBzZSBtb2RlXG4gIGV4aXRNb2RlKCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgX2lzT3Blbk90aGVyU2lkZU1lbnUoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbikuc29tZShlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUgIT09IHRoaXMuX2VsZW1lbnQgJiYgZS5pc09wZW47XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSAnb3Blbicgb3IgJ2Nsb3NlJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRBbmltYXRpb25dXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVcbiAgICovXG4gIGV4ZWN1dGVBY3Rpb24obmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgRklOQUxfU1RBVEUgPSBuYW1lID09PSAnb3BlbicgPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gRklOQUxfU1RBVEUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sb2NrLmlzTG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BsaXR0ZXIgc2lkZSBpcyBsb2NrZWQuJyk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnb3BlbicgJiYgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgbWVudSBpcyBhbHJlYWR5IG9wZW4uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHByZSR7bmFtZX1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke25hbWV9IGV2ZW50LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9sb2NrLmxvY2soKTtcbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUgPSBGSU5BTF9TVEFURTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuX2VtaXRFdmVudChgcG9zdCR7bmFtZX1gKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLndpdGhvdXRBbmltYXRpb24pIHtcbiAgICAgIGRvbmUoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fYW5pbWF0b3JbbmFtZV0oKCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1zaWRlXG4gKiBAY2F0ZWdvcnkgc3BsaXR0ZXJcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGVpdGhlciB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBgPG9ucy1zcGxpdHRlLWNvbnRlbnQ+YCBlbGVtZW50LlxuICpcbiAqICAgIEl0IHN1cHBvcnRzIHR3byBtb2RlczogY29sbGFwc2VkIGFuZCBzcGxpdC4gV2hlbiBpdCdzIGluIGNvbGxhcHNlZCBtb2RlIGl0IHdpbGwgYmUgaGlkZGVuIGZyb20gdmlldyBhbmQgY2FuIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHN3aXBlcyB0aGUgc2NyZWVuIG9yIHRhcHMgYSBidXR0b24uIEluIHNwbGl0IG1vZGUgdGhlIGVsZW1lbnQgaXMgYWx3YXlzIHNob3duLiBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCBiZXR3ZWVuIHRoZSB0d28gbW9kZXMgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gc2l6ZS5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBpcyB0aGUgcGFyZW50IGNvbXBvbmVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5jbGFzcyBTcGxpdHRlclNpZGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY29tcG9uZW50J3MgbW9kZSBjaGFuZ2VzLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruODouODvOODieOBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQubW9kZVxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IG1vZGUuIENhbiBiZSBlaXRoZXIgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/liY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmcgbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/jga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nLW1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24uIFVzZSBvbmUgb2YgYFwib3ZlcmxheVwiYCwgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm92ZXJsYXlcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3Blbi10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgIDAuM1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGhvdyBtdWNoIHRoZSBtZW51IG5lZWRzIHRvIGJlIHN3aXBlZCBiZWZvcmUgb3BlbmluZy4gQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDFgLlsvZW5dXG4gICAqICBbamFd44Gp44Gu44GP44KJ44GE44K544Ov44Kk44OX44GZ44KM44Gw44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844KS6ZaL44GP44GL44Gp44GG44GL44Gu5Ymy5ZCI44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTHjga7plpPjga7mlbDlgKTjgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg6/jgqTjg5fjga7ot53pm6LjgYzjgZPjgZPjgafmjIflrprjgZfjgZ/mlbDlgKTmjpvjgZHjgovjgZPjga7opoHntKDjga7luYXjgojjgorjgoLlpKfjgY3jgZHjgozjgbDjgIHjgrnjg6/jgqTjg5fjgYzntYLjgo/jgaPjgZ/mmYLjgavjgZPjga7opoHntKDjgpLplovjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8wLjPjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xsYXBzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSBjb2xsYXBzZSBiZWhhdmlvci4gVmFsaWQgdmFsdWVzIGFyZSBgXCJwb3J0cmFpdFwiYCwgYFwibGFuZHNjYXBlXCJgIG9yIGEgbWVkaWEgcXVlcnkuXG4gICAqICAgICBUaGUgc3RyaW5ncyBgXCJwb3J0cmFpdFwiYCBhbmQgYFwibGFuZHNjYXBlXCJgIG1lYW5zIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiBkZXZpY2UgaXMgaW4gbGFuZHNjYXBlIG9yIHBvcnRyYWl0IG9yaWVudGF0aW9uLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIGEgbWVkaWEgcXVlcnksIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiB0aGUgbWVkaWEgcXVlcnkgcmVzb2x2ZXMgdG8gYHRydWVgLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmlldyBhbHdheXMgYmUgaW4gYFwiY29sbGFwc2VcImAgbW9kZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOW3puWBtOOBruODmuODvOOCuOOCkumdnuihqOekuuOBq+OBmeOCi+adoeS7tuOCkuaMh+WumuOBl+OBvuOBmeOAgnBvcnRyYWl0LCBsYW5kc2NhcGXjgIF3aWR0aCAjcHjjgoLjgZfjgY/jga/jg6Hjg4fjgqPjgqLjgq/jgqjjg6rjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJcbiAgICogICAgIHBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GZ44KL44Go44CB44OH44OQ44Kk44K544Gu55S76Z2i44GM57im5ZCR44GN44KC44GX44GP44Gv5qiq5ZCR44GN44Gr44Gq44Gj44Gf5pmC44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOWApOOBq+S9leOCguaMh+WumuOBl+OBquOBhOWgtOWQiOOBq+OBr+OAgeW4uOOBq2NvbGxhcHNl44Oi44O844OJ44Gr44Gq44KK44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGUtdGFyZ2V0LXdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgc3BlY2lmaWVkIGluIGVpdGhlciBwaXhlbHMgb3IgYXMgYSBwZXJjZW50YWdlLCBlLmcuIGA5MCVgIG9yIGAyMDBweGAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaWRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGxlZnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgd2hpY2ggc2lkZSBvZiB0aGUgc2NyZWVuIHRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyBsb2NhdGVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImxlZnRcImAgYW5kIGBcInJpZ2h0XCJgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBjOW3puOBi+WPs+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+WApOOBr1wibGVmdFwi44GLXCJyaWdodFwi44Gu44G/44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLiBUaGlzIGF0dHJpYnV0ZSBpcyByZWFkIG9ubHkuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44GM6Kit5a6a44GV44KM44G+44GZ44CCXCJjb2xsYXBzZVwi44KC44GX44GP44GvXCJzcGxpdFwi44GM5oyH5a6a44GV44KM44G+44GZ44CC44GT44Gu5bGe5oCn44Gv6Kqt44G/6L6844G/5bCC55So44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBVUkwgb2YgdGhlIG1lbnUgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gZW5hYmxlIHN3aXBlIGludGVyYWN0aW9uIG9uIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4nmmYLjgavjgrnjg6/jgqTjg5fmk43kvZzjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29sbGFwc2VNb2RlID0gbmV3IENvbGxhcHNlTW9kZSh0aGlzKTtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogT25zU3BsaXR0ZXJFbGVtZW50Ll9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFNwbGl0dGVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnU3BsaXR0ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgICB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUgPSAoZSkgPT4gdGhpcy5fY29sbGFwc2VNb2RlLmhhbmRsZUdlc3R1cmUoZSk7XG4gICAgdGhpcy5fd2F0Y2hlZEF0dHJpYnV0ZXMgPSBbJ2FuaW1hdGlvbicsICd3aWR0aCcsICdzaWRlJywgJ2NvbGxhcHNlJywgJ3N3aXBlYWJsZScsICdzd2lwZS10YXJnZXQtd2lkdGgnLCAnYW5pbWF0aW9uLW9wdGlvbnMnLCAnb3Blbi10aHJlc2hvbGQnLCAncGFnZSddO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG11c3QgYmUgYW4gb25zLXNwbGl0dGVyIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLnBhcmVudEVsZW1lbnQsIHtkcmFnTWluRGlzdGFuY2U6IDF9KTtcblxuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NpZGUnLCAnbGVmdCcpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl93YXRjaGVkQXR0cmlidXRlcy5mb3JFYWNoKGUgPT4gdGhpcy5fdXBkYXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICB0aGlzLl91cGRhdGUobmFtZSwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZShuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSAnX3VwZGF0ZScgKyBuYW1lLnNwbGl0KCctJykubWFwKGUgPT4gZVswXS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSkuam9pbignJyk7XG4gICAgcmV0dXJuIHRoaXNbbmFtZV0odmFsdWUpO1xuICB9XG5cbiAgX2VtaXRFdmVudChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgIT09ICdwcmUnKSB7XG4gICAgICByZXR1cm4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtzaWRlOiB0aGlzfSk7XG4gICAgfVxuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge1xuICAgICAgc2lkZTogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICB9XG5cbiAgX3VwZGF0ZUNvbGxhcHNlKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKFNQTElUX01PREUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnY29sbGFwc2UnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShDT0xMQVBTRV9NT0RFKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5jaGFuZ2VUYXJnZXQodmFsdWUpO1xuICB9XG5cbiAgLy8gcmVhZG9ubHkgYXR0cmlidXRlIGZvciB0aGUgdXNlcnNcbiAgX3VwZGF0ZU1vZGUobW9kZSkge1xuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuX2NvbGxhcHNlTW9kZVttb2RlID09PSBDT0xMQVBTRV9NT0RFID8gJ2VudGVyTW9kZScgOiAnZXhpdE1vZGUnXSgpO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBtb2RlKTtcblxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdtb2RlY2hhbmdlJywge3NpZGU6IHRoaXMsIG1vZGU6IG1vZGV9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUGFnZShwYWdlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSkge1xuICAgIGlmIChwYWdlICE9PSBudWxsKSB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB0aGlzLmxvYWQocGFnZSkpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVPcGVuVGhyZXNob2xkKHRocmVzaG9sZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB7XG4gICAgdGhpcy5fdGhyZXNob2xkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDAuMykpO1xuICB9XG5cbiAgX3VwZGF0ZVN3aXBlYWJsZShzd2lwZWFibGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGVhYmxlJykpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzd2lwZWFibGUgPT09IG51bGwgPyAnb2ZmJyA6ICdvbic7XG5cbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0IGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFnZW5kJywgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlU3dpcGVUYXJnZXRXaWR0aCh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSkge1xuICAgIHRoaXMuX3N3aXBlVGFyZ2V0V2lkdGggPSBNYXRoLm1heCgwLCBwYXJzZUludCh2YWx1ZSkgfHwgMCk7XG4gIH1cblxuICBfdXBkYXRlV2lkdGgod2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgIHRoaXMuX3dpZHRoID0gL15cXGQrKHB4fCUpJC8udGVzdCh3aWR0aCkgPyB3aWR0aCA6ICc4MCUnO1xuICAgIHRoaXMuc3R5bGUud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgfVxuXG4gIF91cGRhdGVTaWRlKHNpZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgdGhpcy5fc2lkZSA9IHNpZGUgPT09ICdyaWdodCcgPyBzaWRlIDogJ2xlZnQnO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbihhbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykpIHtcbiAgICB0aGlzLl9hbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcih7YW5pbWF0aW9ufSk7XG4gICAgdGhpcy5fYW5pbWF0b3IuYWN0aXZhdGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0aW9uT3B0aW9ucyh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSB7XG4gICAgdGhpcy5fYW5pbWF0b3IudXBkYXRlT3B0aW9ucyhBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIHNpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmlzT3BlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb3BlblxuICAgKiBAc2lnbmF0dXJlIG9wZW4oW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBvcGVuKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGUuZXhlY3V0ZUFjdGlvbignb3BlbicsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvc2VcbiAgICogQHNpZ25hdHVyZSBjbG9zZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBjbG9zZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ2Nsb3NlJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4gPyB0aGlzLmNsb3NlKG9wdGlvbnMpIDogdGhpcy5vcGVuKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBwYWdlVXJsIGluIHRoZSByaWdodCBzZWN0aW9uWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIHV0aWwuY3JlYXRlRnJhZ21lbnQoaHRtbCksIG9wdGlvbnMsIGZyYWdtZW50ID0+IHtcbiAgICAgICAgdGhpcy5faGlkZSgpO1xuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXG4gICAgICAgIHRoaXMuX3Nob3coKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cbn1cblxud2luZG93Lk9uc1NwbGl0dGVyU2lkZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1zcGxpdHRlci1zaWRlJywge1xuICBwcm90b3R5cGU6IFNwbGl0dGVyU2lkZUVsZW1lbnQucHJvdG90eXBlXG59KTtcblxud2luZG93Lk9uc1NwbGl0dGVyU2lkZUVsZW1lbnQucmV3cml0YWJsZXMgPSByZXdyaXRhYmxlcztcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3dpdGNoLS0qJyxcbiAgJy5zd2l0Y2hfX2lucHV0JzogJ3N3aXRjaC0tKl9faW5wdXQnLFxuICAnLnN3aXRjaF9faGFuZGxlJzogJ3N3aXRjaC0tKl9faGFuZGxlJyxcbiAgJy5zd2l0Y2hfX3RvZ2dsZSc6ICdzd2l0Y2gtLSpfX3RvZ2dsZSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXG4gIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInN3aXRjaF9faW5wdXRcIj5cbiAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG9nZ2xlXCI+XG4gICAgPGRpdiBjbGFzcz1cInN3aXRjaF9faGFuZGxlXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoX190b3VjaFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBsb2NhdGlvbnMgPSB7XG4gIGlvczogWzEsIDIxXSxcbiAgbWF0ZXJpYWw6IFswLCAxNl1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxuICogQGNhdGVnb3J5IHN3aXRjaFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBTd2l0Y2ggY29tcG9uZW50LiBUaGUgc3dpdGNoIGNhbiBiZSB0b2dnbGVkIGJvdGggYnkgZHJhZ2dpbmcgYW5kIHRhcHBpbmcuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzd2l0Y2ggb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44K544Kk44OD44OB44KS6KGo56S644GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN3aXRjaFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gTHBYWlFRXG4gKiBAZ3VpZGUgVXNpbmdGb3JtQ29tcG9uZW50c1xuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBkaXNhYmxlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBtb2RpZmllcj1cIm1hdGVyaWFsXCI+PC9vbnMtc3dpdGNoPlxuICovXG5cbmNsYXNzIFN3aXRjaEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN3aXRjaCBpcyB0b2dnbGVkLlsvZW5dXG4gICAqICAgW2phXU9OL09GRuOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgKiAgIFtlbl1Td2l0Y2ggb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn1N3aXRjaOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICogICBbZW5dVHJ1ZSBpZiB0aGUgY2hhbmdlIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgarjganjga7jg6bjg7zjgrbjga7mk43kvZzjgavjgojjgaPjgablpInjgo/jgaPjgZ/loLTlkIjjgavjga90cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44KS54Sh5Yq544Gu54q25oWL44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBgaWRgIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgaWYgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWx1ZSkge1xuICAgIGlmICghIXZhbHVlICE9PSB0aGlzLl9jaGVja2JveC5jaGVja2VkKSB7XG4gICAgICB0aGlzLl9jaGVja2JveC5jbGljaygpO1xuICAgICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NoZWNrZWQnLCB0aGlzLmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2JveC5kaXNhYmxlZDtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2NoZWNrYm94LmRpc2FibGVkID0gdmFsdWU7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHRoaXMuZGlzYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2JveFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHVuZGVybHlpbmcgY2hlY2tib3ggZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXpg6jjga5jaGVja2JveOimgee0oOOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94O1xuICB9XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tib3ggPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hfX2lucHV0Jyk7XG4gICAgdGhpcy5faGFuZGxlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc3dpdGNoX19oYW5kbGUnKTtcblxuICAgIFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdtb2RpZmllcicsICduYW1lJywgJ2lucHV0LWlkJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gnKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2NoZWNrYm94LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2NoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDEsIGhvbGRUaW1lb3V0OiAyNTF9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgdGhpcy5fYm91bmRPblJlbGVhc2UgPSB0aGlzLl9vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3N3aXRjaF9fdG91Y2gnKSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBjbGljaygpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcy5jaGVja2JveCwgJ2NoYW5nZScpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICByZXR1cm4gTWF0aC5taW4obFsxXSwgTWF0aC5tYXgobFswXSwgdGhpcy5fc3RhcnRYICsgZS5nZXN0dXJlLmRlbHRhWCkpO1xuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07Ly8gLSBlLmdlc3R1cmUuZGVsdGFYO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5nZXN0dXJlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSB0aGlzLl9nZXRQb3NpdGlvbihlKSArICdweCc7XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oZSk7XG5cbiAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICB0aGlzLl9pc01hdGVyaWFsID0gKGN1cnJlbnQgfHwgJycpLmluZGV4T2YoJ21hdGVyaWFsJykgIT09IC0xO1xuICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbdGhpcy5faXNNYXRlcmlhbCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgdGhpcy5fY2hlY2tib3guaWQgPSBjdXJyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLl9jaGVja2JveC5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zU3dpdGNoRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXN3aXRjaCcsIHtcbiAgcHJvdG90eXBlOiBTd2l0Y2hFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgVGFiYmFyQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC40JztcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbGVhdmVQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVudGVyUGFnZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmJhck5vbmVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVySW5kZXgsIGxlYXZlSW5kZXgsIGRvbmUpIHtcbiAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgLyA2MCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhckZhZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnbGluZWFyJztcbiAgICBvcHRpb25zLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6ICcwLjQnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogJzAnO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFiYmFyU2xpZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnZWFzZS1pbic7XG4gICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC4xNSc7XG4gICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7anFMaXRlfSBsZWF2ZVBhZ2VcbiAgICovXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgY29uc3Qgc2duID0gZW50ZXJJbmRleCA+IGxlYXZlSW5kZXg7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoJyArIChzZ24gPyAnJyA6ICctJykgKyAnMTAwJSwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJy0nIDogJycpICsgJzEwMCUsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1RhYmJhckFuaW1hdG9yLCBUYWJiYXJGYWRlQW5pbWF0b3IsIFRhYmJhck5vbmVBbmltYXRvciwgVGFiYmFyU2xpZGVBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYi1iYXJfX2NvbnRlbnQnOiAndGFiLWJhci0tKl9fY29udGVudCcsXG4gICcudGFiLWJhcic6ICd0YWItYmFyLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBUYWJiYXJOb25lQW5pbWF0b3IsXG4gICdmYWRlJzogVGFiYmFyRmFkZUFuaW1hdG9yLFxuICAnc2xpZGUnOiBUYWJiYXJTbGlkZUFuaW1hdG9yLFxuICAnbm9uZSc6IFRhYmJhck5vbmVBbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKHRhYmJhckVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHVubGluayh0YWJiYXJFbGVtZW50LCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtdGFiYmFyLWdlbi0nICsgKGkrKyk7XG59KSgpO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJiYXJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQSBjb21wb25lbnQgdG8gZGlzcGxheSBhIHRhYiBiYXIgb24gdGhlIGJvdHRvbSBvZiBhIHBhZ2UuIFVzZWQgd2l0aCBgPG9ucy10YWI+YCB0byBtYW5hZ2UgcGFnZXMgdXNpbmcgdGFicy5bL2VuXVxuICogICBbamFd44K/44OW44OQ44O844KS44Oa44O844K45LiL6YOo44Gr6KGo56S644GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCb25zLXRhYuOBqOe1hOOBv+WQiOOCj+OBm+OBpuS9v+OBhuOBk+OBqOOBp+OAgeODmuODvOOCuOOCkueuoeeQhuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQGd1aWRlIFVzaW5nVGFiQmFyXG4gKiAgIFtlbl1Vc2luZyB0YWIgYmFyWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgQ2FsbGluZ0NvbXBvbmVudEFQSXNmcm9tSmF2YVNjcmlwdFxuICogICBbZW5dVXNpbmcgbmF2aWdhdG9yIGZyb20gSmF2YVNjcmlwdFsvZW5dXG4gKiAgIFtqYV1KYXZhU2NyaXB044GL44KJ44Kz44Oz44Od44O844ON44Oz44OI44KS5ZG844Gz5Ye644GZWy9qYV1cbiAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWI+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy10YWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1wYWdlPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKi9cbmNsYXNzIFRhYmJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYmVmb3JlIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBjaGFuZ2UgZXZlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Ki44Kv44OG44Kj44OW44Gq44K/44OW44Gu5aSJ5pu044GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGFmdGVyIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgaPjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGlmIHRoZSBhbHJlYWR5IG9wZW4gdGFiIGlzIHRhcHBlZCBhZ2Fpbi5bL2VuXVxuICAgKiAgIFtqYV3jgZnjgafjgavjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjgYzjgoLjgYbkuIDluqbjgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZXjgozjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwibm9uZVwiYCwgYFwic2xpZGVcImAgYW5kIGBcImZhZGVcImAuIERlZmF1bHQgaXMgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjoqq3jgb/ovrzjgb/mmYLjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOAgVwiZmFkZVwi44CBXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJub25lXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGFiYmFyJ3MgcG9zaXRpb24uIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcImJvdHRvbVwiYCBhbmQgYFwidG9wXCJgLiBVc2UgYFwiYXV0b1wiYCB0byBjaG9vc2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHBsYXRmb3JtIChpT1MgYm90dG9tLCBBbmRyb2lkIHRvcCkuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpcnN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maXJzdENoaWxkLmNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpO1xuXG4gICAgICBpZiAoYWN0aXZlSW5kZXggJiYgdGhpcy5jaGlsZHJlblsxXS5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzFdLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgICBiYXNlQ2xhc3M6IFRhYmJhckFuaW1hdG9yLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lOiAnVGFiYmFyQW5pbWF0b3InLFxuICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHZhciBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5vbnMtdGFiLWJhcl9fY29udGVudC50YWItYmFyX19jb250ZW50Jyk7XG4gICAgdmFyIHRhYmJhciA9IHV0aWwuY3JlYXRlKCcudGFiLWJhci5vbnMtdGFiLWJhcl9fZm9vdGVyLm9ucy10YWJiYXItaW5uZXInKTtcblxuICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0YWJiYXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSkge1xuICAgIHZhciB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xuICAgIHZhciBhY3Rpb24gPSB0b3AgPyB1dGlsLmFkZE1vZGlmaWVyIDogdXRpbC5yZW1vdmVNb2RpZmllcjtcblxuICAgIGFjdGlvbih0aGlzLCAndG9wJyk7XG5cbiAgICB2YXIgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpIDogJyc7XG5cbiAgICAgIGlmICh1dGlsLm1hdGNoKHBhZ2UuZmlyc3RDaGlsZCwgJ29ucy10b29sYmFyJykpIHtcbiAgICAgICAgYWN0aW9uKHBhZ2UuZmlyc3RDaGlsZCwgJ25vc2hhZG93Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCB0b3AgJiYgIWZpbGxlZCk7XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0VGFiYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkUGFnZVxuICAgKiBAc2lnbmF0dXJlIGxvYWRQYWdlKHVybCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gYDxvbnMtdGVtcGxhdGU+YCBpZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44GfaWTlsZ7mgKfjga7lgKTjgpLliKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheXMgYSBuZXcgcGFnZSB3aXRob3V0IGNoYW5naW5nIHRoZSBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Ki44Kv44OG44Kj44OW44Gq44Kk44Oz44OH44OD44Kv44K544KS5aSJ5pu044Gb44Ga44Gr44CB5paw44GX44GE44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBPbnNUYWJFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlUGFnZUVsZW1lbnQocGFnZSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFnZUVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgKi9cbiAgX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgcGFnZUVsZW1lbnQsIG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLl9zd2l0Y2hQYWdlKHBhZ2VFbGVtZW50LCBvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb2xkUGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0VGFiYmFySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmJhcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnQvbnVsbH1cbiAgICovXG4gIF9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKSB7XG4gICAgdmFyIHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgdmFyIHBhZ2UgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWdlc1tpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFnZSAmJiBwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogcGFnZSBlbGVtZW50IG11c3QgYmUgYSBcIm9ucy1wYWdlXCIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZTtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJldmlvdXNUYWJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5cbiAgICovXG4gIF9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2xkUGFnZUVsZW1lbnQgPSB0aGlzLl9vbGRQYWdlRWxlbWVudCB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdmFyIGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICBvbGRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRvci5hcHBseShlbGVtZW50LCBvbGRQYWdlRWxlbWVudCwgb3B0aW9ucy5zZWxlY3RlZFRhYkluZGV4LCBvcHRpb25zLnByZXZpb3VzVGFiSW5kZXgsICgpID0+IHtcbiAgICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICAgIG9sZFBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBlbGVtZW50Ll9zaG93KCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZVRhYlxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZVRhYihpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGFiIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBQYWdlXVxuICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBwYWdlIHdpbGwgbm90IGJlIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM54++5Zyo6KGo56S644GX44Gm44GE44KLcGFnZeOCkuWkieOBiOOBquOBhOWgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAsIGBcInNsaWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgmBcImZhZGVcImDjgIFgXCJzbGlkZVwiYOOAgWBcIm5vbmVcImDjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCBvdGhlciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZVRhYihpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRpb24gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNUYWIgPSB0aGlzLl9nZXRBY3RpdmVUYWJFbGVtZW50KCksXG4gICAgICBzZWxlY3RlZFRhYiA9IHRoaXMuX2dldFRhYkVsZW1lbnQoaW5kZXgpLFxuICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXggPSBpbmRleCxcbiAgICAgIHByZXZpb3VzUGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcblxuICAgIGlmICghc2VsZWN0ZWRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkVGFiSW5kZXggPT09IHByZXZpb3VzVGFiSW5kZXgpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XG4gICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJldmlvdXNQYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWNoYW5nZScsIHtcbiAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICAgIHByZXZpb3VzVGFiLnNldEFjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRUYWIuc2V0QWN0aXZlKCk7XG5cbiAgICB2YXIgbmVlZExvYWQgPSAhc2VsZWN0ZWRUYWIuaXNMb2FkZWQoKSAmJiAhb3B0aW9ucy5rZWVwUGFnZTtcblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbikuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICBpZiAodGFiICE9IHNlbGVjdGVkVGFiKSB7XG4gICAgICAgIHRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuZWVkTG9hZCkge1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5lZWRMb2FkKSB7XG4gICAgICB2YXIgcmVtb3ZlRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoKCFwcmV2aW91c1RhYiAmJiBwcmV2aW91c1BhZ2VFbGVtZW50KSB8fCAocHJldmlvdXNUYWIgJiYgcHJldmlvdXNUYWIuX3BhZ2VFbGVtZW50ICE9PSBwcmV2aW91c1BhZ2VFbGVtZW50KSkge1xuICAgICAgICByZW1vdmVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91c1RhYkluZGV4OiBwcmV2aW91c1RhYkluZGV4LFxuICAgICAgICBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgcGFyYW1zLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMuYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuXG4gICAgICBjb25zdCBsaW5rID0gKGVsZW1lbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZWxlY3RlZFRhYi5fbG9hZFBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQZXJzaXN0ZW50UGFnZURPTShwYWdlRWxlbWVudCwgcGFyYW1zKSk7XG4gICAgICAgIH0sIGxpbmspO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqL1xuICBfbG9hZFBlcnNpc3RlbnRQYWdlRE9NKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCF1dGlsLmlzQXR0YWNoZWQoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHJldHVybiB0aGlzLl9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VGFiYmFyVmlzaWJpbGl0eVxuICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIGhpZGUgb3Igc2hvdyB0aGUgdGFiIGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc3R5bGVbdGhpcy5fdG9wID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcbiAgICB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZVRhYkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGFiIGluZGV4IG9uIGN1cnJlbnQgYWN0aXZlIHRhYi4gSWYgYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgdmFyIHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldIGluc3RhbmNlb2Ygd2luZG93Lk9uc1RhYkVsZW1lbnQgJiYgdGFic1tpXS5pc0FjdGl2ZSAmJiB0YWJzW2ldLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2hlbiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5cbiAgICovXG4gIF9nZXRBY3RpdmVUYWJFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUYWJFbGVtZW50KHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIF9nZXRUYWJFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbltpbmRleF07XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkgeyB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHsgfVxuXG4gIF9zaG93KCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYWdlc1tpXS5fZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zVGFiYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRhYmJhcicsIHtcbiAgcHJvdG90eXBlOiBUYWJiYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gKi9cbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUYWJiYXJBbmltYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvcicpO1xuICB9XG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG53aW5kb3cuT25zVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvciA9IFRhYmJhckFuaW1hdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBPbnNUYWJiYXJFbGVtZW50O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgT25zVGFiYmFyRWxlbWVudCBmcm9tICcuL29ucy10YWJiYXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcvb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndGFiLWJhci0tKl9faXRlbScsXG4gICcudGFiLWJhcl9fYnV0dG9uJzogJ3RhYi1iYXItLSpfX2J1dHRvbidcbn07XG5jb25zdCB0ZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPlxuICAgIDxidXR0b24gY2xhc3M9XCJ0YWItYmFyX19idXR0b24gdGFiLWJhci1pbm5lclwiPjwvYnV0dG9uPlxuICA8L2Rpdj5cbmApO1xuY29uc3QgZGVmYXVsdElubmVyVGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0YWItYmFyX19pY29uXCI+XG4gICAgICA8b25zLWljb24gaWNvbj1cImlvbi1jbG91ZFwiPjwvb25zLWljb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2xhYmVsXCI+bGFiZWw8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYiBiYXIuIEVhY2ggYDxvbnMtdGFiPmAgcmVwcmVzZW50cyBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCv+ODluODkOODvOOBq+mFjee9ruOBleOCjOOCi+WQhOOCouOCpOODhuODoOOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBneOCjOOBnuOCjOOBrm9ucy10YWLjga/jg5rjg7zjgrjjgpLooajjgZfjgb7jgZnjgIJcbiAqICAgICBvbnMtdGFi6KaB57Sg44Gu5Lit44Gr44Gv44CB44K/44OW44Gr6KGo56S644GV44KM44KL44Kz44Oz44OG44Oz44OE44KS55u05o6l6KiY6L+w44GZ44KL44GT44Go44GM5Ye65p2l44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQGd1aWRlIFVzaW5nVGFiQmFyXG4gKiAgIFtlbl1Vc2luZyB0YWIgYmFyWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgRGVmaW5pbmdNdWx0aXBsZVBhZ2VzaW5TaW5nbGVIVE1MXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1vbnMtdGFiYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdGFiYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1vbnMtcGFnZSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXW9ucy1pY29uIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtaWNvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG5cbiAqL1xuY2xhc3MgVGFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdGhhdCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFiIGlzIHRhcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1vbnMtdGFi44GM5Y+C54Wn44GZ44KL44Oa44O844K444G444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lIGZvciB0aGUgdGFiLiBDYW4gc3BlY2lmeSB0aGUgc2FtZSBpY29uIG5hbWUgYXMgYDxvbnMtaWNvbj5gLlxuICAgKiAgICAgSWYgeW91IG5lZWQgdG8gdXNlIHlvdXIgb3duIGljb24sIGNyZWF0ZSBhIENTUyBjbGFzcyB3aXRoIGBiYWNrZ3JvdW5kLWltYWdlYCBvciBhbnkgQ1NTIHByb3BlcnRpZXMgYW5kIHNwZWNpZnkgdGhlIG5hbWUgb2YgeW91ciBDU1MgY2xhc3MgaGVyZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgm9ucy1pY29u44Go5ZCM44GY44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBsYWJlbCBvZiB0aGUgdGFiIGl0ZW0uWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz5LiL44Gr6KGo56S644GV44KM44KL44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIHRoZSB0YWIgdGhhdCBpcyBhY3RpdmUgYnkgZGVmYXVsdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdsYWJlbCcpIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykpIHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgbGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBoYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd0YWItYmFyX19pdGVtJyk7XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2J1dHRvbicpO1xuXG4gICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICBidXR0b24uYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICAvLyB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19idXR0b24nKSwgdGhpcyk7XG4gIH1cblxuICBfdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCkge1xuICAgIGlmICghdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcblxuICAgIGNvbnN0IHRlbXBsYXRlID0gZGVmYXVsdElubmVyVGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKSkge1xuICAgICAgYnV0dG9uLmluc2VydEJlZm9yZSh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpLCBidXR0b24uZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJykpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJyk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcblxuICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGdldEljb25FbGVtZW50KCkuc2V0QXR0cmlidXRlKCdpY29uJywgaWNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKTtcbiAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGdldExhYmVsRWxlbWVudCgpLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWxFbGVtZW50KCk7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SWNvbkVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5xdWVyeVNlbGVjdG9yKCdvbnMtaWNvbicpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNsaWNrKCkge1xuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG4gICAgaWYgKHRhYmJhcikge1xuICAgICAgdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLl9maW5kVGFiSW5kZXgoKSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlKCkge1xuICAgIGNvbnN0IHJhZGlvID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gICAgcmFkaW8uY2hlY2tlZCA9IHRydWU7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItaW5hY3RpdmVdLCBvbnMtdGFiLWluYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1hY3RpdmVdLCBvbnMtdGFiLWFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCcpO1xuICB9XG5cbiAgc2V0SW5hY3RpdmUoKSB7XG4gICAgY29uc3QgcmFkaW8gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKTtcbiAgICByYWRpby5jaGVja2VkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItaW5hY3RpdmVdLCBvbnMtdGFiLWluYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0Jyk7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1hY3RpdmVdLCBvbnMtdGFiLWFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua1xuICAgKi9cbiAgX2xvYWRQYWdlRWxlbWVudChjYWxsYmFjaywgbGluaykge1xuICAgIGlmICghdGhpcy5wYWdlRWxlbWVudCkge1xuICAgICAgdGhpcy5fY3JlYXRlUGFnZUVsZW1lbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSwgKGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGluayhlbGVtZW50LCBlbGVtZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnBhZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodGhpcy5wYWdlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBhZ2VFbGVtZW50KGVsKSB7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSBlbDtcbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcblxuICAgIHJldHVybiB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgICAgY2FsbGJhY2sodXRpbC5jcmVhdGVFbGVtZW50KGh0bWwudHJpbSgpKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnRQb3NpdGlvbigpO1xuXG4gICAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xuXG4gICAgICBpZiAodGFiYmFyLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpICsgJyAnIDogJyc7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHByZWZpeCArIHRhYmJhci5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZScpKSB7XG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5fZmluZFRhYkluZGV4KCk7XG5cbiAgICAgICAgT25zVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsICgpID0+IHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGFiYmFyLnNldEFjdGl2ZVRhYih0YWJJbmRleCwge2FuaW1hdGlvbjogJ25vbmUnfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9uc1RhYmJhckVsZW1lbnQucmV3cml0YWJsZXMucmVhZHkodGFiYmFyLCAoKSA9PiB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgncGFnZScpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBhZ2VFbGVtZW50KHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyksIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBPbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLmxpbmsodGFiYmFyLCBwYWdlRWxlbWVudCwge30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMucGFnZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgIHRhYmJhci5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5wYWdlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgX2ZpbmRUYWJiYXJFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfZmluZFRhYkluZGV4KCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzID09PSBlbGVtZW50c1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlRWxlbWVudFBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG9ucy10YWIgZWxlbWVudCBpcyBtdXN0IGJlIGNoaWxkIG9mIG9ucy10YWJiYXIgZWxlbWVudC4nKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zVGFiRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRhYicsIHtcbiAgcHJvdG90eXBlOiBUYWJFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRhYmJhci1pdGVtJywge1xuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoVGFiRWxlbWVudC5wcm90b3R5cGUpXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAndG9vbGJhci1idXR0b24tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSB0b29sYmFyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXJcbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIG5hdmlnYXRpb24gYmFyIGF0IHRoZSB0b3Agb2YgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24gYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgQnV0dG9uXG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICA8b25zLWljb24gaWNvbj1cImlvbi1uYXZpY29uXCIgc2l6ZT1cIjI4cHhcIj48L29ucy1pY29uPlxuICogICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cbmNsYXNzIFRvb2xiYXJCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd0b29sYmFyLWJ1dHRvbicpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc1Rvb2xiYXJCdXR0b24gPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10b29sYmFyLWJ1dHRvbicsIHtcbiAgcHJvdG90eXBlOiBUb29sYmFyQnV0dG9uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnbmF2aWdhdGlvbi1iYXItLSonLFxuICAnLm5hdmlnYXRpb24tYmFyX19sZWZ0JzogJ25hdmlnYXRpb24tYmFyLS0qX19sZWZ0JyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fY2VudGVyJzogJ25hdmlnYXRpb24tYmFyLS0qX19jZW50ZXInLFxuICAnLm5hdmlnYXRpb24tYmFyX19yaWdodCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fcmlnaHQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dVHJhbnNwYXJlbnQgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUb29sYmFyIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbmF2aWdhdGlvbi5cbiAqXG4gKiAgICAgTGVmdCwgY2VudGVyIGFuZCByaWdodCBjb250YWluZXIgY2FuIGJlIHNwZWNpZmllZCBieSBjbGFzcyBuYW1lcy5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgd2hlbiBydW5uaW5nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODiuODk+OCsuODvOOCt+ODp+ODs+OBp+S9v+eUqOOBmeOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOCr+ODqeOCueWQjeOBq+OCiOOCiuOAgeW3puOAgeS4reWkruOAgeWPs+OBruOCs+ODs+ODhuODiuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQGd1aWRlIEFkZGluZ2F0b29sYmFyIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1bamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1ib3R0b20tdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLWJvdHRvbS10b29sYmFyPmAgZGlzcGxheXMgYSB0b29sYmFyIG9uIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1ib3R0b20tdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhY2sgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgdG9vbGJhciBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhci1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICA8b25zLWJhY2stYnV0dG9uPlxuICogICAgICAgICBCYWNrXG4gKiAgICAgICA8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICBUaXRsZVxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuXG5jbGFzcyBUb29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmxpbmVcbiAgICogQGluaXRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IHRoZSB0b29sYmFyIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOCkuOCpOODs+ODqeOCpOODs+OBq+e9ruOBjeOBvuOBmeOAguOCueOCr+ODreODvOODq+mgmOWfn+WGheOBq+OBneOBruOBvuOBvuihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCk7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSk7XG4gIH1cblxuICBfdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG5cbiAgICBpZiAocGFnZSAmJiBwYWdlICE9PSB0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHBhZ2UuX3JlZ2lzdGVyVG9vbGJhcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxlZnQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5jZW50ZXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJpZ2h0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9fbGFiZWwnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXInKTtcbiAgICB0aGlzLl9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX190aXRsZScpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnbGVmdCcpO1xuICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgncmlnaHQnKTtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy4nICsgbmFtZSkgfHwgdXRpbC5jcmVhdGUoJy4nICsgbmFtZSk7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX18nICsgbmFtZSk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG53aW5kb3cuT25zVG9vbGJhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10b29sYmFyJywge1xuICBwcm90b3R5cGU6IFRvb2xiYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhbmdlJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9fbGVmdCc6ICdyYW5nZS0tKl9fbGVmdCdcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8ZGl2PlxuICA8ZGl2IGNsYXNzPVwicmFuZ2VfX2xlZnRcIj48L2Rpdj5cbiAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwicmFuZ2VcIj5cbjwvZGl2PmApO1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ25hbWUnLFxuICAncGxhY2Vob2xkZXInLFxuICAncmVhZG9ubHknLFxuICAnc2l6ZScsXG4gICdzdGVwJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJhbmdlXG4gKiBAY2F0ZWdvcnkgcmFuZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNsaWRlclsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBSYW5nZSBpbnB1dCBjb21wb25lbnQuIFVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSBzbGlkZXIuXG4gKlxuICogICAgIFdvcmtzIHZlcnkgc2ltaWxhciB0byB0aGUgYDxpbnB1dCB0eXBlPVwicmFuZ2VcIj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geFpRb21NXG4gKiBAZ3VpZGUgVXNpbmdGb3JtQ29tcG9uZW50c1xuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgdGV4dCBpbnB1dHMsIHJhZGlvIGJ1dHRvbnMgYW5kIGNoZWNrYm94ZXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yYW5nZSB2YWx1ZT1cIjIwXCI+PC9vbnMtcmFuZ2U+XG4gKiA8b25zLXJhbmdlIG1vZGlmaWVyPVwibWF0ZXJpYWxcIiB2YWx1ZT1cIjEwXCI+PC9yYW5nZT5cbiAqL1xuY2xhc3MgUmFuZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcucmFuZ2VfX2xlZnQnKSAmJiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKSkpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fbGVmdC5zdHlsZS53aWR0aCA9ICgxMDAgKiB0aGlzLl9yYXRpbykgKyAnJSc7XG4gIH1cblxuICBnZXQgX3JhdGlvKCkge1xuICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmF0aW8uXG4gICAgY29uc3QgbWluID0gdGhpcy5faW5wdXQubWluID09PSAnJyA/IDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5taW4pO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2lucHV0Lm1heCA9PT0gJycgPyAxMDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5tYXgpO1xuXG4gICAgcmV0dXJuICh0aGlzLnZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ21pbicgfHwgbmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2xlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJhbmdlX19sZWZ0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbndpbmRvdy5PbnNSYW5nZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1yYW5nZScsIHtcbiAgcHJvdG90eXBlOiBSYW5nZUVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsImltcG9ydCBvbnMgZnJvbSAnLi9vbnMvb25zJztcblxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNvbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWhlYWRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtaXRlbSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pbnB1dCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLW1vZGFsJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbmF2aWdhdG9yJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcGFnZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXB1bGwtaG9vayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJpcHBsZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJvdyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXN3aXRjaCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYmJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9vbGJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhbmdlJztcblxuLy8gZmFzdGNsaWNrXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcbn0sIGZhbHNlKTtcblxuLy8gb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICB9KTtcbiAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XG59LCBmYWxzZSk7XG5cbi8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbm9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgb25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMoKTtcbn0pO1xuXG4vLyB2aWV3cG9ydC5qc1xubmV3IFZpZXdwb3J0KCkuc2V0dXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
