/*! onsenui v2.2.3 - 2017-04-07 */
if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		// Ignore touches on contenteditable elements to prevent conflict with text selection.
		// (For details: https://github.com/ftlabs/fastclick/pull/211 )
		if (targetElement.isContentEditable) {
			return true;
		}

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;

    this._events[event] = this._events[event]
      .filter(function(_fct) {
        if (fct) {
           return fct !== _fct;
        }
        else {
          return false;
        }
      });
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (!window.Promise) {
    window.Promise = Promise;
  }
})(this);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(self));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ons = factory());
}(this, (function () { 'use strict';

// For @webcomponents/custom-elements
if (window.customElements) {
    // even if native CE1 impl exists, use polyfill
    window.customElements.forcePolyfill = true;
}

(function () {
  'use strict';
  var g = new function () {}();var aa = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function k(b) {
    var a = aa.has(b);b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);return !a && b;
  }function l(b) {
    var a = b.isConnected;if (void 0 !== a) return a;for (; b && !(b.__CE_isImportDocument || b instanceof Document);) {
      b = b.parentNode || (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    }return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling;) {
      a = a.parentNode;
    }return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();for (var c = b; c;) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;a(d);var h = d.localName;if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;if (c instanceof Node && !e.has(c)) for (e.add(c), c = c.firstChild; c; c = c.nextSibling) {
            n(c, a, e);
          }c = m(b, d);continue;
        } else if ("template" === h) {
          c = m(b, d);continue;
        }if (d = d.__CE_shadowRoot) for (d = d.firstChild; d; d = d.nextSibling) {
          n(d, a, e);
        }
      }c = c.firstChild ? c.firstChild : m(b, c);
    }
  }function q(b, a, e) {
    b[a] = e;
  }function r() {
    this.a = new Map();this.f = new Map();this.c = [];this.b = !1;
  }function ba(b, a, e) {
    b.a.set(a, e);b.f.set(e.constructor, e);
  }function t(b, a) {
    b.b = !0;b.c.push(a);
  }function v(b, a) {
    b.b && n(a, function (a) {
      return w(b, a);
    });
  }function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;for (var e = 0; e < b.c.length; e++) {
        b.c[e](a);
      }
    }
  }function x(b, a) {
    var e = [];n(a, function (b) {
      return e.push(b);
    });for (a = 0; a < e.length; a++) {
      var c = e[a];1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];n(a, function (b) {
      return e.push(b);
    });for (a = 0; a < e.length; a++) {
      var c = e[a];1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();var c = [];n(a, function (d) {
      if ("link" === d.localName && "import" === d.getAttribute("rel")) {
        var a = d.import;a instanceof Node && "complete" === a.readyState ? (a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0) : d.addEventListener("load", function () {
          var a = d.import;a.__CE_documentLoadHandled || (a.__CE_documentLoadHandled = !0, a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0, new Set(e), e.delete(a), A(b, a, e));
        });
      } else c.push(d);
    }, e);if (b.b) for (a = 0; a < c.length; a++) {
      w(b, c[a]);
    }for (a = 0; a < c.length; a++) {
      y(b, c[a]);
    }
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);if (e) {
        e.constructionStack.push(a);var c = e.constructor;try {
          try {
            if (new c() !== a) throw Error("The custom element constructor did not produce the element being upgraded.");
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw a.__CE_state = 2, f;
        }a.__CE_state = 1;a.__CE_definition = e;if (e.attributeChangedCallback) for (e = e.observedAttributes, c = 0; c < e.length; c++) {
          var d = e[c],
              h = a.getAttribute(d);null !== h && b.attributeChangedCallback(a, d, null, h, null);
        }l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function (b) {
    var a = b.__CE_definition;a.connectedCallback && a.connectedCallback.call(b);
  };r.prototype.disconnectedCallback = function (b) {
    var a = b.__CE_definition;a.disconnectedCallback && a.disconnectedCallback.call(b);
  };r.prototype.attributeChangedCallback = function (b, a, e, c, d) {
    var h = b.__CE_definition;h.attributeChangedCallback && -1 < h.observedAttributes.indexOf(a) && h.attributeChangedCallback.call(b, a, e, c, d);
  };function B(b, a) {
    this.c = b;this.a = a;this.b = void 0;A(this.c, this.a);"loading" === this.a.readyState && (this.b = new MutationObserver(this.f.bind(this)), this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }function C(b) {
    b.b && b.b.disconnect();
  }B.prototype.f = function (b) {
    var a = this.a.readyState;"interactive" !== a && "complete" !== a || C(this);for (a = 0; a < b.length; a++) {
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) {
        A(this.c, e[c]);
      }
    }
  };function ca() {
    var b = this;this.b = this.a = void 0;this.c = new Promise(function (a) {
      b.b = a;b.a && a(b.a);
    });
  }function D(b) {
    if (b.a) throw Error("Already resolved.");b.a = void 0;b.b && b.b(void 0);
  }function E(b) {
    this.f = !1;this.a = b;this.h = new Map();this.g = function (b) {
      return b();
    };this.b = !1;this.c = [];this.j = new B(b, document);
  }
  E.prototype.l = function (b, a) {
    var e = this;if (!(a instanceof Function)) throw new TypeError("Custom element constructors must be functions.");if (!k(b)) throw new SyntaxError("The element name '" + b + "' is not valid.");if (this.a.a.get(b)) throw Error("A custom element with name '" + b + "' has already been defined.");if (this.f) throw Error("A custom element is already being defined.");this.f = !0;var c, d, h, f, u;try {
      var p = function p(b) {
        var a = P[b];if (void 0 !== a && !(a instanceof Function)) throw Error("The '" + b + "' callback must be a function.");
        return a;
      },
          P = a.prototype;if (!(P instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");c = p("connectedCallback");d = p("disconnectedCallback");h = p("adoptedCallback");f = p("attributeChangedCallback");u = a.observedAttributes || [];
    } catch (va) {
      return;
    } finally {
      this.f = !1;
    }ba(this.a, b, { localName: b, constructor: a, connectedCallback: c, disconnectedCallback: d, adoptedCallback: h, attributeChangedCallback: f, observedAttributes: u, constructionStack: [] });this.c.push(b);this.b || (this.b = !0, this.g(function () {
      if (!1 !== e.b) for (e.b = !1, A(e.a, document); 0 < e.c.length;) {
        var b = e.c.shift();(b = e.h.get(b)) && D(b);
      }
    }));
  };E.prototype.get = function (b) {
    if (b = this.a.a.get(b)) return b.constructor;
  };E.prototype.o = function (b) {
    if (!k(b)) return Promise.reject(new SyntaxError("'" + b + "' is not a valid custom element name."));var a = this.h.get(b);if (a) return a.c;a = new ca();this.h.set(b, a);this.a.a.get(b) && -1 === this.c.indexOf(b) && D(a);return a.c;
  };E.prototype.m = function (b) {
    C(this.j);var a = this.g;this.g = function (e) {
      return b(function () {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;E.prototype.define = E.prototype.l;E.prototype.get = E.prototype.get;E.prototype.whenDefined = E.prototype.o;E.prototype.polyfillWrapFlushCallback = E.prototype.m;var F = window.Document.prototype.createElement,
      da = window.Document.prototype.createElementNS,
      ea = window.Document.prototype.importNode,
      fa = window.Document.prototype.prepend,
      ga = window.Document.prototype.append,
      G = window.Node.prototype.cloneNode,
      H = window.Node.prototype.appendChild,
      I = window.Node.prototype.insertBefore,
      J = window.Node.prototype.removeChild,
      K = window.Node.prototype.replaceChild,
      L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
      M = window.Element.prototype.attachShadow,
      N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
      O = window.Element.prototype.getAttribute,
      Q = window.Element.prototype.setAttribute,
      R = window.Element.prototype.removeAttribute,
      S = window.Element.prototype.getAttributeNS,
      T = window.Element.prototype.setAttributeNS,
      U = window.Element.prototype.removeAttributeNS,
      V = window.Element.prototype.insertAdjacentElement,
      ha = window.Element.prototype.prepend,
      ia = window.Element.prototype.append,
      ja = window.Element.prototype.before,
      ka = window.Element.prototype.after,
      la = window.Element.prototype.replaceWith,
      ma = window.Element.prototype.remove,
      na = window.HTMLElement,
      W = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
      X = window.HTMLElement.prototype.insertAdjacentElement;function oa() {
    var b = Y;window.HTMLElement = function () {
      function a() {
        var a = this.constructor,
            c = b.f.get(a);if (!c) throw Error("The custom element being constructed was not registered with `customElements`.");var d = c.constructionStack;if (!d.length) return d = F.call(document, c.localName), Object.setPrototypeOf(d, a.prototype), d.__CE_state = 1, d.__CE_definition = c, w(b, d), d;var c = d.length - 1,
            h = d[c];if (h === g) throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
        d[c] = g;Object.setPrototypeOf(h, a.prototype);w(b, h);return h;
      }a.prototype = na.prototype;return a;
    }();
  }function pa(b, a, e) {
    a.prepend = function (a) {
      for (var d = [], c = 0; c < arguments.length; ++c) {
        d[c - 0] = arguments[c];
      }c = d.filter(function (b) {
        return b instanceof Node && l(b);
      });e.i.apply(this, d);for (var f = 0; f < c.length; f++) {
        z(b, c[f]);
      }if (l(this)) for (c = 0; c < d.length; c++) {
        f = d[c], f instanceof Element && x(b, f);
      }
    };a.append = function (a) {
      for (var d = [], c = 0; c < arguments.length; ++c) {
        d[c - 0] = arguments[c];
      }c = d.filter(function (b) {
        return b instanceof Node && l(b);
      });e.append.apply(this, d);for (var f = 0; f < c.length; f++) {
        z(b, c[f]);
      }if (l(this)) for (c = 0; c < d.length; c++) {
        f = d[c], f instanceof Element && x(b, f);
      }
    };
  }function qa() {
    var b = Y;q(Document.prototype, "createElement", function (a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);if (e) return new e.constructor();
      }a = F.call(this, a);w(b, a);return a;
    });q(Document.prototype, "importNode", function (a, e) {
      a = ea.call(this, a, e);this.__CE_hasRegistry ? A(b, a) : v(b, a);return a;
    });q(Document.prototype, "createElementNS", function (a, e) {
      if (this.__CE_hasRegistry && (null === a || "http://www.w3.org/1999/xhtml" === a)) {
        var c = b.a.get(e);if (c) return new c.constructor();
      }a = da.call(this, a, e);w(b, a);return a;
    });
    pa(b, Document.prototype, { i: fa, append: ga });
  }function ra() {
    var b = Y;function a(a, c) {
      Object.defineProperty(a, "textContent", { enumerable: c.enumerable, configurable: !0, get: c.get, set: function set(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);else {
            var d = void 0;if (this.firstChild) {
              var e = this.childNodes,
                  u = e.length;if (0 < u && l(this)) for (var d = Array(u), p = 0; p < u; p++) {
                d[p] = e[p];
              }
            }c.set.call(this, a);if (d) for (a = 0; a < d.length; a++) {
              z(b, d[a]);
            }
          }
        } });
    }q(Node.prototype, "insertBefore", function (a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);if (l(this)) for (c = 0; c < d.length; c++) {
          x(b, d[c]);
        }return a;
      }d = l(a);c = I.call(this, a, c);d && z(b, a);l(this) && x(b, a);return c;
    });q(Node.prototype, "appendChild", function (a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);a = H.call(this, a);if (l(this)) for (var d = 0; d < c.length; d++) {
          x(b, c[d]);
        }return a;
      }c = l(a);d = H.call(this, a);c && z(b, a);l(this) && x(b, a);return d;
    });q(Node.prototype, "cloneNode", function (a) {
      a = G.call(this, a);this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });q(Node.prototype, "removeChild", function (a) {
      var c = l(a),
          d = J.call(this, a);c && z(b, a);return d;
    });q(Node.prototype, "replaceChild", function (a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);a = K.call(this, a, c);if (l(this)) for (z(b, c), c = 0; c < d.length; c++) {
          x(b, d[c]);
        }return a;
      }var d = l(a),
          e = K.call(this, a, c),
          f = l(this);f && z(b, c);d && z(b, a);f && x(b, a);return e;
    });L && L.get ? a(Node.prototype, L) : t(b, function (b) {
      a(b, { enumerable: !0, configurable: !0, get: function get() {
          for (var a = [], b = 0; b < this.childNodes.length; b++) {
            a.push(this.childNodes[b].textContent);
          }return a.join("");
        }, set: function set(a) {
          for (; this.firstChild;) {
            J.call(this, this.firstChild);
          }H.call(this, document.createTextNode(a));
        } });
    });
  }function sa(b) {
    var a = Element.prototype;a.before = function (a) {
      for (var c = [], d = 0; d < arguments.length; ++d) {
        c[d - 0] = arguments[d];
      }d = c.filter(function (a) {
        return a instanceof Node && l(a);
      });ja.apply(this, c);for (var e = 0; e < d.length; e++) {
        z(b, d[e]);
      }if (l(this)) for (d = 0; d < c.length; d++) {
        e = c[d], e instanceof Element && x(b, e);
      }
    };a.after = function (a) {
      for (var c = [], d = 0; d < arguments.length; ++d) {
        c[d - 0] = arguments[d];
      }d = c.filter(function (a) {
        return a instanceof Node && l(a);
      });ka.apply(this, c);for (var e = 0; e < d.length; e++) {
        z(b, d[e]);
      }if (l(this)) for (d = 0; d < c.length; d++) {
        e = c[d], e instanceof Element && x(b, e);
      }
    };a.replaceWith = function (a) {
      for (var c = [], d = 0; d < arguments.length; ++d) {
        c[d - 0] = arguments[d];
      }var d = c.filter(function (a) {
        return a instanceof Node && l(a);
      }),
          e = l(this);la.apply(this, c);for (var f = 0; f < d.length; f++) {
        z(b, d[f]);
      }if (e) for (z(b, this), d = 0; d < c.length; d++) {
        e = c[d], e instanceof Element && x(b, e);
      }
    };a.remove = function () {
      var a = l(this);ma.call(this);a && z(b, this);
    };
  }function ta() {
    var b = Y;function a(a, c) {
      Object.defineProperty(a, "innerHTML", { enumerable: c.enumerable, configurable: !0, get: c.get, set: function set(a) {
          var d = this,
              e = void 0;l(this) && (e = [], n(this, function (a) {
            a !== d && e.push(a);
          }));c.set.call(this, a);if (e) for (var f = 0; f < e.length; f++) {
            var h = e[f];1 === h.__CE_state && b.disconnectedCallback(h);
          }this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);return a;
        } });
    }function e(a, c) {
      q(a, "insertAdjacentElement", function (a, d) {
        var e = l(d);a = c.call(this, a, d);e && z(b, d);l(a) && x(b, d);
        return a;
      });
    }M ? q(Element.prototype, "attachShadow", function (a) {
      return this.__CE_shadowRoot = a = M.call(this, a);
    }) : console.warn("Custom Elements: `Element#attachShadow` was not patched.");if (N && N.get) a(Element.prototype, N);else if (W && W.get) a(HTMLElement.prototype, W);else {
      var c = F.call(document, "div");t(b, function (b) {
        a(b, { enumerable: !0, configurable: !0, get: function get() {
            return G.call(this, !0).innerHTML;
          }, set: function set(a) {
            var b = "template" === this.localName ? this.content : this;for (c.innerHTML = a; 0 < b.childNodes.length;) {
              J.call(b, b.childNodes[0]);
            }for (; 0 < c.childNodes.length;) {
              H.call(b, c.childNodes[0]);
            }
          } });
      });
    }q(Element.prototype, "setAttribute", function (a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);var d = O.call(this, a);Q.call(this, a, c);c = O.call(this, a);d !== c && b.attributeChangedCallback(this, a, d, c, null);
    });q(Element.prototype, "setAttributeNS", function (a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);var d = S.call(this, a, c);T.call(this, a, c, e);e = S.call(this, a, c);d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });q(Element.prototype, "removeAttribute", function (a) {
      if (1 !== this.__CE_state) return R.call(this, a);var c = O.call(this, a);R.call(this, a);null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });q(Element.prototype, "removeAttributeNS", function (a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);var d = S.call(this, a, c);U.call(this, a, c);var e = S.call(this, a, c);d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });X ? e(HTMLElement.prototype, X) : V ? e(Element.prototype, V) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");
    pa(b, Element.prototype, { i: ha, append: ia });sa(b);
  } /*
     Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
     This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
     The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
     Code distributed by Google as part of the polymer project is also
     subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
     */
  var Z = window.customElements;if (!Z || Z.forcePolyfill || "function" != typeof Z.define || "function" != typeof Z.get) {
    var Y = new r();oa();qa();ra();ta();document.__CE_hasRegistry = !0;var ua = new E(Y);Object.defineProperty(window, "customElements", { configurable: !0, enumerable: !0, value: ua });
  }
}).call(self);

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.4.0' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var _isObject = function _isObject(it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var document$1 = _global.document;
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f$1 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
  f: f$1
};

var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide$1 = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide$1(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide$1(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else {
      if (!safe) {
        delete O[key];
        _hide$1(O, key, val);
      } else {
        if (O[key]) O[key] = val;else _hide$1(O, key, val);
      }
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE],
      exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {}),
      expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
      key,
      own,
      out,
      exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide$1(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library` 
var _export = $export;

var f$3 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$3
};

var toString$1 = {}.toString;

var _cof = function _cof(it) {
  return toString$1.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings

var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$2 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
  f: f$2
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */

var check = function check(O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

// 19.1.3.19 Object.setPrototypeOf(O, proto)

_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

// Caution:
// Do not replace this import statement with codes.
//
// If you replace this import statement with codes,
// the codes will be executed after the following polyfills are imported
// because import statements are hoisted during compilation.
// Polyfill Custom Elements v1 with global namespace pollution
// Polyfill `Object.setPrototypeOf` with global namespace pollution

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja][/ja]
 */
var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._renderPlatform = null;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja][/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._renderPlatform = platform.trim().toLowerCase();
      }
    }

    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ios';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'android';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Android[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'wp';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @methos isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'blackberry';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'opera';
      } else {
        return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
      }
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'firefox';
      } else {
        return typeof InstallTrigger !== 'undefined';
      }
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'safari';
      } else {
        return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {
          return p.toString() === '[object SafariRemoteNotification]';
        }(!window['safari'] || safari.pushNotification);
      }
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'chrome';
      } else {
        return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
      }
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ie';
      } else {
        return false || !!document.documentMode;
      }
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'edge';
      } else {
        return navigator.userAgent.indexOf(' Edge/') >= 0;
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      throw new Error('Variable name must be a string.');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      throw new Error('Variable value must be a string or a function.');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      throw new Error('"' + name + '" is already defined.');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      throw new Error('Unable to parse empty string.');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          throw new Error('Nested interpolation not supported.');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          throw new Error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      throw new Error('Unterminated interpolation.');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        throw new Error('Variable "' + name + '" does not exist.');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          throw new Error('Must return a string.');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false,
  warningsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  html = ('' + html).trim();

  if (!html.match(/^<ons-page/)) {
    html = '<ons-page _muted>' + html + '</ons-page>';
  }

  return html;
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    window.document.addEventListener('DOMContentLoaded', callback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
    document.removeEventListener('DOMContentLoaded', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    document.addEventListener('DOMContentLoaded', function () {
      onReady();
    });
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

window.document.addEventListener('DOMContentLoaded', function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
    }
  }
}, false);

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    setImmediate(function () {
      var cache = internal$1.templateStore.get(page);

      if (cache) {
        var html = typeof cache === 'string' ? cache : cache[1];
        resolve(html);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', page, true);
        xhr.onload = function (response) {
          var html = xhr.responseText;
          if (xhr.status >= 400 && xhr.status < 600) {
            reject(html);
          } else {
            resolve(html);
          }
        };
        xhr.onerror = function () {
          throw new Error('The page is not found: ' + page);
        };
        xhr.send(null);
      }
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).then(function (html) {
      return internal$1.normalizePageHTML(html);
    }, function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    }).then(function (html) {
      return internal$1.normalizePageHTML(html);
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      throw new Error('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.add(klass);
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.remove(klass);
      });
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      for (var selector in scheme) {
        if (scheme.hasOwnProperty(selector)) {
          var targetElements = !selector || util.match(element, selector) ? [element] : element.querySelectorAll(selector);
          for (var i = 0; i < targetElements.length; i++) {
            ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
          }
        }
      }
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }

    /**
     * Add modifier token to an element.
     */

  }, {
    key: 'addModifier',
    value: function addModifier(element, modifierToken) {
      if (!element.hasAttribute('modifier')) {
        element.setAttribute('modifier', modifierToken);
      } else {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        if (tokens.indexOf(modifierToken) == -1) {
          tokens.push(modifierToken);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }

    /**
     * Remove modifier token from an element.
     */

  }, {
    key: 'removeModifier',
    value: function removeModifier(element, modifierToken) {
      if (element.hasAttribute('modifier')) {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        var index = tokens.indexOf(modifierToken);
        if (index !== -1) {
          tokens.splice(index, 1);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      throw Error('"delegate" parameter must be an object.');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      throw Error('"templateElement" parameter must be an instance of Element or null.');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render() {
      this._userDelegate._render.apply(this._userDelegate, arguments);
    }

    /**
     * @param {Number} index
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, done);
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          throw Error('createItemContent() must return an instance of Element.');
        }

        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        throw Error('countItems() must return a number.');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          throw Error('calculateItemHeight() must return a number.');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;
    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
    }

    this.lastScrollTop = this._pageContent.scrollTop;
    this.padding = 0;
    this._topPositions = [0];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }

    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, function (item) {
        if (!_this._unknownItemHeight) {
          throw Error('Invalid state');
        }

        _this._wrapperElement.appendChild(item.element);

        var done = function done() {
          _this._delegate.destroyItem(0, item);
          _this._wrapperElement.removeChild(item.element);
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        var lastVisibility = _this._wrapperElement.style.visibility;
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            throw Error('Invalid state: this._itemHeight must be greater than zero.');
          }
          _this._wrapperElement.style.visibility = lastVisibility;
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      // Item is rendered
      if (this._renderedItems.hasOwnProperty(i)) {
        if (!this._renderedItems[i].hasOwnProperty('height')) {
          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;
        }
        return this._renderedItems[i].height;
      }

      // Item is not rendered, scroll up
      if (this._topPositions[i + 1] && this._topPositions[i]) {
        return this._topPositions[i + 1] - this._topPositions[i];
      }
      // Item is not rendered, scroll down
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_calculateRenderedHeight',
    value: function _calculateRenderedHeight() {
      var _this2 = this;

      return Object.keys(this._renderedItems).reduce(function (a, b) {
        return a + _this2._getItemHeight(+b);
      }, 0);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: '_lastItemRendered',
    value: function _lastItemRendered() {
      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: '_firstItemRendered',
    value: function _firstItemRendered() {
      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      var lastItemIndex = Math.min(this._lastItemRendered(), this._countItems() - 1);
      var firstItemIndex = this._firstItemRendered();
      this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';
      this.padding = this._topPositions[firstItemIndex];
      this._removeAllElements();
      this._render({ forceScrollDown: true, forceFirstIndex: firstItemIndex, forceLastIndex: lastItemIndex });
      this._wrapperElement.style.height = 'inherit';
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$forceScrollDown = _ref.forceScrollDown,
          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,
          forceFirstIndex = _ref.forceFirstIndex,
          forceLastIndex = _ref.forceLastIndex;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this, arguments[0]));
      }

      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;
      this.lastScrollTop = this._pageContent.scrollTop;
      var keep = {};

      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      var items = [];
      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30);
      var i = start;

      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        top += this._getItemHeight(i);
      }

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        return this._delegate._render(start, i, function () {
          _this3.padding = _this3._topPositions[start];
        });
      }

      if (isScrollUp) {
        for (var j = i - 1; j >= start; j--) {
          keep[j] = true;
          this._renderElement(j, isScrollUp);
        }
      } else {
        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems))));
        for (var _j = start; _j <= lastIndex; _j++) {
          keep[_j] = true;
          this._renderElement(_j, isScrollUp);
        }
      }

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this3._removeElement(key, isScrollUp);
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(index, isScrollUp) {
      var _this4 = this;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        return;
      }

      this._delegate.loadItemElement(index, function (item) {
        if (isScrollUp) {
          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);
          _this4.padding = _this4._topPositions[index];
          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];
        } else {
          _this4._wrapperElement.appendChild(item.element);
        }

        _this4._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      index = +index;
      var item = this._renderedItems[index];
      this._delegate.destroyItem(index, item);

      if (isScrollUp) {
        this._topPositions[index + 1] = undefined;
      } else {
        this.padding = this.padding + this._getItemHeight(index);
      }

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this5 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this5._removeElement(key);
      });
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions(start, end) {
      for (var i = start; i <= end; i++) {
        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var firstItemIndex = this._firstItemRendered();
      var lastItemIndex = this._lastItemRendered();

      // Fix for Safari scroll and Angular 2
      this._recalculateTopPositions(firstItemIndex, lastItemIndex);

      var start = 0;
      var end = this._countItems() - 1;

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this6 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this6, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'padding',
    get: function get() {
      return parseInt(this._wrapperElement.style.paddingTop, 10);
    },
    set: function set(newValue) {
      this._wrapperElement.style.paddingTop = newValue + 'px';
    }
  }, {
    key: 'staticItemHeight',
    get: function get() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.LazyRepeatProvider = LazyRepeatProvider;
internal$1.LazyRepeatDelegate = LazyRepeatDelegate;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'chevron': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  // Effects
  if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {

    if (element.tagName.toLowerCase() === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (/material/.test(element.getAttribute('modifier'))) {
    util.removeModifier(element, 'material');

    if (util.removeModifier(element, 'material--flat')) {
      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var prepareAutoStyle = function prepareAutoStyle(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      platforms[mobileOS](element);
    }
  }
};

var mapModifier = function mapModifier(modifier, element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      return modifiersMap.hasOwnProperty(modifier) ? modifiersMap[modifier] : modifier;
    }
  }

  return modifier;
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepareAutoStyle,
  mapModifier: mapModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var unwrap = function unwrap(string) {
  return string.slice(1, -1);
};
var isObjectString = function isObjectString(string) {
  return string.startsWith('{') && string.endsWith('}');
};
var isArrayString = function isArrayString(string) {
  return string.startsWith('[') && string.endsWith(']');
};
var isQuotedString = function isQuotedString(string) {
  return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
};

var error$1 = function error$1(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error$1(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trimLeft();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '\"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error$1(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error$1(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error$1(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util = {};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util.match(element, query);
  };
};

/**
 * @param {Element} e
 * @param {String/Function} s CSS Selector.
 * @return {Boolean}
 */
util.match = function (e, s) {
  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findChild = function (element, query) {
  var match = util.prepareQuery(query);

  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`
  for (var i = 0; i < element.childNodes.length; i++) {
    var node = element.childNodes[i];
    if (node.nodeType !== Node.ELEMENT_NODE) {
      // process only element nodes
      continue;
    }
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findParent = function (element, query) {
  var match = util.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document) {
      return null;
    }
    if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.isAttached = function (element) {
  while (document.documentElement !== element) {
    if (!element) {
      return false;
    }
    element = element.parentNode;
  }
  return true;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal|ons-sliding-menu|ons-split-view)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  util.extend(element.style, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util.createElement = function (html) {
  var wrapper = document.createElement('div');
  wrapper.innerHTML = html;

  if (wrapper.children.length > 1) {
    throw new Error('"html" must be one wrapper element.');
  }

  return wrapper.children[0];
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util.createFragment = function (html) {
  var wrapper = document.createElement('div');
  wrapper.innerHTML = html;
  var fragment = document.createDocumentFragment();

  while (wrapper.firstChild) {
    fragment.appendChild(wrapper.firstChild);
  }

  return fragment;
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {HTMLElement} container - Page or page-container that implements 'topPage'
 * @return {HTMLElement|null} - Visible page element or null if not found.
 */
util.getTopPage = function (container) {
  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;
};

/**
 * @param {HTMLElement} container - Element where the search begins
 * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.
 */
util.findToolbarPage = function (container) {
  var page = util.getTopPage(container);

  if (page) {
    if (util.findChild(page, 'ons-toolbar')) {
      return page;
    }

    for (var i = 0; i < page._contentElement.children.length; i++) {
      var nextPage = util.getTopPage(page._contentElement.children[i]);
      if (nextPage) {
        return util.findToolbarPage(nextPage);
      }
    }
  }

  return null;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }
  return target.getAttribute('modifier').split(/\s+/).some(function (e) {
    return e === modifierName;
  });
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was added or not.
 */
util.addModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (util.hasModifier(target, modifierName)) {
    return false;
  }

  modifierName = modifierName.trim();
  var modifierAttribute = target.getAttribute('modifier') || '';
  target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util.removeModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!target.getAttribute('modifier')) {
    return false;
  }

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  var modifiers = target.getAttribute('modifier').split(/\s+/);

  var newModifiers = modifiers.filter(function (item) {
    return item && item !== modifierName;
  });
  target.setAttribute('modifier', newModifiers.join(' '));

  return modifiers.length !== newModifiers.length;
};

// TODO: FIX
util.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util.toggleAttribute = function (element, name, value) {
  if (value) {
    element.setAttribute(name, value);
  } else {
    element.removeAttribute(name);
  }
};

util.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 * @param {Element} hasRipple
 */
util.updateRipple = function (target, hasRipple) {
  if (hasRipple === undefined) {
    hasRipple = target.hasAttribute('ripple');
  }

  var rippleElement = util.findChild(target, 'ons-ripple');

  if (hasRipple) {
    if (!rippleElement) {
      target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Obejct} Deferred promise.
 */
util.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/**
 * Show warnings when they are enabled.
 *
 * @param {*} arguments to console.warn
 */
util.warn = function () {
  if (!internal$1.config.warningsDisabled) {
    var _console;

    (_console = console).warn.apply(_console, arguments);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
var TIMEOUT_RATIO = 1.4;

var util$2 = {};

// capitalize string
util$2.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * @param {Object} params
 * @param {String} params.property
 * @param {Float} params.duration
 * @param {String} params.timing
 */
util$2.buildTransitionValue = function (params) {
  params.property = params.property || 'all';
  params.duration = params.duration || 0.4;
  params.timing = params.timing || 'linear';

  var props = params.property.split(/ +/);

  return props.map(function (prop) {
    return prop + ' ' + params.duration + 's ' + params.timing;
  }).join(', ');
};

/**
 * Add an event handler on "transitionend" event.
 */
util$2.onceOnTransitionEnd = function (element, callback) {
  if (!element) {
    return function () {};
  }

  var fn = function fn(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();

      callback();
    }
  };

  var removeListeners = function removeListeners() {
    util$2._transitionEndEvents.forEach(function (eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };

  util$2._transitionEndEvents.forEach(function (eventName) {
    element.addEventListener(eventName, fn, false);
  });

  return removeListeners;
};

util$2._transitionEndEvents = function () {

  if ('ontransitionend' in window) {
    return ['transitionend'];
  }

  if ('onwebkittransitionend' in window) {
    return ['webkitTransitionEnd'];
  }

  if (util$2.vendorPrefix === 'webkit' || util$2.vendorPrefix === 'o' || util$2.vendorPrefix === 'moz' || util$2.vendorPrefix === 'ms') {
    return [util$2.vendorPrefix + 'TransitionEnd', 'transitionend'];
  }

  return [];
}();

util$2._cssPropertyDict = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var dict = {};
  var a = 'A'.charCodeAt(0);
  var z = 'z'.charCodeAt(0);

  var upper = function upper(s) {
    return s.substr(1).toUpperCase();
  };

  for (var i = 0; i < styles.length; i++) {

    var key = styles[i].replace(/^[\-]+/, '').replace(/[\-][a-z]/g, upper).replace(/^moz/, 'Moz');

    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== 'cssText' && key !== 'parentText') {
        dict[key] = true;
      }
    }
  }

  return dict;
}();

util$2.hasCssProperty = function (name) {
  return name in util$2._cssPropertyDict;
};

/**
 * Vendor prefix for css property.
 */
util$2.vendorPrefix = function () {
  var styles = window.getComputedStyle(document.documentElement, ''),
      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
  return pre;
}();

util$2.forceLayoutAtOnce = function (elements, callback) {
  this.batchImmediate(function () {
    elements.forEach(function (element) {
      // force layout
      element.offsetHeight;
    });
    callback();
  });
};

util$2.batchImmediate = function () {
  var callbacks = [];

  return function (callback) {
    if (callbacks.length === 0) {
      setImmediate(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$2.batchAnimationFrame = function () {
  var callbacks = [];

  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    setTimeout(callback, 1000 / 60);
  };

  return function (callback) {
    if (callbacks.length === 0) {
      raf(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$2.transitionPropertyName = function () {
  if (util$2.hasCssProperty('transitionDuration')) {
    return 'transition';
  }

  if (util$2.hasCssProperty(util$2.vendorPrefix + 'TransitionDuration')) {
    return util$2.vendorPrefix + 'Transition';
  }

  throw new Error('Invalid state');
}();

/**
 * @param {HTMLElement} element
 */
var Animit = function Animit(element) {
  if (!(this instanceof Animit)) {
    return new Animit(element);
  }

  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === '[object Array]') {
    this.elements = element;
  } else {
    throw new Error('First argument must be an array or an instance of HTMLElement.');
  }

  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};

Animit.prototype = {

  /**
   * @property {Array}
   */
  transitionQueue: undefined,

  /**
   * @property {Array}
   */
  elements: undefined,

  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function play(callback) {
    if (typeof callback === 'function') {
      this.transitionQueue.push(function (done) {
        callback();
        done();
      });
    }

    this.startAnimation();

    return this;
  },

  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function queue(transition, options) {
    var queue = this.transitionQueue;

    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }

    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }

    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error('Invalid arguments');
    }

    return this;
  },

  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function wait(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function (done) {
        setTimeout(done, 1000 * seconds);
      });
    }

    return this;
  },

  saveStyle: function saveStyle() {

    this.transitionQueue.push(function (done) {
      this.elements.forEach(function (element, index) {
        var css = this.lastStyleAttributeDict[index] = {};

        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }.bind(this));
      done();
    }.bind(this));

    return this;
  },

  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function restoreStyle(options) {
    options = options || {};
    var self = this;

    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }

    var transitionName = util$2.transitionPropertyName;

    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');

      this.transitionQueue.push(function (done) {
        var elements = this.elements;
        var timeoutId;

        var clearTransition = function clearTransition() {
          elements.forEach(function (element) {
            element.style[transitionName] = '';
          });
        };

        // add "transitionend" event handler
        var removeListeners = util$2.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });

        // for fail safe.
        timeoutId = setTimeout(function () {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1000 * TIMEOUT_RATIO);

        // transition and style settings
        elements.forEach(function (element, index) {

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === undefined) {
              css[name] = '';
            }
          }

          element.style[transitionName] = transitionValue;

          Object.keys(css).forEach(function (key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });

          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function (done) {
        reset();
        done();
      });
    }

    return this;

    function reset() {
      // Clear transition animation settings.
      self.elements.forEach(function (element, index) {
        element.style[transitionName] = 'none';

        var css = self.lastStyleAttributeDict[index];

        if (!css) {
          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
        }

        self.lastStyleAttributeDict[index] = undefined;

        for (var i = 0, name = ''; i < element.style.length; i++) {
          name = element.style[i];
          if (typeof css[element.style[i]] === 'undefined') {
            css[element.style[i]] = '';
          }
        }

        Object.keys(css).forEach(function (key) {
          element.style[key] = css[key];
        });
      });
    }
  },

  /**
   * Start animation sequence.
   */
  startAnimation: function startAnimation() {
    this._dequeueTransition();

    return this;
  },

  _dequeueTransition: function _dequeueTransition() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error('Current transition exists.');
    }
    this._currentTransition = transition;
    var self = this;
    var called = false;

    var done = function done() {
      if (!called) {
        called = true;
        self._currentTransition = undefined;
        self._dequeueTransition();
      } else {
        throw new Error('Invalid state: This callback is called twice.');
      }
    };

    if (transition) {
      transition.call(this, done);
    }
  }

};

/**
 * @param {Animit} arguments
 */
Animit.runAll = function () /* arguments... */{
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};

/**
 * @param {Object} options
 * @param {Float} [options.duration]
 * @param {String} [options.property]
 * @param {String} [options.timing]
 */
Animit.Transition = function (options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || 'linear';
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || 'all';
};

Animit.Transition.prototype = {

  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function build() {

    if (Object.keys(this.options.css).length === 0) {
      throw new Error('options.css is required.');
    }

    var css = createActualCssProps(this.options.css);

    if (this.options.duration > 0) {
      var transitionValue = util$2.buildTransitionValue(this.options);
      var self = this;

      return function (callback) {
        var elements = this.elements;
        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
        var timeoutId;

        var removeListeners = util$2.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          callback();
        });

        timeoutId = setTimeout(function () {
          removeListeners();
          callback();
        }, timeout);

        elements.forEach(function (element) {
          element.style[util$2.transitionPropertyName] = transitionValue;

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });
      };
    }

    if (this.options.duration <= 0) {
      return function (callback) {
        var elements = this.elements;

        elements.forEach(function (element) {
          element.style[util$2.transitionPropertyName] = '';

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });

        if (elements.length > 0) {
          util$2.forceLayoutAtOnce(elements, function () {
            util$2.batchAnimationFrame(callback);
          });
        } else {
          util$2.batchAnimationFrame(callback);
        }
      };
    }

    function createActualCssProps(css) {
      var result = {};

      Object.keys(css).forEach(function (name) {
        var value = css[name];

        if (util$2.hasCssProperty(name)) {
          result[name] = value;
          return;
        }

        var prefixed = util$2.vendorPrefix + util$2.capitalize(name);
        if (util$2.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });

      return result;
    }
  }
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja][/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetector[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]DOM[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja][/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler) {
    element.addEventListener(type, handler, false);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler) {
    element.removeEventListener(type, handler, false);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find) {
    if (src.indexOf) {
      var index = src.indexOf(find);
      return index === -1 ? false : index;
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return false;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === false) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup();

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  });

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate [/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja][/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja][/ja]
   */
  on: function onEvent(gestures, handler) {
    var self = this;
    Event$1.on(self.element, gestures, handler, function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja][/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja][/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja][/ja]
   */
  off: function offEvent(gestures, handler) {
    var self = this;

    Event$1.off(self.element, gestures, handler, function (type) {
      var index = Utils.inArray({ gesture: type, handler: handler });
      if (index !== false) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]/[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja][/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja][/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var readyMap = new WeakMap();
var queueMap = new WeakMap();

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/dialog
 * @description
 *   [en]
 *     Utility methods to create different kinds of alert dialogs. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja][/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function (options) {
  // Prompt input string
  var inputString = '';
  if (options.isPrompt) {
    inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
  }

  // Buttons string
  var buttons = '';
  options.buttonLabels.forEach(function (label, index) {
    buttons += '\n      <button class="\n        alert-dialog-button\n        ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n        ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n      ">\n        ' + label + '\n      </button>\n    ';
  });

  // Dialog Element
  var el = {};
  var _destroyDialog = function _destroyDialog() {
    if (el.dialog.onDialogCancel) {
      el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
    }

    Object.keys(el).forEach(function (key) {
      return delete el[key];
    });
    el = null;

    if (options.destroy instanceof Function) {
      options.destroy();
    }
  };

  el.dialog = document.createElement('ons-alert-dialog');
  el.dialog.innerHTML = '\n    <div class="alert-dialog-mask"></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ';
  contentReady(el.dialog);

  // Set attributes
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && el.dialog.setAttribute(a, options[a]);
  });
  if (options.modifier) {
    util.addModifier(el.dialog, options.modifier);
  }

  var deferred = util.defer();

  // Prompt events
  if (options.isPrompt && options.submitOnEnter) {
    el.input = el.dialog.querySelector('.text-input');
    el.input.onkeypress = function (event) {
      if (event.keyCode === 13) {
        el.dialog.hide().then(function () {
          if (el) {
            var resolveValue = el.input.value;
            _destroyDialog();
            options.callback(resolveValue);
            deferred.resolve(resolveValue);
          }
        });
      }
    };
  }

  // Button events
  el.footer = el.dialog.querySelector('.alert-dialog-footer');
  util.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
    buttonElement.onclick = function () {
      el.dialog.hide().then(function () {
        if (el) {
          var resolveValue = options.isPrompt ? el.input.value : index;
          el.dialog.remove();
          _destroyDialog();
          options.callback(resolveValue);
          deferred.resolve(resolveValue);
        }
      });
    };

    el.footer.appendChild(buttonElement);
  });

  // Cancel events
  if (options.cancelable) {
    el.dialog.cancelable = true;
    el.dialog.onDialogCancel = function () {
      setImmediate(function () {
        el.dialog.remove();
        _destroyDialog();
      });
      var resolveValue = options.isPrompt ? null : -1;
      options.callback(resolveValue);
      deferred.reject(resolveValue);
    };
    el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
  }

  // Show dialog
  document.body.appendChild(el.dialog);
  options.compile(el.dialog);
  setImmediate(function () {
    el.dialog.show().then(function () {
      if (el.input && options.isPrompt && options.autofocus) {
        el.input.focus();
      }
    });
  });

  return deferred.promise;
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  typeof message === 'string' ? options.message = message : options = message;
  if (!options.message && !options.messageHTML) {
    throw new Error('Alert dialog must contain a message.');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    buttonLabels: ['OK'],
    primaryButtonIndex: 0,
    animation: 'default',
    cancelable: false
  }, defaults, options);
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja][/ja]
 * @param {String} [options.message]
 *   [en]Alert message.[/en]
 *   [ja][/ja]
 * @param {String} [options.messageHTML]
 *   [en]Alert message in HTML.[/en]
 *   [ja]HTML[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]"OK"[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja] 0 [/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja][/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]"none", "fade"[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialogID[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialogclass[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]"Alert"[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]modifier[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     
 *     HTML
 *     options.messageoptions.messageHTML
 *   [/ja]
 */
notification.alert = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]["Cancel", "OK"][/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `1`.[/en]
 *   [ja] 1 [/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     
 *     "Cancel""OK"
 *     options.messageoptions.messageHTML
 *   [/ja]
 */
notification.confirm = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    primaryButtonIndex: 1,
    title: 'Confirm'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja][/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]"OK"[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja] 0 [/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja][/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja][/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`.[/en]
 *   [ja]inputtrue[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterformsubmittrue[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     
 *     options.messageoptions.messageHTML
 *   [/ja]
 */
notification.prompt = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });

  return notification._createAlertDialog(options);
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja][/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]portraittrue[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja][/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja][/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja][/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja][/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja][/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja][/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja][/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja][/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja][/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]portraittrue[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]portrait[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]landscapetrue[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]landscape[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  util.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$3 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$3._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$3._ready = true;
      }, false);
    } else {
      util$3._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
window.addEventListener('DOMContentLoaded', function () {
  return util$3._onDOMContentLoaded();
}, false);

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$3.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$3.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        var tree = {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none') {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };

        if (!HandlerRepository.has(tree.element)) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = tree.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var subTree = _step.value;

              if (HandlerRepository.has(subTree.element)) {
                return subTree;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        return tree;
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent,
      _ref$params = _ref.params,
      params = _ref$params === undefined ? {} : _ref$params;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util.createElement(html.trim());
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent,
      _ref3$params = _ref3.params,
      params = _ref3$params === undefined ? {} : _ref3$params;

  var element = util.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function BaseAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, BaseAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration || 0;
    this.delay = options.delay || 0;
  }

  createClass(BaseAnimator, null, [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;
      return newAnimator;
    }
  }]);
  return BaseAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UI[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {};

ons$1._util = util;
ons$1.animit = Animit;
ons$1._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
ons$1._internal = internal$1;
ons$1.GestureDetector = GestureDetector;
ons$1.platform = platform;
ons$1.softwareKeyboard = softwareKeyboard;
ons$1.pageAttributeExpression = pageAttributeExpression;
ons$1.orientation = orientation;
ons$1.notification = notification;
ons$1._animationOptionsParser = parse;
ons$1._autoStyle = autoStyle;
ons$1._DoorLock = DoorLock;
ons$1._contentReady = contentReady;
ons$1.defaultPageLoader = defaultPageLoader;
ons$1.PageLoader = PageLoader;
ons$1._BaseAnimator = BaseAnimator;

ons$1._readyLock = new DoorLock();

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UI[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovatrue[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordova[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]Onsen UI[/ja]
 *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UI[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja][/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler.[/en]
 * [ja][/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler.[/en]
 * [ja][/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.enable();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = false;
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja][/ja]
 */
ons$1.disableAnimations = function () {
  ons$1._internal.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAnimations = function () {
  ons$1._internal.config.animationsDisabled = false;
};

ons$1._disableWarnings = function () {
  ons$1._internal.config.warningsDisabled = true;
};

ons$1._enableWarnings = function () {
  ons$1._internal.config.warningsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = ons$1._autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = ons$1._autoStyle.enable;

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      ons$1._autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createPopoverOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var popover = div.querySelector('ons-popover');
    document.body.appendChild(popover);

    if (options.link instanceof Function) {
      options.link(popover);
    }

    return popover;
  });
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageURLons-templateid[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja][/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]AngularJS[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]Promise[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja][/ja]
 */
ons$1.createPopover = ons$1._createPopoverOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var dialog = div.querySelector('ons-dialog');
    document.body.appendChild(dialog);

    if (options.link instanceof Function) {
      options.link(dialog);
    }

    return dialog;
  });
};

/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageURLons-templateid[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]Promise[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja][/ja]
 */
ons$1.createDialog = ons$1._createDialogOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createAlertDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var alertDialog = div.querySelector('ons-alert-dialog');
    document.body.appendChild(alertDialog);

    if (options.link instanceof Function) {
      options.link(alertDialog);
    }

    return alertDialog;
  });
};

/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageURLons-templateid[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]Promise[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja][/ja]
 */
ons$1.createAlertDialog = ons$1._createAlertDialogOriginal;

/**
 * @param {String} page
 * @param {Function} link
 */
ons$1._resolveLoadingPlaceholderOriginal = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

  if (elements.length > 0) {
    elements.filter(function (element) {
      return !element.getAttribute('page');
    }).forEach(function (element) {
      element.setAttribute('ons-loading-placeholder', page);
      ons$1._resolveLoadingPlaceholder(element, page, link);
    });
  } else {
    throw new Error('No ons-loading-placeholder exists.');
  }
};

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
 *   [ja]pageURLons-templateid[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderons.resolveLoadingPlaceholder[/ja]
 */
ons$1.resolveLoadingPlaceholder = ons$1._resolveLoadingPlaceholderOriginal;

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (element, page, link) {
  link = link || function (element, done) {
    done();
  };
  ons$1._internal.getPageHTMLAsync(page).then(function (html) {

    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }

    var contentElement = ons$1._util.createElement('<div>' + html + '</div>');
    contentElement.style.display = 'none';

    element.appendChild(contentElement);

    link(contentElement, function () {
      contentElement.style.display = '';
    });
  }).catch(function (error) {
    throw new Error('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  window.addEventListener('DOMContentLoaded', function () {
    if (ons$1.isWebView()) {
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  }, false);
}

window._superSecretOns = ons$1;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement() {
    classCallCheck(this, BaseElement);

    var _this = possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));

    _this.init();
    return _this;
  }

  createClass(BaseElement, [{
    key: 'init',
    value: function init() {}
  }]);
  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template.
 *
 *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
 *   [/en]
 *   [ja]HTMLHTMLidpageURLons-navigator[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]1HTML[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html">
 * </ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  function TemplateElement() {
    classCallCheck(this, TemplateElement);
    return possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).apply(this, arguments));
  }

  createClass(TemplateElement, [{
    key: 'init',


    /**
     * @property template
     * @type {String}
     * @description
     *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      this.template = this.innerHTML;

      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (this.parentNode) {
        // Note: this.parentNode is not set in some CE0/CE1 polyfills.
        // Show warning when the ons-template is not located just under document.body
        if (this.parentNode !== document.body) {
          // if the parent is not document.body
          util.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\n\n' + this.parentNode.outerHTML : '.'));
        }
      }

      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  function IfElement() {
    classCallCheck(this, IfElement);
    return possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).apply(this, arguments));
  }

  createClass(IfElement, [{
    key: 'init',


    /**
     * @attribute platform
     * @initonly
     * @type {string}
     * @description
     *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute orientation
     * @type {string}
     * @description
     *  [en]Either `"portrait"` or `"landscape"`.[/en]
     *  [ja]portraitlandscape[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        if (platform._renderPlatform !== null) {
          _this2._platformUpdate();
        } else if (!_this2._isAllowedPlatform()) {
          while (_this2.childNodes[0]) {
            _this2.childNodes[0].remove();
          }
          _this2._platformUpdate();
        }
      });

      this._onOrientationChange();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function (_BaseAnimator) {
  inherits(AlertDialogAnimator, _BaseAnimator);

  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);
    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
 *   [/en]
 *   [ja][/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @modifier rowfooter
 *   [en]Horizontally aligns the footer buttons.[/en]
 *   [ja][/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialog[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialog[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]ons.notification[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseElement) {
  inherits(AlertDialogElement, _BaseElement);

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);
    return possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).apply(this, arguments));
  }

  createClass(AlertDialogElement, [{
    key: 'init',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the alert dialog is displayed.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from showing.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the alert dialog is displayed.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja][/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the alert dialog is hidden.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from hiding.[/en]
     *   [ja][/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the alert dialog is hidden.[/en]
     * [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]disabled[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]"none""default"[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
     *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = function () {
        return _this2._cancel();
      };

      this._updateAnimatorFactory();
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      if (this.getAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]"fade", "none"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var tryShow = function tryShow() {
          var unlock = _this3._doorLock.lock();
          var animator = _this3._animatorFactory.newAnimator(options);

          _this3.style.display = 'block';
          _this3._mask.style.opacity = '1';

          return new Promise(function (resolve) {
            contentReady(_this3, function () {
              animator.show(_this3, function () {
                _this3._visible = true;
                unlock();

                util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                callback();
                resolve(_this3);
              });
            });
          });
        };

        return new Promise(function (resolve) {
          _this3._doorLock.waitUnlock(function () {
            return resolve(tryShow());
          });
        });
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]"fade", "none"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var tryHide = function tryHide() {
          var unlock = _this4._doorLock.lock();
          var animator = _this4._animatorFactory.newAnimator(options);

          return new Promise(function (resolve) {
            contentReady(_this4, function () {
              animator.hide(_this4, function () {
                _this4.style.display = 'none';
                _this4._visible = false;
                unlock();

                util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                callback();
                resolve(_this4);
              });
            });
          });
        };

        return new Promise(function (resolve) {
          _this4._doorLock.waitUnlock(function () {
            return resolve(tryHide());
          });
        });
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this5 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this5._running = false;
          util.triggerElementEvent(_this5, 'dialog-cancel');
        }, function () {
          return _this5._running = false;
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }
  }, {
    key: '_mask',
    get: function get() {
      return util.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict;
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseElement);

customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName = 'back-button';

var scheme$1 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/navigator
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbar[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigator[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);
    return possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).apply(this, arguments));
  }

  createClass(BackButtonElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the back button.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._options = {};
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName);

      if (!util.findChild(this, '.back-button__label')) {
        var label = util.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util.findChild(this, '.back-button__icon')) {
        var icon = util.create('span.back-button__icon');

        this.insertBefore(icon, this.children[0]);
      }

      ModifierUtil.initModifier(this, scheme$1);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.refresh
     * @description
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPagetrue[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName)) {
            this.className = defaultClassName + ' ' + current;
          }
          break;

        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$1);
          break;
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$1 = 'bottom-bar';
var scheme$2 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbar[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);
    return possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).apply(this, arguments));
  }

  createClass(BottomToolbarElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this.classList.add(defaultClassName$1);
      ModifierUtil.initModifier(this, scheme$2);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (util.match(this.parentNode, 'ons-page')) {
        this.parentNode.classList.add('page-with-bottom-toolbar');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$1)) {
            this.className = defaultClassName$1 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$2);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$3 = { '': 'button--*' };

var defaultClassName$2 = 'button';

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja][/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja][/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja][/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja][/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja][/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]quiet[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]cta[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja][/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ons-toolbar-buttonons-back-button[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseElement) {
  inherits(ButtonElement, _BaseElement);

  function ButtonElement() {
    classCallCheck(this, ButtonElement);
    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
  }

  createClass(ButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$2)) {
            this.className = defaultClassName$2 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$2);

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$3);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return ButtonElement;
}(BaseElement);

customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$4 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);
    return possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).apply(this, arguments));
  }

  createClass(CarouselItemElement, [{
    key: 'init',
    value: function init() {
      this.style.width = '100%';
      ModifierUtil.initModifier(this, scheme$4);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

customElements.define('ons-carousel-item', CarouselItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var VerticalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaY;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityY;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().height;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(0px, ' + -scroll + 'px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
      this._offset = -(height - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.height = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

var HorizontalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaX;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityX;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().width;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(' + -scroll + 'px, 0px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
      this._offset = -(width - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.width = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-item[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  function CarouselElement() {
    classCallCheck(this, CarouselElement);
    return possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).apply(this, arguments));
  }

  createClass(CarouselElement, [{
    key: 'init',


    /**
     * @event postchange
     * @description
     *   [en]Fired just after the current carousel item has changed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]Carousel[/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja][/ja]
     * @param {Number} event.lastActiveIndex
     *   [en]Previous active index.[/en]
     *   [ja][/ja]
     */

    /**
     * @event refresh
     * @description
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]Carousel[/ja]
     */

    /**
     * @event overscroll
     * @description
     *   [en]Fired when the carousel has been overscrolled.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.carousel
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja][/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja][/ja]
     * @param {String} event.direction
     *   [en]Can be one of either "up", "down", "left" or "right".[/en]
     *   [ja]"up", "down", "left", "right"[/ja]
     * @param {Function} event.waitToReturn
     *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
     *   [ja]PromisePromiseresolvereject[/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
     *   [ja]"horizontal""vertical""horizontal"[/ja]
     */

    /**
     * @attribute fullscreen
     * @description
     *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
     *   [ja]absolute[/ja]
     */

    /**
     * @attribute overscrollable
     * @description
     *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute centered
     * @description
     *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
     *   [ja]ons-carousel-item[/ja]
     */

    /**
     * @attribute item-width
     * @type {String}
     * @description
     *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
     *    [ja]ons-carousel-itemdirection"horizontal"[/ja]
     */

    /**
     * @attribute item-height
     * @type {String}
     * @description
     *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
     *   [ja]ons-carousel-itemdirection"vertical"[/ja]
     */

    /**
     * @attribute auto-scroll
     * @description
     *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
     *   [ja]carousel-item[/ja]
     */

    /**
     * @attribute auto-scroll-ratio
     * @type {Number}
     * @description
     *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
     *    [ja]0.01.0[/ja]
     */

    /**
     * @attribute swipeable
     * @description
     *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the carousel is disabled.[/en]
     *   [ja]dragtouchswipe[/ja]
     */

    /**
     * @attribute initial-index
     * @initonly
     * @type {Number}
     * @description
     *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
     *   [ja]ons-carousel-item0 0 [/ja]
     */

    /**
     * @attribute auto-refresh
     * @description
     *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @description
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *   [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    value: function init() {
      this._doorLock = new DoorLock();
      this._scroll = 0;
      this._offset = 0;
      this._lastActiveIndex = 0;

      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnResize = this._onResize.bind(this);

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
    }
  }, {
    key: '_onResize',
    value: function _onResize() {
      var i = this._scroll / this._currentElementSize;
      delete this._currentElementSize;
      this.setActiveIndex(i);
    }
  }, {
    key: '_onDirectionChange',
    value: function _onDirectionChange() {
      if (this._isVertical()) {
        this.style.overflowX = 'auto';
        this.style.overflowY = '';
      } else {
        this.style.overflowX = '';
        this.style.overflowY = 'auto';
      }

      this.refresh();
    }
  }, {
    key: '_saveLastState',
    value: function _saveLastState() {
      this._lastState = {
        elementSize: this._getCarouselItemSize(),
        carouselElementCount: this.itemCount,
        width: this._getCarouselItemSize() * this.itemCount
      };
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getCarouselItemSize',
    value: function _getCarouselItemSize() {
      var sizeAttr = this._getCarouselItemSizeAttr();
      var sizeInfo = this._decomposeSizeString(sizeAttr);
      var elementSize = this._getElementSize();

      if (sizeInfo.unit === '%') {
        return Math.round(sizeInfo.number / 100 * elementSize);
      } else if (sizeInfo.unit === 'px') {
        return sizeInfo.number;
      } else {
        throw new Error('Invalid state');
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getInitialIndex',
    value: function _getInitialIndex() {
      var index = parseInt(this.getAttribute('initial-index'), 10);

      if (typeof index === 'number' && !isNaN(index)) {
        return Math.max(Math.min(index, this.itemCount - 1), 0);
      } else {
        return 0;
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: '_getCarouselItemSizeAttr',
    value: function _getCarouselItemSizeAttr() {
      var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
      var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_decomposeSizeString',
    value: function _decomposeSizeString(size) {
      var matches = size.match(/^(\d+)(px|%)/);

      return {
        number: parseInt(matches[1], 10),
        unit: matches[2]
      };
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
      this._lastActiveIndex = this._getInitialIndex();
      this._scrollTo(this._scroll);
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]ons-carousel-itemindex[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animation = options.animation || this.getAttribute('animation');
      options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
      var max = this._calculateMaxScroll();

      this._scroll = Math.max(0, Math.min(max, scroll));
      return this._scrollTo(this._scroll, options).then(function () {
        _this2._tryFirePostChangeEvent();
        return _this2;
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]ons-carousel-item[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = this._scroll - (this._offset || 0);
      var count = this.itemCount;
      var size = this._getCarouselItemSize();

      if (scroll < 0) {
        return 0;
      }

      var i = void 0;
      for (i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      // max carousel index
      return i;
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]ons-carousel-item[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]ons-carousel-item[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isEnabledChangeEvent',
    value: function _isEnabledChangeEvent() {
      var elementSize = this._getElementSize();
      var carouselItemSize = this._getCarouselItemSize();

      return this.autoScroll && Math.abs(elementSize - carouselItemSize) < 0.5;
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isVertical',
    value: function _isVertical() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: '_prepareEventListeners',
    value: function _prepareEventListeners() {
      var _this3 = this;

      this._gestureDetector = new GestureDetector(this, {
        dragMinDistance: 1,
        dragLockToAxis: true
      });
      this._mutationObserver = new MutationObserver(function () {
        return _this3.refresh();
      });

      this._updateSwipeable();
      this._updateAutoRefresh();

      window.addEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._gestureDetector.dispose();
      this._gestureDetector = null;

      this._mutationObserver.disconnect();
      this._mutationObserver = null;

      window.removeEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      if (this._gestureDetector) {
        if (this.swipeable) {
          this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.on('dragend', this._boundOnDragEnd);
        } else {
          this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.off('dragend', this._boundOnDragEnd);
        }
      }
    }
  }, {
    key: '_updateAutoRefresh',
    value: function _updateAutoRefresh() {
      if (this._mutationObserver) {
        if (this.hasAttribute('auto-refresh')) {
          this._mutationObserver.observe(this, { childList: true });
        } else {
          this._mutationObserver.disconnect();
        }
      }
    }
  }, {
    key: '_tryFirePostChangeEvent',
    value: function _tryFirePostChangeEvent() {
      var currentIndex = this.getActiveIndex();

      if (this._lastActiveIndex !== currentIndex) {
        var lastActiveIndex = this._lastActiveIndex;
        this._lastActiveIndex = currentIndex;

        util.triggerElementEvent(this, 'postchange', {
          carousel: this,
          activeIndex: currentIndex,
          lastActiveIndex: lastActiveIndex
        });
      }
    }
  }, {
    key: '_isWrongDirection',
    value: function _isWrongDirection(d) {
      // this._lastDragDirection = d;
      return this._isVertical() ? d === 'left' || d === 'right' : d === 'up' || d === 'down';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      if (this._isWrongDirection(event.gesture.direction) || event.target && event.target.tagName.toLowerCase() === 'input' && event.target.type === 'range') {
        return;
      }

      event.stopPropagation();

      this._lastDragEvent = event;

      var scroll = this._scroll - this._getScrollDelta(event);
      this._scrollTo(scroll);
      event.gesture.preventDefault();

      this._tryFirePostChangeEvent();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var _this4 = this;

      if (!this._lastDragEvent) {
        return;
      }
      this._currentElementSize = undefined;
      this._scroll = this._scroll - this._getScrollDelta(event);

      // if (!this._isWrongDirection(this._lastDragDirection) && this._getScrollDelta(event) !== 0) {
      //   event.stopPropagation();
      // }

      if (this._isOverScroll(this._scroll)) {
        var waitForAction = false;
        util.triggerElementEvent(this, 'overscroll', {
          carousel: this,
          activeIndex: this.getActiveIndex(),
          direction: this._getOverScrollDirection(),
          waitToReturn: function waitToReturn(promise) {
            waitForAction = true;
            promise.then(function () {
              return _this4._scrollToKillOverScroll();
            });
          }
        });

        if (!waitForAction) {
          this._scrollToKillOverScroll();
        }
      } else {
        this._startMomentumScroll();
      }
      this._lastDragEvent = null;

      event.gesture.preventDefault();
    }

    /**
     * @param {Object} trait
     */

  }, {
    key: '_mixin',
    value: function _mixin(trait) {
      Object.keys(trait).forEach(function (key) {
        this[key] = trait[key];
      }.bind(this));
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll() {
      if (this._lastDragEvent) {
        var velocity = this._getScrollVelocity(this._lastDragEvent);
        var duration = 0.3;
        var scrollDelta = duration * 100 * velocity;
        var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

        this._scroll = scroll;

        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(this._scroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
      }
    }
  }, {
    key: '_normalizeScrollPosition',
    value: function _normalizeScrollPosition(scroll) {
      var max = this._calculateMaxScroll();

      if (!this.autoScroll) {
        return Math.max(0, Math.min(max, scroll));
      }
      var arr = [];
      var size = this._getCarouselItemSize();
      var nbrOfItems = this.itemCount;

      for (var i = 0; i < nbrOfItems; i++) {
        if (i * size + this._offset < max) {
          arr.push(i * size + this._offset);
        }
      }
      arr.push(max);

      arr.sort(function (left, right) {
        left = Math.abs(left - scroll);
        right = Math.abs(right - scroll);

        return left - right;
      });

      arr = arr.filter(function (item, pos) {
        return !pos || item != arr[pos - 1];
      });

      var lastScroll = this._lastActiveIndex * size + this._offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;
      var result = arr[0];

      if (scrollRatio <= this.autoScrollRatio) {
        result = lastScroll;
      } else if (scrollRatio < 1.0) {
        if (arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }

      return Math.max(0, Math.min(max, result));
    }

    /**
     * @return {Array}
     */

  }, {
    key: '_getCarouselItemElements',
    value: function _getCarouselItemElements() {
      return util.arrayFrom(this.children).filter(function (child) {
        return child.nodeName.toLowerCase() === 'ons-carousel-item';
      });
    }

    /**
     * @param {Number} scroll
     * @param {Object} [options]
     * @return {Promise} Resolves to the carousel element
     */

  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isOverscrollable = this.overscrollable;

      var normalizeScroll = function normalizeScroll(scroll) {
        var ratio = 0.35;

        if (scroll < 0) {
          return isOverscrollable ? Math.round(scroll * ratio) : 0;
        }

        var maxScroll = _this5._calculateMaxScroll();
        if (maxScroll < scroll) {
          return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
        }

        return scroll;
      };

      return new Promise(function (resolve) {
        Animit(_this5._getCarouselItemElements()).queue({
          transform: _this5._generateScrollTransform(normalizeScroll(scroll))
        }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
          if (options.callback instanceof Function) {
            options.callback();
          }
          resolve();
        });
      });
    }
  }, {
    key: '_calculateMaxScroll',
    value: function _calculateMaxScroll() {
      var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: '_isOverScroll',
    value: function _isOverScroll(scroll) {
      if (scroll < 0 || scroll > this._calculateMaxScroll()) {
        return true;
      }
      return false;
    }
  }, {
    key: '_getOverScrollDirection',
    value: function _getOverScrollDirection() {
      if (this._isVertical()) {
        return this._scroll <= 0 ? 'up' : 'down';
      } else {
        return this._scroll <= 0 ? 'left' : 'right';
      }
    }
  }, {
    key: '_scrollToKillOverScroll',
    value: function _scrollToKillOverScroll() {
      var duration = 0.4;

      if (this._scroll < 0) {
        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(0)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = 0;
        return;
      }

      var maxScroll = this._calculateMaxScroll();

      if (maxScroll < this._scroll) {
        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(maxScroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = maxScroll;
        return;
      }

      return;
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]ons-carousel-itemons-carousel[/ja]
     */
    value: function refresh() {
      // Bug fix
      if (this._getCarouselItemSize() === 0) {
        return;
      }

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
      this._setup();

      if (this._lastState && this._lastState.width > 0) {
        var scroll = this._scroll; // - this._offset;

        if (this._isOverScroll(scroll)) {
          this._scrollToKillOverScroll();
        } else {
          if (this.autoScroll) {
            scroll = this._normalizeScrollPosition(scroll);
          }

          this._scrollTo(scroll);
        }
      }

      this._saveLastState();

      util.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this is set to `"none"`, the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]ons-carousel-item[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]ons-carousel-item[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this._prepareEventListeners();

      this._setup();
      this._setupInitialIndex();

      this._saveLastState();

      // Fix rendering glitch on Android 4.1
      if (this.offsetHeight === 0) {
        setImmediate(function () {
          return _this6.refresh();
        });
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._updateSwipeable();
          break;
        case 'auto-refresh':
          this._updateAutoRefresh();
          break;
        case 'direction':
          this._onDirectionChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._removeEventListeners();
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]ratio[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get() {
      return this._getCarouselItemElements().length;
    }
  }, {
    key: 'autoScrollRatio',
    get: function get() {
      var attr = this.getAttribute('auto-scroll-ratio');

      if (!attr) {
        return 0.5;
      }

      var scrollRatio = parseFloat(attr);
      if (scrollRatio < 0.0 || scrollRatio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      return isNaN(scrollRatio) ? 0.5 : scrollRatio;
    },
    set: function set(ratio) {
      if (ratio < 0.0 || ratio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeabletrue[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get() {
      return this.hasAttribute('swipeable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]true[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'auto-scroll', value);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this.hasAttribute('disabled');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrolltrue[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get() {
      return this.hasAttribute('overscrollable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centeredtrue[/ja]
     */

  }, {
    key: 'centered',
    get: function get() {
      return this.hasAttribute('centered');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['swipeable', 'auto-refresh', 'direction'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['postchange', 'refresh', 'overscroll'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]ons-row[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3iOS 6OSons-rowons-column[/ja]
 * @codepen GgujC {wide}
 * @guide layouting [en]Layouting guide[/en][ja][/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-row[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]"top", "center", "bottom"[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]10%50px[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);
    return possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).apply(this, arguments));
  }

  createClass(ColElement, [{
    key: 'init',
    value: function init() {
      if (this.getAttribute('width')) {
        this._updateWidth();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (typeof width === 'string') {
        width = ('' + width).trim();
        width = width.match(/^\d+$/) ? width + '%' : width;

        this.style.webkitBoxFlex = '0';
        this.style.webkitFlex = '0 0 ' + width;
        this.style.mozBoxFlex = '0';
        this.style.mozFlex = '0 0 ' + width;
        this.style.msFlex = '0 0 ' + width;
        this.style.flex = '0 0 ' + width;
        this.style.maxWidth = width;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function (_BaseAnimator) {
  inherits(DialogAnimator, _BaseAnimator);

  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);
    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);

    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this4;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$5 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$1 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja][/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialog[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popover[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modal[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseElement) {
  inherits(DialogElement, _BaseElement);

  function DialogElement() {
    classCallCheck(this, DialogElement);
    return possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).apply(this, arguments));
  }

  createClass(DialogElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = function () {
        return _this2._cancel();
      };

      this._updateAnimatorFactory();
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        container.classList.add('dialog-container');
        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }
        dialog.appendChild(container);

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, scheme$5);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this3 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this3._running = false;
          util.triggerElementEvent(_this3, 'dialog-cancel');
        }, function () {
          return _this3._running = false;
        });
      }
    }

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]"none", "slide"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja][/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja][/ja]
     * @return {Promise} Resolves to the displayed element.
     */

  }, {
    key: 'show',
    value: function show() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        dialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var tryShow = function tryShow() {
          var unlock = _this4._doorLock.lock();
          var animator = _this4._animatorFactory.newAnimator(options);

          _this4.style.display = 'block';
          _this4._mask.style.opacity = '1';

          return new Promise(function (resolve) {
            contentReady(_this4, function () {
              animator.show(_this4, function () {
                _this4._visible = true;
                unlock();

                util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                callback();
                resolve(_this4);
              });
            });
          });
        };

        return new Promise(function (resolve) {
          _this4._doorLock.waitUnlock(function () {
            return resolve(tryShow());
          });
        });
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]"none", "slide"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        dialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var tryHide = function tryHide() {
          var unlock = _this5._doorLock.lock();
          var animator = _this5._animatorFactory.newAnimator(options);

          return new Promise(function (resolve) {
            contentReady(_this5, function () {
              animator.hide(_this5, function () {
                _this5.style.display = 'none';
                _this5._visible = false;
                unlock();

                util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                callback();
                resolve(_this5);
              });
            });
          });
        };

        return new Promise(function (resolve) {
          _this5._doorLock.waitUnlock(function () {
            return resolve(tryHide());
          });
        });
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }
  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     * [en]Fired just before the dialog is displayed.[/en]
     * [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being shown.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postshow
     * @description
     * [en]Fired just after the dialog is displayed.[/en]
     * [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @event prehide
     * @description
     * [en]Fired just before the dialog is hidden.[/en]
     * [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being hidden.[/en]
     *   [ja][/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the dialog is hidden.[/en]
     * [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]disabled[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]"none""default"[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
     */

    get: function get() {
      return util.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.dialog');
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$1;
    }
  }, {
    key: 'DialogAnimator',
    get: function get() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseElement);

customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$3 = 'fab';

var scheme$6 = {
  '': 'fab--*',
  '.fab__icon': 'fab--*__icon'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  function FabElement() {
    classCallCheck(this, FabElement);
    return possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).apply(this, arguments));
  }

  createClass(FabElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      // The following statements can be executed before contentReady
      // since these do not access the children
      this.hide();
      this.classList.add(defaultClassName$3);

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!util.findChild(this, '.fab__icon')) {
        var content = document.createElement('span');
        content.classList.add('fab__icon');

        util.arrayFrom(this.childNodes).forEach(function (element) {
          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
            content.appendChild(element);
          }
        });
        this.appendChild(content);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$6);

      this._updatePosition();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      setImmediate(function () {
        return _this3.show();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$3)) {
            this.className = defaultClassName$3 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$6);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this4 = this;

      setImmediate(function () {
        return _this4.hide();
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(1)';
      this.style.webkitTransform = 'scale(1)';
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(0)';
      this.style.webkitTransform = 'scale(0)';
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'toggle',


    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */
    value: function toggle() {
      this.visible ? this.hide() : this.show();
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this.style.transform === 'scale(1)' && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'position', 'class'];
    }
  }]);
  return FabElement;
}(BaseElement);

customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja][/ja]
 * @guide gesture-detector
 *   [en]Detecting finger gestures[/en]
 *   [ja][/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);
    return possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).apply(this, arguments));
  }

  createClass(GestureDetectorElement, [{
    key: 'init',
    value: function init() {
      this._gestureDetector = new GestureDetector(this);
    }
  }]);
  return GestureDetectorElement;
}(BaseElement);

customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  function IconElement() {
    classCallCheck(this, IconElement);
    return possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).apply(this, arguments));
  }

  createClass(IconElement, [{
    key: 'init',


    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
     *
     *     See all available icons on their respective sites:
     *
     *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
     *     * [Ionicons](http://ionicons.com)
     *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
     *
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit, material:md-edit">
     *     </ons-icon>
     *     ```
     *
     *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute size
     * @type {String}
     * @description
     *   [en]
     *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit"
     *       size="32px, material:24px">
     *     </ons-icon>
     *     ```
     *
     *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute rotate
     * @type {Number}
     * @description
     *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
     *   [ja]90, 180, 270[/ja]
     */

    /**
     * @attribute fixed-width
     * @type {Boolean}
     * @default false
     * @description
     *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute spin
     * @description
     *   [en]Specify whether the icon should be spinning.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
        this._update();
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);
      this._update();
      setImmediate(function () {
        return _this2._update();
      }); // Fix for bindings
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this3 = this;

      this._cleanClassAttribute();

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util.extend(this.style, style);

      classList.forEach(function (className) {
        return _this3.classList.add(className);
      });
    }
  }, {
    key: '_getAttribute',
    value: function _getAttribute(attr) {
      var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);
      return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute() {
      var _this4 = this;

      util.arrayFrom(this.classList).filter(function (className) {
        return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
        );
      }).forEach(function (className) {
        return _this4.classList.remove(className);
      });

      this.classList.remove('zmdi');
      this.classList.remove('ons-icon--ion');
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
      } else {
        classList.push('fa');
        classList.push('fa-' + iconName);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('fa-' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['icon', 'size', 'modifier'];
    }
  }]);
  return IconElement;
}(BaseElement);

customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     DOM
 *     
 *     
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`[/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     `HTMLElement`
     *     
     *     `<ons-lazy-repeat>`
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja][/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     ()
     *     
     *     
     *     
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     DOM
     *     DOM
     *     
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja][/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get() {
      throw new Error('This property can only be used to set the delegate object.');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$4 = 'list-header';
var scheme$7 = { '': 'list-header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]ons-list[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-list[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-item[/ja]
 * @guide lists [en]Using lists[/en][ja][/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);
    return possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).apply(this, arguments));
  }

  createClass(ListHeaderElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list header.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$4);
      ModifierUtil.initModifier(this, scheme$7);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$4)) {
            this.className = defaultClassName$4 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$5 = 'list-item';
var scheme$8 = {
  '.list-item': 'list-item--*',
  '.list-item__left': 'list-item--*__left',
  '.list-item__center': 'list-item--*__center',
  '.list-item__right': 'list-item--*__right',
  '.list-item__label': 'list-item--*__label',
  '.list-item__title': 'list-item--*__title',
  '.list-item__subtitle': 'list-item--*__subtitle',
  '.list-item__thumbnail': 'list-item--*__thumbnail',
  '.list-item__icon': 'list-item--*__icon'
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja][/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
 *
 *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *     </ons-list-item>
 *     ```
 *
 *     There is also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-list[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-header[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja][/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list-item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list-item__title">Title</div>
 *     <div class="list-item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  function ListItemElement() {
    classCallCheck(this, ListItemElement);
    return possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).apply(this, arguments));
  }

  createClass(ListItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list item.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute lock-on-drag
     * @type {String}
     * @description
     *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute tappable
     * @type {Boolean}
     * @description
     *   [en]Makes the element react to taps.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute tap-background-color
     * @type {Color}
     * @description
     *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$5);

      var left = void 0,
          center = void 0,
          right = void 0;

      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('left')) {
          el.classList.add('list-item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list-item__right');
          right = el;
        }
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right) {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        this.insertBefore(center, right || null);
      }

      center.classList.add('center');
      center.classList.add('list-item__center');

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$8);

      autoStyle.prepare(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$5)) {
            this.className = defaultClassName$5 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
          break;
        case 'ripple':
          this._updateRipple();
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('drag', this._onDrag);
      this.addEventListener('touchstart', this._onTouch);
      this.addEventListener('mousedown', this._onTouch);
      this.addEventListener('touchend', this._onRelease);
      this.addEventListener('touchmove', this._onRelease);
      this.addEventListener('touchcancel', this._onRelease);
      this.addEventListener('mouseup', this._onRelease);
      this.addEventListener('mouseout', this._onRelease);
      this.addEventListener('touchleave', this._onRelease);

      this._originalBackgroundColor = this.style.backgroundColor;

      this.tapped = false;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('drag', this._onDrag);
      this.removeEventListener('touchstart', this._onTouch);
      this.removeEventListener('mousedown', this._onTouch);
      this.removeEventListener('touchend', this._onRelease);
      this.removeEventListener('touchmove', this._onRelease);
      this.removeEventListener('touchcancel', this._onRelease);
      this.removeEventListener('mouseup', this._onRelease);
      this.removeEventListener('mouseout', this._onRelease);
      this.removeEventListener('touchleave', this._onRelease);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch() {
      if (this.tapped) {
        return;
      }

      this.tapped = true;

      this.style.transition = this._transition;
      this.style.webkitTransition = this._transition;
      this.style.MozTransition = this._transition;

      if (this._tappable) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        this.style.backgroundColor = this._tapBackgroundColor;
        this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;

      this.style.transition = '';
      this.style.webkitTransition = '';
      this.style.MozTransition = '';

      this.style.backgroundColor = this._originalBackgroundColor || '';
      this.style.boxShadow = '';
    }
  }, {
    key: '_shouldLockOnDrag',
    value: function _shouldLockOnDrag() {
      return this.hasAttribute('lock-on-drag');
    }
  }, {
    key: '_transition',
    get: function get() {
      return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
    }
  }, {
    key: '_tappable',
    get: function get() {
      return this.hasAttribute('tappable');
    }
  }, {
    key: '_tapBackgroundColor',
    get: function get() {
      return this.getAttribute('tap-background-color') || '#d9d9d9';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class', 'ripple'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$6 = 'list';
var scheme$9 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja][/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]ons-list-item[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-item[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-header[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeat[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja][/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  function ListElement() {
    classCallCheck(this, ListElement);
    return possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).apply(this, arguments));
  }

  createClass(ListElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$6);
      ModifierUtil.initModifier(this, scheme$9);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$6)) {
            this.className = defaultClassName$6 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$9);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ListElement;
}(BaseElement);

customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultCheckboxClass = 'checkbox';
var defaultRadioButtonClass = 'radio-button';

var scheme$10 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label',
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark',
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @codepen ojQxLj
 * @tutorial vanilla/Reference/input
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja][/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 * <ons-input type="checkbox" checked></ons-input>
 */

var InputElement = function (_BaseElement) {
  inherits(InputElement, _BaseElement);

  function InputElement() {
    classCallCheck(this, InputElement);
    return possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).apply(this, arguments));
  }

  createClass(InputElement, [{
    key: 'init',


    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
      });

      this._boundOnInput = this._onInput.bind(this);
      this._boundOnFocusin = this._onFocusin.bind(this);
      this._boundDelegateEvent = this._delegateEvent.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this.children.length !== 0) {
        return;
      }

      var helper = document.createElement('span');
      helper.classList.add('_helper');

      var container = document.createElement('label');
      container.appendChild(document.createElement('input'));
      container.appendChild(helper);

      var label = document.createElement('span');
      label.classList.add('input-label');

      util.arrayFrom(this.childNodes).forEach(function (element) {
        return label.appendChild(element);
      });
      this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

      this.appendChild(container);

      switch (this.getAttribute('type')) {
        case 'checkbox':
          this.classList.add(defaultCheckboxClass);
          this._input.classList.add('checkbox__input');
          this._helper.classList.add('checkbox__checkmark');
          this._updateBoundAttributes();
          break;

        case 'radio':
          this.classList.add(defaultRadioButtonClass);
          this._input.classList.add('radio-button__input');
          this._helper.classList.add('radio-button__checkmark');
          this._updateBoundAttributes();
          break;

        default:
          this._input.classList.add('text-input');
          this._helper.classList.add('text-input__label');
          this._input.parentElement.classList.add('text-input__container');

          this._updateLabel();
          this._updateBoundAttributes();
          this._updateLabelClass();
          break;
      }

      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }

      ModifierUtil.initModifier(this, scheme$10);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
          });
          break;
        case 'placeholder':
          contentReady(this, function () {
            return _this3._updateLabel();
          });
          break;
        case 'input-id':
          contentReady(this, function () {
            return _this3._input.id = current;
          });
          break;
        case 'checked':
          this.checked = current !== null;
          break;
        case 'class':
          switch (this.getAttribute('type')) {
            case 'checkbox':
              if (!this.classList.contains(defaultCheckboxClass)) {
                this.className = defaultCheckboxClass + ' ' + current;
              }
              break;
            case 'radio':
              if (!this.classList.contains(defaultRadioButtonClass)) {
                this.className = defaultRadioButtonClass + ' ' + current;
              }
              break;
          }
          break;
      }

      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this3._updateBoundAttributes();
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
          _this4._input.addEventListener('input', _this4._boundOnInput);
          _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
          _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
        }

        _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.removeEventListener('input', _this5._boundOnInput);
        _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
        _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
        _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
      });
    }
  }, {
    key: '_setLabel',
    value: function _setLabel(value) {
      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = value;
      } else {
        this._helper.innerText = value;
      }
    }
  }, {
    key: '_updateLabel',
    value: function _updateLabel() {
      this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this6 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this6.hasAttribute(attr)) {
          _this6._input.setAttribute(attr, _this6.getAttribute(attr));
        } else {
          _this6._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_onInput',
    value: function _onInput(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_onFocusin',
    value: function _onFocusin(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input');
    }
  }, {
    key: '_helper',
    get: function get() {
      return this.querySelector('._helper');
    }

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this7 = this;

      contentReady(this, function () {
        _this7._input.value = val;
        _this7._onInput();
      });
    }

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'checked',
    get: function get() {
      return this._input.checked;
    },
    set: function set(val) {
      var _this8 = this;

      contentReady(this, function () {
        _this8._input.checked = val;
      });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: '_isTextInput',
    get: function get() {
      return this.type !== 'radio' && this.type !== 'checkbox';
    }
  }, {
    key: 'type',
    get: function get() {
      return this.getAttribute('type');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['class', 'modifier', 'placeholder', 'input-id', 'checked'].concat(INPUT_ATTRIBUTES);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change', 'input', 'focus', 'focusin', 'focusout', 'blur'];
    }
  }]);
  return InputElement;
}(BaseElement);

customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function (_BaseAnimator) {
  inherits(ModalAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ModalAnimator);
    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeModalAnimator);
    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 1
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$11 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var defaultClassName$7 = 'modal';

var _animatorDict$2 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     
 *     
 *   [/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseElement) {
  inherits(ModalElement, _BaseElement);

  function ModalElement() {
    classCallCheck(this, ModalElement);
    return possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).apply(this, arguments));
  }

  createClass(ModalElement, [{
    key: 'init',


    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
     *  [ja]"none""fade"[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delaye.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._doorLock = new DoorLock();

      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add(defaultClassName$7);

      if (!util.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = function () {
        return undefined;
      };
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]"none", "fade"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryShow = function tryShow() {
        var unlock = _this3._doorLock.lock();
        var animator = _this3._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this3, function () {
            _this3.style.display = 'table';
            animator.show(_this3, function () {
              unlock();

              util.propagateAction(_this3, '_show');
              callback();
              resolve(_this3);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          return resolve(tryShow());
        });
      });
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]"none", "fade"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.visible) {
        return this.hide.apply(this, arguments);
      } else {
        return this.show.apply(this, arguments);
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]"none", "fade"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryHide = function tryHide() {
        var unlock = _this4._doorLock.lock();
        var animator = _this4._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this4, function () {
            animator.hide(_this4, function () {
              _this4.style.display = 'none';
              unlock();

              util.propagateAction(_this4, '_hide');
              callback();
              resolve(_this4);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this4._doorLock.waitUnlock(function () {
          return resolve(tryHide());
        });
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'class') {
        if (!this.classList.contains(defaultClassName$7)) {
          this.className = defaultClassName$7 + ' ' + current;
        }
      } else if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(handler) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this.style.display !== 'none';
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$2;
    }
  }, {
    key: 'ModalAnimator',
    get: function get() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseElement);

customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorTransitionAnimator = function (_BaseAnimator) {
  inherits(NavigatorTransitionAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorTransitionAnimator(options) {
    classCallCheck(this, NavigatorTransitionAnimator);

    options = util.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (NavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(NavigatorTransitionAnimator)).call(this, options));
  }

  createClass(NavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'block',
    value: function block(page) {
      var blocker = util.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
      page.parentNode.appendChild(blocker);
      return function () {
        return blocker.remove();
      };
    }
  }]);
  return NavigatorTransitionAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSSlideNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');

    return _this;
  }

  createClass(IOSSlideNavigatorTransitionAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

      var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('toolbar--material') && !leavePage._getToolbarElement().classList.contains('toolbar--material');

      return bothPageHasToolbar && noMaterialToolbar;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get$1(IOSSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      contentReady(enterPage, function () {
        var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;
        var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;
        var enterPageDecomposition = _this2._decompose(enterPageTarget);
        var leavePageDecomposition = _this2._decompose(leavePageTarget);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var maskClear = Animit(_this2.backgroundMask).saveStyle().queue({
          opacity: 0,
          transform: 'translate3d(0, 0, 0)'
        }).wait(_this2.delay).queue({
          opacity: 0.05
        }, {
          duration: _this2.duration,
          timing: _this2.timing
        }).restoreStyle().queue(function (done) {
          _this2.backgroundMask.remove();
          done();
        });

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

        if (shouldAnimateToolbar) {
          // TODO: Remove this fix
          var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
          _this2.backgroundMask.style.top = enterPageToolbarHeight;

          Animit.runAll(maskClear, Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.toolbar).saveStyle().queue({
            css: {
              opacity: 0
            },
            duration: 0
          }).queue({
            css: {
              opacity: 1
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.background).queue({
            css: {
              top: enterPageToolbarHeight
            },
            duration: 0
          }), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(125%, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
            css: { opacity: 0 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 1 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            unblock();
            callback();
            done();
          }), Animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.label + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePageDecomposition.other).saveStyle().queue({
            css: { opacity: 1 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 0 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle());
        } else {

          Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePage).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            unblock();
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get$1(IOSSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;
      var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;
      var enterPageDecomposition = this._decompose(enterPageTarget);
      var leavePageDecomposition = this._decompose(leavePageTarget);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var maskClear = Animit(this.backgroundMask).saveStyle().queue({
        opacity: 0.1,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        done();
      });

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

      if (shouldAnimateToolbar) {
        var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
        this.backgroundMask.style.top = enterPageToolbarHeight;

        Animit.runAll(maskClear, Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.label + 'px, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
          css: { opacity: 0 },
          duration: 0
        }).wait(this.delay).queue({
          css: { opacity: 1 },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(leavePageDecomposition.background).queue({
          css: {
            top: enterPageToolbarHeight
          },
          duration: 0
        }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).wait(0).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }), Animit(leavePageDecomposition.toolbar).queue({
          css: {
            opacity: 1
          },
          duration: 0
        }).queue({
          css: {
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.toolbarCenter).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(125%, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.backButtonLabel).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }));
      } else {
        Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(leavePage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }));
      }
    }
  }]);
  return IOSSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSLiftNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get$1(IOSLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get$1(IOSLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSFadeNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSFadeNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (IOSFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get$1(IOSFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(enterPage._getToolbarElement()).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get$1(IOSFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage._getToolbarElement()).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDSlideNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, MDSlideNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
    _this.blackMaskOpacity = 0.4;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get$1(MDSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: 0,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: this.blackMaskOpacity
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(100%, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get$1(MDSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: this.blackMaskOpacity,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(100%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDLiftNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, MDLiftNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get$1(MDLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).queue({
        css: {
          opacity: 0.4
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get$1(MDLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0.4
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDFadeNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease-out' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.25 : _ref$duration;

    classCallCheck(this, MDFadeNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (MDFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get$1(MDFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 42px, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get$1(MDFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(0.15).queue({
        css: {
          transform: 'translate3D(0, 38px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          opacity: 1
        },
        duration: 0
      }).wait(0.04).queue({
        css: {
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

  function NoneNavigatorTransitionAnimator(options) {
    classCallCheck(this, NoneNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorTransitionAnimator)).call(this, options));
  }

  createClass(NoneNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$3 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
  },
  'slide-ios': IOSSlideNavigatorTransitionAnimator,
  'slide-md': MDSlideNavigatorTransitionAnimator,
  'lift-ios': IOSLiftNavigatorTransitionAnimator,
  'lift-md': MDLiftNavigatorTransitionAnimator,
  'fade-ios': IOSFadeNavigatorTransitionAnimator,
  'fade-md': MDFadeNavigatorTransitionAnimator,
  'none': NoneNavigatorTransitionAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide multiple-page-navigation
 *   [en]Guide for page navigation[/en]
 *   [ja][/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]1HTML[/ja]
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <ons-template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </ons-template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);
    return possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).apply(this, arguments));
  }

  createClass(NavigatorElement, [{
    key: 'init',
    value: function init() {
      this._isRunning = false;
      this._initialized = false;
      this._pageLoader = defaultPageLoader;
      this._pageMap = new WeakMap();

      this._updateAnimatorFactory();
    }

    /**
     * @property pageLoader
     * @type {PageLoader}
     * @description
     *   [en][/en]
     *   [ja]PageLoader[/ja]
     */

  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en][/en]
     *   [ja]`page``page`[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      rewritables.ready(this, function () {
        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
            }
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: NavigatorTransitionAnimator,
        baseClassName: 'NavigatorTransitionAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Boolean} [options.refresh]
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPagetrue[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja][/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      if (!options.refresh) {
        return this._popPage(options, popUpdate);
      } else {
        return this._popPageAndRefresh(options, popUpdate);
      }
    }
  }, {
    key: '_popPageAndRefresh',
    value: function _popPageAndRefresh(options, popUpdate) {
      var _this4 = this;

      util.warn('\'refresh\' option for pushPage has been deprecated and will be removed in the next release.');

      var index = this.pages.length - 2;
      var oldPage = this.pages[index];

      if (!this._pageMap.has(oldPage)) {
        throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
      }

      var page = this._pageMap.get(oldPage);

      return new Promise(function (resolve) {
        var options = {
          page: page,
          parent: _this4,
          params: oldPage.pushedOptions ? oldPage.pushedOptions.data : {}
        };

        _this4._pageLoader.load(options, function (pageElement) {
          _this4._pageMap.set(pageElement, page);

          pageElement = util.extend(pageElement, {
            data: oldPage.data,
            pushedOptions: oldPage.pushedOptions || {}
          });

          _this4.insertBefore(pageElement, oldPage ? oldPage : null);
          _this4._pageLoader.unload(oldPage);
          resolve();
        });
      }).then(function () {
        return _this4._popPage(options, popUpdate);
      });
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this5 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this5.pages[length - 1];
        var enterPage = _this5.pages[length - 2];

        options.animation = options.animation || (leavePage.pushedOptions ? leavePage.pushedOptions.animation : undefined);
        options.animationOptions = util.extend({}, leavePage.pushedOptions ? leavePage.pushedOptions.animationOptions : {}, options.animationOptions || {});

        if (options.data) {
          enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        }

        var callback = function callback() {
          update().then(function () {
            _this5._isRunning = false;

            enterPage._show();
            util.triggerElementEvent(_this5, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this5 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          });
        };

        leavePage._hide();
        var animator = _this5._animatorFactory.newAnimator(options);
        animator.pop(_this5.pages[length - 2], _this5.pages[length - 1], callback);
      }).catch(function () {
        return _this5._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
     *   [ja]pageURLons-templateid[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]page[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        _this6._verifyPageElement(pageElement);
        _this6._pageMap.set(pageElement, page);
        pageElement = util.extend(pageElement, {
          data: options.data
        });
        pageElement.style.visibility = 'hidden';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this6, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this6._pageLoader.load({ page: page, parent: _this6, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this7.pages.length;

        var enterPage = _this7.pages[pageLength - 1];
        var leavePage = options.leavePage || _this7.pages[pageLength - 2];

        if (enterPage.nodeName !== 'ONS-PAGE') {
          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
        }

        enterPage.updateBackButton(pageLength - 1);

        enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this7._isRunning = false;

            setImmediate(function () {
              return enterPage._show();
            });
            util.triggerElementEvent(_this7, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this7 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          };

          enterPage.style.visibility = '';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this7._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this8.pages.length > 1) {
          _this8._pageLoader.unload(_this8.pages[_this8.pages.length - 2]);
        }
        _this8._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]pageindex[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this9 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this9 }, function (pageElement) {
          _this9._verifyPageElement(pageElement);
          _this9._pageMap.set(pageElement, page);
          pageElement = util.extend(pageElement, {
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this9.getAttribute('animation-options')), options.animationOptions || {});

          _this9.insertBefore(pageElement, _this9.pages[index]);
          _this9.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this9.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation) {
        options.animation = 'none';
      }

      var callback = options.callback;

      options.callback = function () {
        while (_this10.pages.length > 1) {
          _this10._pageLoader.unload(_this10.pages[0]);
        }

        _this10.pages[0].updateBackButton(false);
        callback && callback();
      };

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]URLons-navigator[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]Promise[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]push[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        throw new Error('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      page.style.visibility = 'hidden';
      page.setAttribute('_skipinit', '');
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (!this._pageMap.has(this.pages[index])) {
          throw Error('This is bug.');
        }

        if (pageName === this._pageMap.get(this.pages[index])) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util.triggerElementEvent(this, 'pre' + name, util.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util.createElement(internal$1.normalizePageHTML(templateHTML));
      this._verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @param {Element} element
     */

  }, {
    key: '_verifyPageElement',
    value: function _verifyPageElement(element) {
      if (element.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('You must supply an "ons-page" element to "ons-navigator".');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      if (this.topPage) {
        this.topPage._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this.topPage) {
        this.topPage._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pagepush[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]page[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]push[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pagepop[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]page[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]pagepop[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pagepush[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushpage[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]page[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pagepop[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pop[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]pop[/ja]
     */

    get: function get() {
      return this._animatorFactory;
    }
  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]pushPage()resetToPage()[/ja]
     */

  }, {
    key: 'topPage',
    get: function get() {
      return this.pages[this.pages.length - 1] || null;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this.children).filter(function (element) {
        return element.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.refresh
     * @default  false
     * @type {Boolean}
     * @description
     *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
     *   [ja]popPagetrue[/ja]
     */

  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
        throw new Error('"Animator" param must inherit NavigatorElement.NavigatorTransitionAnimator');
      }

      _animatorDict$3[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['animation'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$3;
    }
  }, {
    key: 'NavigatorTransitionAnimator',
    get: function get() {
      return NavigatorTransitionAnimator;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['prepush', 'postpush', 'prepop', 'postpop'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$9 = 'toolbar';

var scheme$13 = {
  '': 'toolbar--*',
  '.toolbar__left': 'toolbar--*__left',
  '.toolbar__center': 'toolbar--*__center',
  '.toolbar__right': 'toolbar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar[/en]
 *   [ja][/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar [en]Adding a toolbar[/en][ja][/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbar[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-button[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-button[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);
    return possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).apply(this, arguments));
  }

  createClass(ToolbarElement, [{
    key: 'init',


    /**
     * @attribute inline
     * @initonly
     * @description
     *   [en]Display the toolbar as an inline element.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$9)) {
            this.className = defaultClassName$9 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$13);
          break;
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$9);
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$13);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('toolbar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util.findChild(this, '.toolbar__' + name)) {
        var _element = util.findChild(this, '.toolbar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util.findChild(this, '.' + name) || util.create('.' + name);
      element.classList.add('toolbar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$8 = 'page';
var scheme$12 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

var nullToolbarElement = document.createElement('ons-toolbar'); // requires that 'ons-toolbar' element is registered

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/page
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]1HTML[/ja]
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages[/en]
 *   [ja][/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  function PageElement() {
    classCallCheck(this, PageElement);
    return possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).apply(this, arguments));
  }

  createClass(PageElement, [{
    key: 'init',


    /**
     * @event init
     * @description
     *   [en]Fired right after the page is attached.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event show
     * @description
     *   [en]Fired right after the page is shown.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event hide
     * @description
     *   [en]Fired right after the page is hidden.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event destroy
     * @description
     *   [en]Fired right before the page is destroyed.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Specify modifier name to specify custom styles.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute on-infinite-scroll
     * @type {String}
     * @description
     *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this.classList.add(defaultClassName$8);
      this._initialized = false;

      contentReady(this, function () {
        _this2._compile();

        _this2._isShown = false;
        _this2._contentElement = _this2._getContentElement();
        _this2._isMuted = _this2.hasAttribute('_muted');
        _this2._skipInit = _this2.hasAttribute('_skipinit');
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      contentReady(this, function () {
        if (!_this3._isMuted) {
          if (_this3._skipInit) {
            _this3.removeAttribute('_skipinit');
          } else {
            setImmediate(function () {
              return util.triggerElementEvent(_this3, 'init');
            });
          }
        }

        if (!util.hasAnyComponentAsParent(_this3)) {
          setImmediate(function () {
            return _this3._show();
          });
        }

        _this3._tryToFillStatusBar();

        if (_this3.hasAttribute('on-infinite-scroll')) {
          _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this4 = this;

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
      });
    }
  }, {
    key: '_hasAPageControlChild',
    value: function _hasAPageControlChild() {
      return util.findChild(this._contentElement, function (e) {
        return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
      });
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_getContentElement',


    /**
     * @return {HTMLElement}
     */
    value: function _getContentElement() {
      var result = util.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__content" element.');
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      if (util.findChild(this, 'ons-toolbar')) {
        return true;
      }
      return !!util.findChild(this._contentElement, function (el) {
        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__background" element.');
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$8)) {
            this.className = defaultClassName$8 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$12);
          break;
        case '_muted':
          this._isMuted = this.hasAttribute('_muted');
          break;
        case '_skipinit':
          this._skipInit = this.hasAttribute('_skipinit');
          break;
        case 'on-infinite-scroll':
          if (current === null) {
            this.onInfiniteScroll = null;
          } else {
            this.onInfiniteScroll = function (done) {
              var f = util.findFromPath(current);
              _this6.onInfiniteScroll = f;
              f(done);
            };
          }
          break;
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this7 = this;

      autoStyle.prepare(this);

      if (util.findChild(this, '.content')) {
        util.findChild(this, '.content').classList.add('page__content');
      }

      if (util.findChild(this, '.background')) {
        util.findChild(this, '.background').classList.add('page__background');
      }

      if (!util.findChild(this, '.page__content')) {
        var content = util.create('.page__content');

        util.arrayFrom(this.childNodes).forEach(function (node) {
          if (node.nodeType !== 1 || _this7._elementShouldBeMoved(node)) {
            content.appendChild(node);
          }
        });

        var prevNode = util.findChild(this, '.page__background') || util.findChild(this, 'ons-toolbar');

        this.insertBefore(content, prevNode && prevNode.nextSibling);
      }

      if (!util.findChild(this, '.page__background')) {
        var background = util.create('.page__background');
        this.insertBefore(background, util.findChild(this, '.page__content'));
      }

      ModifierUtil.initModifier(this, scheme$12);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util.isAttached(this)) {
        this._isShown = true;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'show');
        }

        util.propagateAction(this, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'hide');
        }

        util.propagateAction(this, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      if (!this._isMuted) {
        util.triggerElementEvent(this, 'destroy');
      }

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util.propagateAction(this, '_destroy');

      this.remove();
    }
  }, {
    key: 'name',
    set: function set(str) {
      this.setAttribute('name', str);
    },
    get: function get() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get() {
      return this.querySelector('ons-back-button');
    }
  }, {
    key: 'onInfiniteScroll',
    set: function set(value) {
      var _this8 = this;

      if (value === null) {
        this._onInfiniteScroll = null;
        this._contentElement.removeEventListener('scroll', this._boundOnScroll);
        return;
      }
      if (!(value instanceof Function)) {
        throw new Error('onInfiniteScroll must be a function or null');
      }
      if (!this._onInfiniteScroll) {
        this._infiniteScrollLimit = 0.9;
        this._boundOnScroll = this._onScroll.bind(this);
        setImmediate(function () {
          return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
        });
      }
      this._onInfiniteScroll = value;
    },
    get: function get() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', '_muted', '_skipinit', 'on-infinite-scroll', 'class'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['init', 'show', 'hide', 'destroy'];
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }]);
  return PageElement;
}(BaseElement);

customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function (_BaseAnimator) {
  inherits(PopoverAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, PopoverAnimator);
    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref2) {
      var from = _ref2.from,
          to = _ref2.to,
          options = _ref2.options,
          callback = _ref2.callback,
          _ref2$restore = _ref2.restore,
          restore = _ref2$restore === undefined ? false : _ref2$restore,
          animation = _ref2.animation;

      options = util.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = Animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(this.delay).queue({
        css: to,
        duration: this.duration,
        timing: this.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this2 = this;

      Object.keys(animations).forEach(function (key) {
        return _this2._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}(BaseAnimator);

var fade$1 = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: { animation: fade$1.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.out,
        _popover: { animation: fade$1.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$14 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__content': 'popover--*__content',
  '.popover__arrow': 'popover--*__arrow'
};

var _animatorDict$4 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja][/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide dialogs
 *  [en]Dialog components[/en]
 *  [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseElement) {
  inherits(PopoverElement, _BaseElement);

  function PopoverElement() {
    classCallCheck(this, PopoverElement);
    return possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).apply(this, arguments));
  }

  createClass(PopoverElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._initAnimatorFactory();
        _this2.style.display = 'none';
      });

      this._doorLock = new DoorLock();
      this._boundOnChange = this._onChange.bind(this);
      this._boundCancel = function () {
        return _this2._cancel();
      };
    }
  }, {
    key: '_initAnimatorFactory',
    value: function _initAnimatorFactory() {
      var factory = new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
      this._animator = function (options) {
        return factory.newAnimator(options);
      };
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          contentElement = this._content,
          margin = this._margin;

      var targetRect = target.getBoundingClientRect();
      var isMD = util.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');

      var targetDistance = {
        top: targetRect.top - margin,
        left: targetRect.left - margin,
        right: window.innerWidth - targetRect.right - margin,
        bottom: window.innerHeight - targetRect.bottom - margin
      };

      var targetCenterDistanceFrom = {
        top: targetRect.top + Math.round(targetRect.height / 2),
        bottom: window.innerHeight - targetRect.bottom + Math.round(targetRect.height / 2),
        left: targetRect.left + Math.round(targetRect.width / 2),
        right: window.innerWidth - targetRect.right + Math.round(targetRect.width / 2)
      };

      var _calculateDirections2 = this._calculateDirections(targetDistance),
          vertical = _calculateDirections2.vertical,
          primaryDirection = _calculateDirections2.primary,
          secondary = _calculateDirections2.secondary;

      ModifierUtil.addModifier(this, primaryDirection);

      var sizeName = vertical ? 'width' : 'height';
      // Get .popover__content size
      var contentSize = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width'), 10),
          height: parseInt(style.getPropertyValue('height'), 10)
        };
      }(window.getComputedStyle(contentElement));

      // Setting .popover position.
      var offset = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);
      this._popover.style[primaryDirection] = Math.max(margin, targetDistance[primaryDirection] + offset + margin) + 'px';
      var secondaryOffset = Math.max(margin, margin + targetDistance[secondary] - (contentSize[sizeName] - targetRect[sizeName]) / 2);
      this._popover.style[secondary] = secondaryOffset + 'px';

      // Setting .popover__arrow position.
      this._arrow.style[secondary] = Math.max(radius, targetCenterDistanceFrom[secondary] - secondaryOffset) + 'px';
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = 'top' == primary || 'bottom' == primary;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this3 = this;

      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this3._arrow.style[e] = _this3._content.style[e] = _this3._popover.style[e] = '';
        ModifierUtil.removeModifier(_this3, e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this4 = this;

      setImmediate(function () {
        if (_this4._currentTarget) {
          _this4._positionPopover(_this4._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this._popover && this._mask) {
        return;
      }

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = templateSource.cloneNode(true);
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      // FIXME!
      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      // FIXME!
      if (this.hasAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme$14);
    }
  }, {
    key: '_prepareAnimationOptions',
    value: function _prepareAnimationOptions(options) {
      if (options.animation && !(options.animation in _animatorDict$4)) {
        throw new Error('Animator ' + options.animation + ' is not registered.');
      }

      options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
    }
  }, {
    key: '_executeAction',
    value: function _executeAction(actions) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var callback = options.callback;
      var action = actions.action,
          before = actions.before,
          after = actions.after;


      this._prepareAnimationOptions(options);

      var canceled = false;
      util.triggerElementEvent(this, 'pre' + action, { // synchronous
        popover: this,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this5._doorLock.waitUnlock(function () {
          var unlock = _this5._doorLock.lock();

          before && before();

          contentReady(_this5, function () {
            _this5._animator(options)[action](_this5, function () {
              after && after();

              unlock();

              util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

              callback && callback();
              resolve(_this5);
            });
          });
        });
      });
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
     *   [ja]CSSeventDOM[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]target$eventDOMCSS[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Accepts options.target
      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
        options = target;
        target = options.target;
      }

      if (typeof target === 'string') {
        target = document.querySelector(target);
      } else if (target instanceof Event) {
        target = target.target;
      }

      if (typeof target === 'undefined') {
        throw new Error('A target argument must be defined for the popover.');
      }

      if (!(target instanceof HTMLElement)) {
        throw new Error('Invalid target');
      }

      return this._executeAction({
        action: 'show',
        before: function before() {
          _this6.style.display = 'block';
          _this6._currentTarget = target;
          _this6._positionPopover(target);
        }
      }, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._executeAction({
        action: 'hide',
        after: function after() {
          _this7.style.display = 'none';
          _this7._clearStyles();
        }
      }, options);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this8 = this;

      contentReady(this, function () {
        _this8._margin = _this8._margin || parseInt(window.getComputedStyle(_this8).getPropertyValue('top'));

        // Fix for iframes
        if (!_this8._margin) {
          _this8._margin = 6;
        }

        _this8._radius = parseInt(window.getComputedStyle(_this8._content).getPropertyValue('border-top-left-radius'));

        _this8._mask.addEventListener('click', _this8._boundCancel, false);

        _this8.onDeviceBackButton = function (e) {
          return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
        };

        window.addEventListener('resize', _this8._boundOnChange, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this9 = this;

      contentReady(this, function () {
        _this9._mask.removeEventListener('click', _this9._boundCancel, false);

        _this9._backButtonHandler.destroy();
        _this9._backButtonHandler = null;

        window.removeEventListener('resize', _this9._boundOnChange, false);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$14);
          break;
        case 'direction':
          this._boundOnChange();
          break;
        case 'animation':
          this._initAnimatorFactory();
          break;
      }
    }
  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this10 = this;

      if (this.cancelable) {
        this.hide({
          callback: function callback() {
            util.triggerElementEvent(_this10, 'dialog-cancel');
          }
        });
      }
    }
  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the popover is displayed.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being shown.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the popover is displayed.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the popover is hidden.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being hidden.[/en]
     *   [ja][/ja]
     */

    /**
     * @event posthide
     * @description
     *   [en]Fired just after the popover is hidden.[/en]
     *   [ja][/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the popover.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *  [en]
     *    A space separated list of directions. If more than one direction is specified,
     *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
     *  [/en]
     *  [ja]
     *    
     *    "up", "down", "left", "right"4
     *    
     *  [/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute cover-target
     * @description
     *   [en]If set the popover will cover the target on the screen.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @description
     *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {Color}
     * @description
     *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *   [ja]"rgba(0, 0, 0, 0.2)"[/ja]
     */

    get: function get() {
      return util.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get() {
      return util.findChild(this, '.popover');
    }
  }, {
    key: '_content',
    get: function get() {
      return util.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get() {
      return util.findChild(this._popover, '.popover__arrow');
    }
  }, {
    key: 'visible',
    get: function get() {
      return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this._popover, callback);
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        throw new Error('"Animator" param must inherit PopoverAnimator');
      }
      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'direction', 'animation'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$4;
    }
  }, {
    key: 'PopoverAnimator',
    get: function get() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseElement);

customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$15 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar--*__primary',
  '.progress-bar__secondary': 'progress-bar--*__secondary'
};

var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

/**
 * @element ons-progress-bar
 * @category visual
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);
    return possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).apply(this, arguments));
  }

  createClass(ProgressBarElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util.findChild(this, '.progress-bar');
      }

      this._primary = util.findChild(this._template, '.progress-bar__primary');
      this._secondary = util.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$15);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util.findChild(this, '.progress-bar');

      if (!util.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--indeterminate');
          _this3._template.classList.remove('progress-bar--determinate');
        });
      } else {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--determinate');
          _this3._template.classList.remove('progress-bar--indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._primary.style.width = _this4.hasAttribute('value') ? _this4.getAttribute('value') + '%' : '0%';
        _this4._secondary.style.width = _this4.hasAttribute('secondary-value') ? _this4.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$16 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__primary': 'progress-circular--*__primary',
  '.progress-circular__secondary': 'progress-circular--*__secondary'
};

var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" />\n    <circle class="progress-circular__primary" />\n  </svg>\n');

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);
    return possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).apply(this, arguments));
  }

  createClass(ProgressCircularElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          ModifierUtil.addModifier(_this3, 'indeterminate');
        });
      } else {
        contentReady(this, function () {
          ModifierUtil.removeModifier(_this3, 'indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('value') * 251.32 * 0.01);
          _this4._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('secondary-value') * 251.32 * 0.01);
          _this4._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util.findChild(this._template, '.progress-circular__primary');
      this._secondary = util.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$16);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util.findChild(this, '.progress-circular');

      if (!util.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]0100[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

var removeTransform = function removeTransform(el) {
  el.style.transform = '';
  el.style.WebkitTransform = '';
  el.style.transition = '';
  el.style.WebkitTransition = '';
};

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  function PullHookElement() {
    classCallCheck(this, PullHookElement);
    return possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).apply(this, arguments));
  }

  createClass(PullHookElement, [{
    key: 'init',


    /**
     * @event changestate
     * @description
     *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
     *   [ja]"initial", "preaction", "action"[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.pullHook
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {String} event.state
     *   [en]Current state.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
     *   [ja]disabled[/ja]
     */

    /**
     * @attribute height
     * @type {String}
     * @description
     *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
     *   [ja]pull down"preaction""64px"[/ja]
     */

    /**
     * @attribute threshold-height
     * @type {String}
     * @description
     *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
     *   [ja]pull down"action"[/ja]
     */

    /**
     * @attribute fixed-content
     * @description
     *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnScroll = this._onScroll.bind(this);

      this._setState(STATE_INITIAL, true);
      this._hide(); // Fix for transparent toolbar transitions
    }
  }, {
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height;

      this.style.height = height + 'px';
      this.style.lineHeight = height + 'px';
      this.style.marginTop = '-1px';
      this._pageElement.style.marginTop = '-' + height + 'px';
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_generateTranslationTransform',
    value: function _generateTranslationTransform(scroll) {
      return 'translate3d(0px, ' + scroll + 'px, 0px)';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this2 = this;

      if (this.disabled) {
        return;
      }

      // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
      // there will be no inertial scroll when scrolling down. Allowing default scrolling will
      // kill all 'touchmove' events.
      if (platform.isAndroid()) {
        var element = this._pageElement;
        element.scrollTop = this._startScroll - event.gesture.deltaY;
        if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
          event.gesture.preventDefault();
        }
      }

      if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
        this._transitionDragLength = event.gesture.deltaY;

        var direction = event.gesture.interimDirection;
        if (direction === 'down') {
          this._transitionDragLength -= 1;
        } else {
          this._transitionDragLength += 1;
        }
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

      if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
        event.gesture.stopDetect();

        setImmediate(function () {
          return _this2._finish();
        });
      } else if (scroll >= this.height) {
        this._setState(STATE_PREACTION);
      } else {
        this._setState(STATE_INITIAL);
      }

      // By stopping propagation only of `dragup` and `dragdown`,
      // allowing ancestor elements to detect `dragleft` and `dragright`.
      // If we comment out the following `if` block, `ons-splitter` with `ons-pull-hook` will be broken.
      if (event.gesture.direction === 'up' || event.gesture.direction === 'down') {
        event.stopPropagation();
      }
      this._translateTo(scroll);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      if (this.disabled) {
        return;
      }

      this._startScroll = this._getCurrentScroll();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      if (this.disabled) {
        return;
      }

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this3 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this3._translateTo(0, { animate: true });
        _this3._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_thresholdHeightEnabled',
    value: function _thresholdHeightEnabled() {
      var th = this.thresholdHeight;
      return th > 0 && th >= this.height;
    }
  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this._getState();

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this._getState()) {
        util.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }
  }, {
    key: '_getState',
    value: function _getState() {
      return this.getAttribute('state');
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_getCurrentScroll',
    value: function _getCurrentScroll() {
      return this._pageElement.scrollTop;
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_isContentFixed',
    value: function _isContentFixed() {
      return this.hasAttribute('fixed-content');
    }
  }, {
    key: '_getScrollableElement',
    value: function _getScrollableElement() {
      if (this._isContentFixed()) {
        return this;
      } else {
        return this._pageElement;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.style.visibility = '';
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.style.visibility = 'hidden';
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      var done = function done() {
        if (scroll === 0) {
          var el = _this4._getScrollableElement();
          removeTransform(el);
        }

        if (options.callback) {
          options.callback();
        }
      };

      this._currentTranslation = scroll;

      if (options.animate) {
        Animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }, {
          duration: 0.3,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).play(done);
      } else {
        Animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }).play(done);
      }
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._destroyEventListeners();
      this._createEventListeners();
    }
  }, {
    key: '_createEventListeners',
    value: function _createEventListeners() {
      this._gestureDetector = new GestureDetector(this._pageElement, {
        dragMinDistance: 1,
        dragDistanceCorrection: false,
        dragLockToAxis: !this._dragLockDisabled
      });

      // Bind listeners
      //
      // Note:
      // If we swipe up/down a screen too fast,
      // the gesture detector occasionally dispatches a `dragleft` or `dragright`,
      // so we need to have the pull hook listen to `dragleft` and `dragright` as well as `dragup` and `dragdown`.
      this._gestureDetector.on('dragup dragdown dragleft dragright', this._boundOnDrag);
      this._gestureDetector.on('dragstart', this._boundOnDragStart);
      this._gestureDetector.on('dragend', this._boundOnDragEnd);

      this._pageElement.addEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: '_destroyEventListeners',
    value: function _destroyEventListeners() {
      if (this._gestureDetector) {
        this._gestureDetector.off('dragup dragdown dragleft dragright', this._boundOnDrag);
        this._gestureDetector.off('dragstart', this._boundOnDragStart);
        this._gestureDetector.off('dragend', this._boundOnDragEnd);

        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }

      this._pageElement.removeEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._createEventListeners();
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._pageElement.style.marginTop = '';

      this._destroyEventListeners();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height') {
        this._setStyle();
      }
    }
  }, {
    key: 'onAction',
    get: function get() {
      return this._onAction;
    },
    set: function set(value) {
      if (!(value instanceof Function) && value !== null) {
        throw new Error('onAction must be a function or null');
      }
      this._onAction = value;
    }
  }, {
    key: 'height',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The height must be an integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The threshold height must be an integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get() {
      return this._getState();
    }
  }, {
    key: 'pullDistance',
    get: function get() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['height'];
    }
  }, {
    key: 'STATE_INITIAL',
    get: function get() {
      return STATE_INITIAL;
    }
  }, {
    key: 'STATE_PREACTION',
    get: function get() {
      return STATE_PREACTION;
    }
  }, {
    key: 'STATE_ACTION',
    get: function get() {
      return STATE_ACTION;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['changestate'];
    }
  }]);
  return PullHookElement;
}(BaseElement);

customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            timeout && clearTimeout(timeout);

            var passed = new Date().getTime() - start;
            var k = passed / duration;
            var remaining = newDuration * (1 - k);

            properties.forEach(function (i) {
              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
            });

            updateStyles();

            start = el.speedUpTime;
            duration = remaining;

            el.style.transitionDuration = duration / 1000 + 's';

            properties.forEach(function (i) {
              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
            });

            timeout = setTimeout(result.stop, remaining);
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$10 = 'ripple';

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]DOM[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @guide cross-platform-styling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  function RippleElement() {
    classCallCheck(this, RippleElement);
    return possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).apply(this, arguments));
  }

  createClass(RippleElement, [{
    key: 'init',


    /**
     * @attribute color
     * @type {String}
     * @description
     *   [en]Color of the ripple effect.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute background
     * @type {String}
     * @description
     *   [en]Color of the background.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._animator = new AnimatorCSS();

      ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
        _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$10);

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util.create('.ripple__wave');
        this._background = util.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x, y, h, w, r;
      var b = this.getBoundingClientRect();
      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;
        r = Math.sqrt(x * x + y * y);
      } else {
        x = (e.clientX || e.changedTouches[0].clientX) - b.left;
        y = (e.clientY || e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);
        r = Math.sqrt(h * h + w * w);
      }
      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR,
          _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this3 = this;

      if (!this.disabled) {
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this4 = this;

      if (this._holding) {
        this._holding.speed(300).then(function () {
          _this4._animator.stopAll({ stopNext: true });
          _this4._animator.fade(_this4._wave);
          _this4._animator.fade(_this4._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;
      this._boundOnTap = this._onTap.bind(this);
      this._boundOnHold = this._onHold.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnRelease = this._onRelease.bind(this);

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._boundOnTap);
        this._parentNode.addEventListener('hold', this._boundOnHold);
        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._boundOnTap);
      pn.removeEventListener('hold', this._boundOnHold);
      pn.removeEventListener('dragstart', this._boundOnDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {

        case 'class':
          if (!this.classList.contains(defaultClassName$10)) {
            this.className = defaultClassName$10 + ' ' + current;
          }
          break;

        case 'start-radius':
          this._minR = Math.max(0, parseFloat(current) || 0);
          break;

        case 'color':
          if (current) {
            contentReady(this, function () {
              _this5._wave.style.background = current;
              if (!_this5.hasAttribute('background')) {
                _this5._background.style.background = current;
              }
            });
          }
          break;

        case 'background':
          if (current || last) {
            if (current === 'none') {
              contentReady(this, function () {
                _this5._background.setAttribute('disabled', 'disabled');
                _this5._background.style.background = 'transparent';
              });
            } else {
              contentReady(this, function () {
                if (_this5._background.hasAttribute('disabled')) {
                  _this5._background.removeAttribute('disabled');
                }
                _this5._background.style.background = current;
              });
            }
          }
          break;

        case 'center':
          if (name === 'center') {
            this._center = current != null && current != 'false';
          }
          break;

      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['start-radius', 'color', 'background', 'center', 'class'];
    }
  }]);
  return RippleElement;
}(BaseElement);

customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]ons-col[/ja]
 * @codepen GgujC {wide}
 * @guide layouting
 *   [en]Layouting guide[/en]
 *   [ja][/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-col[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3iOS 6OSons-rowons-colons-colvertical-alignvertical-align[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]topbottomcenter[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$17 = {
  '': 'select-*',
  '.select-input': 'select-input--*'
};

var defaultClassName$11 = 'select';

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];

/**
 * @element ons-select
 * @category form
 * @modifier material
 *  [en]Displays a Material Design select input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a select input.[/en]
 *  [ja][/ja]
 * @description
 *   [en]
 *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id="my-id">`.
 *
 *     The component will automatically display as a Material Design select on Android.
 *
 *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
 *   [/en]
 *   [ja]`select`  `ons-select` [/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/select
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-select>
 *   <option value="1">1</option>
 *   <option value="2">2nd</option>
 *   <option value="3">3rd option</option>
 * </ons-select>
 */

var SelectElement = function (_BaseElement) {
  inherits(SelectElement, _BaseElement);

  function SelectElement() {
    classCallCheck(this, SelectElement);
    return possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).apply(this, arguments));
  }

  createClass(SelectElement, [{
    key: 'init',


    /**
     * @attribute autofocus
     * @type {Boolean}
     * @default false
     * @description
     *  [en]Element automatically gains focus on page load.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @type {Boolean}
     * @default false
     * @description
     *   [en]Specify if select input should be disabled.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute form
     * @type {String}
     * @description
     *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
     *   [ja] `form`  `form` [/ja]
     */

    /**
     * @attribute multiple
     * @type {Boolean}
     * @default false
     * @description
     *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute name
     * @type {String}
     * @description
     *   [en]Name the select element, useful for instance if it is part of a form.[/en]
     *   [ja] `form` [/ja]
     */

    /**
     * @attribute required
     * @type {Boolean}
     * @description
     *   [en]Make the select input required for submitting the form it is part of.[/en]
     *   [ja] `form` [/ja]
     */

    /**
     * @attribute select-id
     * @type {String}
     * @description
     *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]
     *   [ja] select  ID [/ja]
     */

    /**
     * @attribute size
     * @type {Number}
     * @default 1
     * @description
     *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$11)) {
            this.className = defaultClassName$11 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
          break;
      }

      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this3._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this4 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this4.hasAttribute(attr)) {
          _this4._select.setAttribute(attr, _this4.getAttribute(attr));
        } else {
          _this4._select.removeAttribute(attr);
        }
      });
    }

    /**
     * @property length
     * @description
     *   [en]Number of options in the select box.[/en]
     *   [ja] `select` [/ja]
     */

    /**
     * @property options
     * @description
     *   [en]Several options for handling the select DOM object.[/en]
     *   [ja] `option` [/ja]
     */

    /**
     * @property selectedIndex
     * @description
     *   [en]Index of the currently selected option.[/en]
     *   [ja][/ja]
     */

    /**
     * @property value
     * @description
     *   [en]Value of the currently selected option.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      var _this5 = this;

      autoStyle.prepare(this);

      this.classList.add(defaultClassName$11);
      var sel = this._select || document.createElement('select');
      if (!sel.id && this.hasAttribute('select-id')) {
        sel.id = this.getAttribute('select-id');
      }
      sel.classList.add('select-input');
      if (!this._select) {
        util.arrayFrom(this.childNodes).forEach(function (element) {
          return sel.appendChild(element);
        });
        this.appendChild(sel);
      }

      ModifierUtil.initModifier(this, scheme$17);

      var _arr = ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value'];

      var _loop = function _loop() {
        var key = _arr[_i];
        _this5.__defineGetter__(key, function () {
          return _this5._select[key];
        });
        _this5.__defineSetter__(key, function (value) {
          _this5._select[key] = value;
        });
      };

      for (var _i = 0; _i < _arr.length; _i++) {
        _loop();
      }
      this.__defineGetter__('form', function () {
        return _this5._select['form'];
      });
      this.__defineGetter__('type', function () {
        return _this5._select['type'];
      });

      this.add = function (option) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _this5._select.add(option, index);
      };
      this.remove = function (index) {
        _this5._select.remove(index);
      };
    }
  }, {
    key: '_select',
    get: function get() {
      return this.querySelector('select');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change'];
    }
  }]);
  return SelectElement;
}(BaseElement);

customElements.define('ons-select', SelectElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$12 = 'fab fab--mini speed-dial__item';

var scheme$18 = {
  '': 'speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignSpeed dial
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dial[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fab[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);
    return possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).apply(this, arguments));
  }

  createClass(SpeedDialItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          this._updateClassName(current);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: '_updateClassName',
    value: function _updateClassName(className) {
      var _this2 = this;

      if (!defaultClassName$12.split(/\s+/).every(function (token) {
        return _this2.classList.contains(token);
      })) {
        this.className = defaultClassName$12 + ' ' + className;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this3 = this;

      autoStyle.prepare(this);

      defaultClassName$12.split(/\s+/).forEach(function (token) {
        _this3.classList.add(token);
      });

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$18);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal utility library for manipulating element's style.
 */
var styler = function styler(element, style) {
  return styler.css.apply(styler, arguments);
};

/**
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
styler.css = function (element, styles) {
  var keys = Object.keys(styles);
  keys.forEach(function (key) {
    if (key in element.style) {
      element.style[key] = styles[key];
    } else if (styler._prefix(key) in element.style) {
      element.style[styler._prefix(key)] = styles[key];
    } else {
      util.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
styler._prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
  };
}();

/**
 * @param {Element} element
 */
styler.clear = function (element) {
  styler._clear(element);
};

/**
 * @param {Element} element
 */
styler._clear = function (element) {
  var len = element.style.length;
  var style = element.style;
  var keys = [];
  for (var i = 0; i < len; i++) {
    keys.push(style[i]);
  }

  keys.forEach(function (key) {
    style[key] = '';
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$13 = 'speed-dial';
var scheme$19 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-item[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fab[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);
    return possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).apply(this, arguments));
  }

  createClass(SpeedDialElement, [{
    key: 'init',


    /**
     * @event open
     * @description
     *   [en]Fired when the menu items are shown.[/en]
     *   [ja][/ja]
     */

    /**
     * @event close
     * @description
     *   [en]Fired when the menu items are hidden.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *   [en]
     *     Specify the vertical and horizontal position of the component.
     *     I.e. to display it in the top right corner specify "right top".
     *     Choose from "right", "left", "top" and "bottom".
     *   [/en]
     *   [ja]
     *     
     *     "right top"
     *     rightlefttopbottom
     *   [/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
     *   [ja]
     *     up, down, left, right
     *   [/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._itemShown = false;
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$13);
      autoStyle.prepare(this);
      this._updateRipple();
      ModifierUtil.initModifier(this, scheme$19);

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$13)) {
            this.className = defaultClassName$13 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$19);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this3._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this3._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this3._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (this.onClick) {
        this.onClick.apply(this);
        return Promise.resolve();
      } else if (!this.disabled && this.visible) {
        return this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        return this.show();
      }
      return Promise.resolve();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this4 = this;

      return new Promise(function (resolve) {
        if (!_this4.inline) {
          setImmediate(function () {
            return _this4.hide().then(resolve);
          });
        } else {
          resolve();
        }
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      if (this._fab) {
        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          throw new Error('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this._fab.show();
      return Promise.resolve();
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this5 = this;

      return this.hideItems().then(function () {
        return _this5._fab.hide();
      });
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {
      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      var totalDelay = 0;
      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * i;
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = true;
        util.triggerElementEvent(this, 'open');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      var totalDelay = 0;
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * (children.length - i);
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = false;
        util.triggerElementEvent(this, 'close');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dial[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      return this.isOpen() ? this.hideItems() : this.showItems();
    }
  }, {
    key: 'items',
    get: function get() {
      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: '_fab',
    get: function get() {
      return util.findChild(this, 'ons-fab');
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      if (value) {
        this.hideItems();
      }
      util.arrayFrom(this.children).forEach(function (e) {
        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
      });

      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'inline',
    get: function get() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this._fab.visible && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['class', 'modifier', 'ripple', 'direction', 'position'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['open', 'close'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-contentons-splitter[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitter[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-side[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);
    return possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).apply(this, arguments));
  }

  createClass(SplitterContentElement, [{
    key: 'init',


    /**
     * @attribute page
     * @type {String}
     * @description
     *   [en]
     *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
     *
     *     It is also possible to put `<ons-page>` element as a child of the element.
     *   [/en]
     *   [ja]ons-splitter-contentURL[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;

      contentReady(this, function () {
        var page = _this2._getPageTarget();

        if (page) {
          _this2.load(page);
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageURLons-templateid[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]URL[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`Promise[/ja]
     */
    value: function load(page) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this3._content || null;

        _this3._pageLoader.load({ page: page, parent: _this3 }, function (pageElement) {
          if (oldContent) {
            _this3._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this3._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader');
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);
    return possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).apply(this, arguments));
  }

  createClass(SplitterMaskElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this._boundOnClick = this._onClick.bind(this);
      contentReady(this, function () {
        if (_this2.parentNode._sides.every(function (side) {
          return side.mode === 'split';
        })) {
          _this2.setAttribute('style', 'display: none !important');
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else if (util.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator = function (_BaseAnimator) {
  inherits(SplitterAnimator, _BaseAnimator);

  function SplitterAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, SplitterAnimator);
    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util.extend(this, {
        timing: this.timing, duration: this.duration, delay: this.delay
      }, options);
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this2 = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this2._side = sideElement;
        _this2._content = splitter.content;
        _this2._mask = splitter.mask;
      });
    }
  }, {
    key: 'inactivate',
    value: function inactivate() {
      this._content = this._side = this._mask = null;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      Animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this.duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        _this3._side.style.webkitTransition = '';
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        opacity: '0'
      }, {
        duration: this.duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }, {
    key: 'minus',
    get: function get() {
      return this._side._side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$5 = {
  default: SplitterAnimator,
  overlay: SplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-content[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-side[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);
    return possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).apply(this, arguments));
  }

  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util.findChild(this, function (e) {
        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        _this3.content.style[side.side] = side.mode === 'split' ? side._width : 0;
      });
    }
  }, {
    key: 'init',
    value: function init() {
      var _this4 = this;

      this._boundOnModeChange = this._onModeChange.bind(this);

      contentReady(this, function () {
        _this4._compile();
        _this4._layout();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this.mask) {
        this.appendChild(document.createElement('ons-splitter-mask'));
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util.propagateAction(this, '_destroy');
      this.remove();
    }
  }, {
    key: 'left',
    get: function get() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get() {
      return this._getSide('right');
    }

    /**
     * @property side
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'side',
    get: function get() {
      return util.findChild(this, 'ons-splitter-side');
    }
  }, {
    key: '_sides',
    get: function get() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get() {
      return util.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'topPage',
    get: function get() {
      return this.content._content;
    }
  }, {
    key: 'mask',
    get: function get() {
      return util.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        throw new Error('Animator parameter must be an instance of SplitterAnimator.');
      }
      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$5;
    }
  }]);
  return SplitterElement;
}(BaseElement);

customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var WATCHED_ATTRIBUTES = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold'];

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._boundOnChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._boundOnChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._boundOnChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._boundOnChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._boundOnChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

var widthToPx = function widthToPx(width, parent) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(parent.offsetWidth * value / 100);
};

var CollapseMode = function () {
  createClass(CollapseMode, [{
    key: '_animator',
    get: function get() {
      return this._element._animator;
    }
  }]);

  function CollapseMode(element) {
    classCallCheck(this, CollapseMode);

    this._active = false;
    this._state = CLOSED_STATE;
    this._element = element;
    this._lock = new DoorLock();
  }

  createClass(CollapseMode, [{
    key: 'isOpen',
    value: function isOpen() {
      return this._active && this._state !== CLOSED_STATE;
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
        return;
      }
      if (e.type === 'dragstart') {
        this._onDragStart(e);
      } else if (!this._ignoreDrag) {
        e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var scrolling = !/left|right/.test(event.gesture.direction);
      var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      var area = this._element._swipeTargetWidth;
      var isOpen = this.isOpen();
      this._ignoreDrag = scrolling || area && distance > area && !isOpen;

      this._width = widthToPx(this._element._width, this._element.parentNode);
      this._startDistance = this._distance = isOpen ? this._width : 0;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      event.gesture.preventDefault();
      var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._animator.translate(distance);
        this._distance = distance;
        this._state = CHANGING_STATE;
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var distance = this._distance,
          width = this._width,
          el = this._element;

      var direction = event.gesture.interimDirection;
      var shouldOpen = el._side !== direction && distance > width * el._threshold;
      this.executeAction(shouldOpen ? 'open' : 'close');
      this._ignoreDrag = true;
    }
  }, {
    key: 'layout',
    value: function layout() {
      if (this._active && this._state === OPEN_STATE) {
        this._animator.open();
      }
    }

    // enter collapse mode

  }, {
    key: 'enterMode',
    value: function enterMode() {
      if (!this._active) {
        this._active = true;
        this.layout();
      }
    }

    // exit collapse mode

  }, {
    key: 'exitMode',
    value: function exitMode() {
      this._active = false;
    }
  }, {
    key: '_isOpenOtherSideMenu',
    value: function _isOpenOtherSideMenu() {
      var _this = this;

      return util.arrayFrom(this._element.parentElement.children).some(function (e) {
        return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
      });
    }

    /**
     * @param {String} name - 'open' or 'close'
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @param {Boolean} [options.withoutAnimation]
     * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
     */

  }, {
    key: 'executeAction',
    value: function executeAction(name) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

      if (!this._active) {
        return Promise.resolve(false);
      }

      if (this._state === FINAL_STATE) {
        return Promise.resolve(this._element);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Splitter side is locked.');
      }
      if (name === 'open' && this._isOpenOtherSideMenu()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._element._emitEvent('pre' + name)) {
        return Promise.reject('Canceled in pre' + name + ' event.');
      }

      var callback = options.callback;
      var unlock = this._lock.lock();
      var done = function done() {
        _this2._state = FINAL_STATE;
        _this2.layout();
        unlock();
        _this2._element._emitEvent('post' + name);
        callback && callback();
      };

      if (options.withoutAnimation) {
        done();
        return Promise.resolve(this._element);
      }
      this._state = CHANGING_STATE;
      return new Promise(function (resolve) {
        _this2._animator[name](function () {
          done();
          resolve(_this2._element);
        });
      });
    }
  }]);
  return CollapseMode;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-sideons-splitter[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitter[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-content[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */


var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);
    return possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).apply(this, arguments));
  }

  createClass(SplitterSideElement, [{
    key: 'init',


    /**
     * @event modechange
     * @description
     *   [en]Fired just after the component's mode changes.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {String} event.mode
     *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
     *   [ja][/ja]
     */

    /**
     * @event preopen
     * @description
     *   [en]Fired just before the sliding menu is opened.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding menu.[/en]
     *   [ja][/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postopen
     * @description
     *   [en]Fired just after the sliding menu is opened.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @event preclose
     * @description
     *   [en]Fired just before the sliding menu is closed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja][/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding-menu.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postclose
     * @description
     *   [en]Fired just after the sliding menu is closed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default  default
     * @description
     *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
     *  [ja]"overlay", "default"[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute open-threshold
     * @type {Number}
     * @default  0.3
     * @description
     *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
     *  [ja]010.3[/ja]
     */

    /**
     * @attribute collapse
     * @type {String}
     * @description
     *   [en]
     *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
     *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
     *     If the value is a media query, the view will collapse when the media query resolves to `true`.
     *     If the value is not defined, the view always be in `"collapse"` mode.
     *   [/en]
     *   [ja]
     *     portrait, landscapewidth #px
     *     portraitlandscape
     *     
     *     collapse
     *   [/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute width
     * @type {String}
     * @description
     *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
     *   [ja]px%eg. 90%, 200px[/ja]
     */

    /**
     * @attribute side
     * @type {String}
     * @default left
     * @description
     *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
     *   [ja]"left""right"[/ja]
     */

    /**
     * @attribute mode
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
     *   [ja]"collapse""split"[/ja]
     */

    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The URL of the menu page.[/en]
     *   [ja]ons-splitter-sideURL[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Whether to enable swipe interaction on collapse mode.[/en]
     *   [ja]collapse[/ja]
     */

    value: function init() {
      var _this4 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;
      this._collapseMode = new CollapseMode(this);
      this._collapseDetection = new CollapseDetection(this);

      this._animatorFactory = new AnimatorFactory({
        animators: SplitterElement.animators,
        baseClass: SplitterAnimator,
        baseClassName: 'SplitterAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
      this._boundHandleGesture = function (e) {
        return _this4._collapseMode.handleGesture(e);
      };
      this._watchedAttributes = WATCHED_ATTRIBUTES;
      contentReady(this, function () {
        rewritables$2.ready(_this4, function () {
          var page = _this4._getPageTarget();

          if (page) {
            _this4.load(page);
          }
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('Parent must be an ons-splitter element.');
      }

      this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

      contentReady(this, function () {
        _this5._watchedAttributes.forEach(function (e) {
          return _this5._update(e);
        });
      });

      if (!this.hasAttribute('side')) {
        this.setAttribute('side', 'left');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._collapseDetection.disable();
      this._gestureDetector.dispose();
      this._gestureDetector = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._update(name, current);
    }
  }, {
    key: '_update',
    value: function _update(name, value) {
      name = '_update' + name.split('-').map(function (e) {
        return e[0].toUpperCase() + e.slice(1);
      }).join('');
      return this[name](value);
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }

    // readonly attribute for the users

  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
        this.setAttribute('mode', mode);

        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateOpenThreshold',
    value: function _updateOpenThreshold() {
      var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('open-threshold');

      this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipeable');

      var action = swipeable === null ? 'off' : 'on';

      if (this._gestureDetector) {
        this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
      }
    }
  }, {
    key: '_updateSwipeTargetWidth',
    value: function _updateSwipeTargetWidth() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipe-target-width');

      this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      this.style.width = this._width;
    }
  }, {
    key: '_updateSide',
    value: function _updateSide() {
      var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('side');

      this._side = side === 'right' ? side : 'left';
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      this._animator = this._animatorFactory.newAnimator({ animation: animation });
      this._animator.activate(this);
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseons-splitter-side[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('open', options);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseons-splitter-side[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('close', options);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.isOpen ? this.close(options) : this.open(options);
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
     *   [ja]pageURLons-templateid[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]URL[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this6._content || null;

        _this6._pageLoader.load({ page: page, parent: _this6 }, function (pageElement) {
          if (oldContent) {
            _this6._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this6._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'side',
    get: function get() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: '_width',
    get: function get() {
      var width = this.getAttribute('width');
      return (/^\d+(px|%)$/.test(width) ? width : '80%'
      );
    },
    set: function set(value) {
      this.setAttribute('width', value);
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get() {
      return this._mode;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open..[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get() {
      return this._collapseMode.isOpen();
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return WATCHED_ATTRIBUTES;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$14 = 'switch';

var scheme$20 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja][/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseElement) {
  inherits(SwitchElement, _BaseElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);
    return possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).apply(this, arguments));
  }

  createClass(SwitchElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this._checked = false;
      this._disabled = false;

      this._boundOnChange = this._onChange.bind(this);

      contentReady(this, function () {
        _this2._compile();
        ['checked', 'disabled', 'modifier', 'name', 'value', 'input-id'].forEach(function (e) {
          _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
        });
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$14);

      if (!(util.findChild(this, '.switch__input') && util.findChild(this, '.switch__toggle'))) {
        this.appendChild(template$2.cloneNode(true));
      }

      ModifierUtil.initModifier(this, scheme$20);

      this._checkbox = this.querySelector('.switch__input');
      this._handle = this.querySelector('.switch__handle');

      this._checkbox.checked = this._checked;
      this._checkbox.disabled = this._disabled;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._checkbox.removeEventListener('change', _this3._boundOnChange);
        _this3.removeEventListener('dragstart', _this3._onDragStart);
        _this3.removeEventListener('hold', _this3._onHold);
        _this3.removeEventListener('tap', _this3.click);
        _this3.removeEventListener('click', _this3._onClick);
        if (_this3._gestureDetector) {
          _this3._gestureDetector.dispose();
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._checkbox.addEventListener('change', _this4._boundOnChange);
        _this4.addEventListener('dragstart', _this4._onDragStart);
        _this4.addEventListener('hold', _this4._onHold);
        _this4.addEventListener('tap', _this4.click);
        _this4.addEventListener('click', _this4._onClick);
        _this4._gestureDetector = new GestureDetector(_this4, { dragMinDistance: 1, holdTimeout: 251 });
        _this4._boundOnRelease = _this4._onRelease.bind(_this4);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }
      this.click();
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains('switch__touch')) {
        ev.preventDefault();
      }
    }
  }, {
    key: 'click',
    value: function click() {
      if (!this._disabled) {
        this.checked = !this.checked;

        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }
    }
  }, {
    key: '_getPosition',
    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        ModifierUtil.addModifier(this, 'active');
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        ModifierUtil.removeModifier(this, 'active');
        return;
      }

      e.stopPropagation();

      ModifierUtil.addModifier(this, 'active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.gesture.srcEvent.preventDefault();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._boundOnRelease);

      this._handle.style.left = '';
      ModifierUtil.removeModifier(this, 'active');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      contentReady(this, function () {
        switch (name) {
          case 'class':
            if (!_this5.classList.contains(defaultClassName$14)) {
              _this5.className = defaultClassName$14 + ' ' + current;
            }
            break;

          case 'modifier':
            _this5._isMaterial = (current || '').indexOf('material') !== -1;
            _this5._locations = locations[_this5._isMaterial ? 'material' : 'ios'];
            ModifierUtil.onModifierChanged(last, current, _this5, scheme$20);
            break;

          case 'input-id':
            _this5._checkbox.id = current;
            break;

          case 'checked':
            _this5._checked = current !== null;
            _this5._checkbox.checked = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
            break;

          case 'disabled':
            _this5._disabled = current !== null;
            _this5._checkbox.disabled = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
            break;

          default:
            if (current !== null) {
              _this5._checkbox.setAttribute(name, current);
            } else {
              _this5._checkbox.removeAttribute(name);
            }
        }
      });
    }
  }, {
    key: 'checked',


    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFF[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]Switch[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja][/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]true[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]ON[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]ON`true`[/ja]
     */

    get: function get() {
      return this._checked;
    },
    set: function set(value) {
      this._checked = !!value;
      util.toggleAttribute(this, 'checked', this._checked);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this._disabled;
    },
    set: function set(value) {
      var _this6 = this;

      contentReady(this, function () {
        _this6._disabled = !!value;
        util.toggleAttribute(_this6, 'disabled', _this6._disabled);
        _this6._checkbox.disabled = _this6._disabled;
      });
    }

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]checkbox[/ja]
     */

  }, {
    key: 'checkbox',
    get: function get() {
      return this._checkbox;
    }
  }, {
    key: 'value',


    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */
    get: function get() {
      return !this.hasOwnProperty('_checkbox') ? this.getAttribute('value') : this._checkbox.value;
    },
    set: function set(val) {
      var _this7 = this;

      contentReady(this, function () {
        _this7._checkbox.value = val;
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'input-id', 'checked', 'value', 'disabled', 'class'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change'];
    }
  }]);
  return SwitchElement;
}(BaseElement);

customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var TabbarAnimator = function (_BaseAnimator) {
  inherits(TabbarAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function TabbarAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, TabbarAnimator);
    return possibleConstructorReturn(this, (TabbarAnimator.__proto__ || Object.getPrototypeOf(TabbarAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  /**
   * @param {Element} enterPage ons-page element
   * @param {Element} leavePage ons-page element
   * @param {Number} enterPageIndex
   * @param {Number} leavePageIndex
   * @param {Function} done
   */


  createClass(TabbarAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      throw new Error('This method must be implemented.');
    }
  }]);
  return TabbarAnimator;
}(BaseAnimator);

var TabbarNoneAnimator = function (_TabbarAnimator) {
  inherits(TabbarNoneAnimator, _TabbarAnimator);

  function TabbarNoneAnimator() {
    classCallCheck(this, TabbarNoneAnimator);
    return possibleConstructorReturn(this, (TabbarNoneAnimator.__proto__ || Object.getPrototypeOf(TabbarNoneAnimator)).apply(this, arguments));
  }

  createClass(TabbarNoneAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      setTimeout(done, 1000 / 60);
    }
  }]);
  return TabbarNoneAnimator;
}(TabbarAnimator);

var TabbarFadeAnimator = function (_TabbarAnimator2) {
  inherits(TabbarFadeAnimator, _TabbarAnimator2);

  function TabbarFadeAnimator() {
    classCallCheck(this, TabbarFadeAnimator);
    return possibleConstructorReturn(this, (TabbarFadeAnimator.__proto__ || Object.getPrototypeOf(TabbarFadeAnimator)).apply(this, arguments));
  }

  createClass(TabbarFadeAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      Animit.runAll(Animit(enterPage).saveStyle().queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), Animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarFadeAnimator;
}(TabbarAnimator);

var TabbarSlideAnimator = function (_TabbarAnimator3) {
  inherits(TabbarSlideAnimator, _TabbarAnimator3);

  function TabbarSlideAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.15 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, TabbarSlideAnimator);
    return possibleConstructorReturn(this, (TabbarSlideAnimator.__proto__ || Object.getPrototypeOf(TabbarSlideAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  /**
   * @param {jqLite} enterPage
   * @param {jqLite} leavePage
   */


  createClass(TabbarSlideAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      var sgn = enterIndex > leaveIndex;

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), Animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarSlideAnimator;
}(TabbarAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$22 = {
  '.tabbar__content': 'tabbar--*__content',
  '.tabbar': 'tabbar--*'
};

var _animatorDict$6 = {
  'default': TabbarNoneAnimator,
  'fade': TabbarFadeAnimator,
  'slide': TabbarSlideAnimator,
  'none': TabbarNoneAnimator
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-tabbar-gen-' + i++;
  };
}();

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]ons-tab[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]1HTML[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tab[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-page[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  function TabbarElement() {
    classCallCheck(this, TabbarElement);
    return possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).apply(this, arguments));
  }

  createClass(TabbarElement, [{
    key: 'init',


    /**
     * @event prechange
     * @description
     *   [en]Fires just before the tab is changed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]ons-tab[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItem[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the change event.[/en]
     *   [ja][/ja]
     */

    /**
     * @event postchange
     * @description
     *   [en]Fires just after the tab is changed.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]ons-tab[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItem[/ja]
     */

    /**
     * @event reactive
     * @description
     *   [en]Fires if the already open tab is tapped again.[/en]
     *   [ja][/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja][/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]ons-tab[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItem[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default none
     * @description
     *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
     *   [ja]"none""fade""slide""none"[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute position
     * @initonly
     * @type {String}
     * @default bottom
     * @description
     *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
     *   [ja]"bottom""top""bottom"[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._tabbarId = generateId$1();

      contentReady(this, function () {
        _this2._compile();

        var content = _this2._contentElement;
        for (var i = 0; i < content.children.length; i++) {
          content.children[i].style.display = 'none';
        }

        var activeIndex = _this2.getAttribute('activeIndex');

        var tabbar = _this2._tabbarElement;
        if (activeIndex && tabbar.children.length > activeIndex) {
          tabbar.children[activeIndex].setAttribute('active', 'true');
        }

        autoStyle.prepare(_this2);
        ModifierUtil.initModifier(_this2, scheme$22);

        _this2._animatorFactory = new AnimatorFactory({
          animators: _animatorDict$6,
          baseClass: TabbarAnimator,
          baseClassName: 'TabbarAnimator',
          defaultAnimation: _this2.getAttribute('animation')
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        return _this3._updatePosition();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (this._contentElement && this._tabbarElement) {
        var content = util.findChild(this, '.tabbar__content');
        var bar = util.findChild(this, '.tabbar');

        content.classList.add('ons-tabbar__content');
        bar.classList.add('ons-tabbar__footer');
      } else {

        var _content = util.create('.ons-tabbar__content.tabbar__content');
        var tabbar = util.create('.tabbar.ons-tabbar__footer');

        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }

        this.appendChild(_content);
        this.appendChild(tabbar);
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this4 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
      var action = top ? util.addModifier : util.removeModifier;

      action(this, 'top');

      var page = util.findParent(this, 'ons-page');
      if (page) {
        contentReady(page, function () {
          _this4.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

          if (util.match(page.firstChild, 'ons-toolbar')) {
            action(page.firstChild, 'noshadow');
          }
        });
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: '_getTabbarElement',
    value: function _getTabbarElement() {
      return util.findChild(this, '.tabbar');
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getTabbarId',
    value: function getTabbarId() {
      return this._tabbarId;
    }

    /**
     * @return {Element/null}
     */

  }, {
    key: '_getCurrentPageElement',
    value: function _getCurrentPageElement() {
      var pages = this._contentElement.children;
      var page = null;
      for (var i = 0; i < pages.length; i++) {
        if (pages[i].style.display !== 'none') {
          page = pages[i];
          break;
        }
      }

      if (page && page.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('Invalid state: page element must be a "ons-page" element.');
      }

      return page;
    }
  }, {
    key: '_switchPage',


    /**
     * @param {Element} element
     * @param {Object} options
     * @param {String} [options.animation]
     * @param {Function} [options.callback]
     * @param {Object} [options.animationOptions]
     * @param {Number} options.selectedTabIndex
     * @param {Number} options.previousTabIndex
     * @return {Promise} Resolves to the new page element.
     */
    value: function _switchPage(element, options) {
      var oldPageElement = this._oldPageElement || internal$1.nullElement;
      this._oldPageElement = element;
      var animator = this._animatorFactory.newAnimator(options);

      return new Promise(function (resolve) {
        if (oldPageElement !== internal$1.nullElement) {
          oldPageElement._hide();
        }

        animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
          if (oldPageElement !== internal$1.nullElement) {
            oldPageElement.style.display = 'none';
          }

          element.style.display = 'block';
          element._show();

          if (options.callback instanceof Function) {
            options.callback();
          }

          resolve(element);
        });
      });
    }

    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja][/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Boolean} [options.keepPage]
     *   [en]If true the page will not be changed.[/en]
     *   [ja]pagetrue[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
     *   [ja]`"fade"``"slide"``"none"`[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveTab',
    value: function setActiveTab(index) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      if (!options.animation && this.hasAttribute('animation')) {
        options.animation = this.getAttribute('animation');
      }

      var previousTab = this._getActiveTabElement(),
          selectedTab = this._getTabElement(index),
          previousTabIndex = this.getActiveTabIndex(),
          selectedTabIndex = index,
          previousPageElement = this._getCurrentPageElement();

      if (!selectedTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (selectedTabIndex === previousTabIndex) {
        util.triggerElementEvent(this, 'reactive', {
          index: selectedTabIndex,
          tabItem: selectedTab
        });

        return Promise.resolve(previousPageElement);
      }

      var canceled = false;

      util.triggerElementEvent(this, 'prechange', {
        index: selectedTabIndex,
        tabItem: selectedTab,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        selectedTab.setInactive();
        if (previousTab) {
          previousTab.setActive();
        }
        return Promise.reject('Canceled in prechange event.');
      }

      selectedTab.setActive();

      var params = _extends({}, options, {
        previousTabIndex: previousTabIndex,
        selectedTabIndex: selectedTabIndex
      });

      if (previousTab) {
        previousTab.setInactive();
      } else {
        params.animation = 'none';
      }

      return new Promise(function (resolve) {
        selectedTab._loadPageElement(_this5._contentElement, function (pageElement) {
          pageElement.removeAttribute('style');

          _this5._switchPage(pageElement, params).then(function (page) {
            util.triggerElementEvent(_this5, 'postchange', {
              index: selectedTabIndex,
              tabItem: selectedTab
            });

            return resolve(page);
          });
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
      this._getTabbarElement().style.display = visible ? '' : 'none';
    }
  }, {
    key: 'show',
    value: function show() {
      this.setTabbarVisibility(true);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setTabbarVisibility(false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the tabbar is visible or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'getActiveTabIndex',


    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]-1[/ja]
     */
    value: function getActiveTabIndex() {
      var tabs = this._getTabbarElement().children;

      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i] instanceof TabElement && tabs[i].isActive && tabs[i].isActive()) {
          return i;
        }
      }

      return -1;
    }

    /**
     * @return {Number} When active tab is not found, returns -1.
     */

  }, {
    key: '_getActiveTabElement',
    value: function _getActiveTabElement() {
      return this._getTabElement(this.getActiveTabIndex());
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_getTabElement',
    value: function _getTabElement(index) {
      return this._getTabbarElement().children[index];
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: '_show',
    value: function _show() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      var tabs = this._getTabbarElement().children;
      for (var i = tabs.length - 1; i >= 0; i--) {
        tabs[i].remove();
      }
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
      }
    }
  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this, '.tabbar__content');
    }
  }, {
    key: '_tabbarElement',
    get: function get() {
      return util.findChild(this, '.tabbar');
    }
  }, {
    key: 'topPage',
    get: function get() {
      return this._getCurrentPageElement();
    }
  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this._contentElement.children);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._getTabbarElement().style.display !== 'none';
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {Function} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof TabbarAnimator)) {
        throw new Error('"Animator" param must inherit TabbarElement.TabbarAnimator');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$3;
    }
  }, {
    key: 'TabbarAnimator',
    get: function get() {
      return TabbarAnimator;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['prechange', 'postchange', 'reactive'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$6;
    }
  }]);
  return TabbarElement;
}(BaseElement);

customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$15 = 'tabbar__item';

var scheme$21 = {
  '': 'tabbar--*__item',
  '.tabbar__button': 'tabbar--*__button'
};

var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tabbar__button"></button>\n  </div>\n');

var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tabbar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tabbar__label">label</div>\n    <div class="tabbar__badge notification">1</div>\n  </div>\n');

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     ons-tab
 *     ons-tab
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages.[/en]
 *   [ja]Managing multiple pages[/ja]]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]1HTML[/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbar[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-page[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-icon[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  function TabElement() {
    classCallCheck(this, TabElement);
    return possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).apply(this, arguments));
  }

  createClass(TabElement, [{
    key: 'init',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The page that is displayed when the tab is tapped.[/en]
     *   [ja]ons-tabURL[/ja]
     */

    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
     *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
     *   [/en]
     *   [ja]
     *     ons-icon
     *     background-imageCSS
     *   [/ja]
     */

    /**
     * @attribute active-icon
     * @type {String}
     * @description
     *   [en]The name of the icon when the tab is active.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute label
     * @type {String}
     * @description
     *   [en]The label of the tab item.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute badge
     * @type {String}
     * @description
     *   [en]Display a notification badge on top of the tab.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute active
     * @description
     *   [en]This attribute should be set to the tab that is active by default.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this._pageLoader = defaultPageLoader;
      this._page = null;

      if (this.hasAttribute('label') || this.hasAttribute('icon') || this.hasAttribute('badge')) {
        this._compile();
      } else {
        contentReady(this, function () {
          _this2._compile();
        });
      }

      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this.page || this.getAttribute('page');
    }
  }, {
    key: '_templateLoaded',
    value: function _templateLoaded() {
      if (this.children.length == 0) {
        return false;
      }

      var hasInput = this._input.getAttribute('type') === 'radio';
      var hasButton = this._button;

      return !!(hasInput && hasButton);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$15);

      if (!this._templateLoaded()) {
        var fragment = document.createDocumentFragment();
        var hasChildren = false;

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          fragment.appendChild(node);

          if (node.nodeType == Node.ELEMENT_NODE) {
            hasChildren = true;
          }
        }

        var template = templateSource$1.cloneNode(true);
        while (template.children[0]) {
          this.appendChild(template.children[0]);
        }

        if (hasChildren) {
          this._button.appendChild(fragment);
          this._hasDefaultTemplate = false;
        } else {
          this._hasDefaultTemplate = true;
          this._updateDefaultTemplate();
        }
      }

      ModifierUtil.initModifier(this, scheme$21);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this.querySelector('.tabbar__button'), this.hasAttribute('ripple'));
    }
  }, {
    key: '_updateDefaultTemplate',
    value: function _updateDefaultTemplate() {
      if (!this._hasDefaultTemplate) {
        return;
      }

      var button = this._button;
      var template = defaultInnerTemplateSource.cloneNode(true);
      if (button.children.length === 0) {
        while (template.children[0]) {
          button.appendChild(template.children[0]);
        }
      }

      if (!button.querySelector('.tabbar__icon')) {
        button.insertBefore(template.querySelector('.tabbar__icon'), button.firstChild);
      }

      if (!button.querySelector('.tabbar__label')) {
        button.appendChild(template.querySelector('.tabbar__label'));
      }

      if (!button.querySelector('.tabbar__badge')) {
        button.appendChild(template.querySelector('.tabbar__badge'));
      }

      var icon = this.getAttribute('icon');
      var label = this.getAttribute('label');
      var badge = this.getAttribute('badge');

      var iconElement = button.querySelector('.tabbar__icon').children[0];
      var labelElement = button.querySelector('.tabbar__label');
      var badgeElement = button.querySelector('.tabbar__badge');

      if (iconElement) {
        if (typeof icon === 'string') {
          var last = iconElement.getAttribute('icon');
          iconElement.setAttribute('icon', icon);
          // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
          iconElement.attributeChangedCallback('icon', last, icon);
        } else {
          iconElement.parentElement.remove();
        }
      }

      if (labelElement) {
        if (typeof label === 'string') {
          labelElement.textContent = label;
        } else {
          labelElement.remove();
        }
      }

      if (badgeElement) {
        if (typeof badge === 'string') {
          badgeElement.textContent = badge;
        } else {
          badgeElement.remove();
        }
      }
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else {
        var tabbar = this._findTabbarElement();
        if (tabbar) {
          tabbar.setActiveTab(this._findTabIndex());
        }
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      this._input.checked = true;
      this.classList.add('active');
      this.setAttribute('active', '');

      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {
        var icon = this.getAttribute('active-icon');
        var iconElement = this._button.querySelector('.tabbar__icon').children[0];
        iconElement.setAttribute('icon', icon);
      }

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'none';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
    }
  }, {
    key: 'setInactive',
    value: function setInactive() {
      this._input.checked = false;
      this.classList.remove('active');
      this.removeAttribute('active');

      if (this.hasAttribute('icon')) {
        var icon = this.getAttribute('icon');
        var iconElement = this._button.querySelector('.tabbar__icon').children[0];
        iconElement.setAttribute('icon', icon);
      }

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'none';
      });
    }

    /**
     * @param {Element} parent
     * @param {Function} callback
     */

  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, callback) {
      var _this3 = this;

      if (!this._loadedPage && !this._getPageTarget()) {
        var pages = this._findTabbarElement().pages;
        var index = this._findTabIndex();
        if (!pages[index]) {
          throw Error('Page was not provided to <ons-tab> index ' + index);
        }
        callback(pages[index]);
      } else if (this._loadingPage) {
        this._loadingPage.then(function (pageElement) {
          callback(pageElement);
        });
      } else if (!this._loadedPage) {
        var deferred = util.defer();
        this._loadingPage = deferred.promise;

        this._pageLoader.load({ page: this._getPageTarget(), parent: parent }, function (pageElement) {
          _this3._loadedPage = pageElement;
          deferred.resolve(pageElement);
          delete _this3._loadingPage;

          callback(pageElement);
        });
      } else {
        callback(this._loadedPage);
      }
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._ensureElementPosition();

        var tabbar = _this4._findTabbarElement();

        if (tabbar.hasAttribute('modifier')) {
          var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
          _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
        }

        var onReady = function onReady() {
          if (_this4._getPageTarget() && !_this4.hasLoaded) {
            _this4.hasLoaded = true;
            _this4._loadPageElement(tabbar._contentElement, function (pageElement) {
              pageElement.style.display = 'none';
              tabbar._contentElement.appendChild(pageElement);
            });
          }

          if (_this4.hasAttribute('active')) {
            tabbar.setActiveTab(_this4._findTabIndex());
          }
        };

        TabbarElement.rewritables.ready(tabbar, onReady);

        _this4.addEventListener('click', _this4._boundOnClick, false);
      });
    }
  }, {
    key: '_findTabbarElement',
    value: function _findTabbarElement() {
      if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode;
      }

      if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode.parentNode;
      }

      return null;
    }
  }, {
    key: '_findTabIndex',
    value: function _findTabIndex() {
      var elements = this.parentNode.children;
      for (var i = 0; i < elements.length; i++) {
        if (this === elements[i]) {
          return i;
        }
      }
    }
  }, {
    key: '_ensureElementPosition',
    value: function _ensureElementPosition() {
      if (!this._findTabbarElement()) {
        throw new Error('This ons-tab element is must be child of ons-tabbar element.');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$15)) {
            this.className = defaultClassName$15 + ' ' + current;
          }
          break;
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$21);
          });
          break;
        case 'ripple':
          this._templateLoaded() && contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateDefaultTemplate();
          });
          break;
        case 'page':
          if (typeof current === 'string') {
            this._page = current;
          }
          break;
      }
    }
  }, {
    key: 'page',
    set: function set(page) {
      this._page = page;
    },
    get: function get() {
      return this._page;
    }
  }, {
    key: 'pageLoader',
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    },
    get: function get() {
      return this._pageLoader;
    }
  }, {
    key: '_input',
    get: function get() {
      return this.children[0];
    }
  }, {
    key: '_button',
    get: function get() {
      return util.findChild(this, '.tabbar__button');
    }
  }, {
    key: 'pageElement',
    get: function get() {
      if (this._loadedPage) {
        return this._loadedPage;
      }

      var tabbar = this._findTabbarElement();
      var index = this._findTabIndex();

      return tabbar._contentElement.children[index];
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
    }
  }]);
  return TabElement;
}(BaseElement);

customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$16 = 'toolbar-button';

var scheme$23 = { '': 'toolbar-button--*' };

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarons-bottom-toolbar[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar
 *   [en]Adding a toolbar[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbar[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-button[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseElement) {
  inherits(ToolbarButtonElement, _BaseElement);

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);
    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
  }

  createClass(ToolbarButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      this._compile();
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$16);

      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$16)) {
            this.className = defaultClassName$16 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$23);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarButtonElement;
}(BaseElement);

customElements.define('ons-toolbar-button', ToolbarButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$17 = 'range';

var scheme$24 = {
  '': 'range--*',
  '.range__input': 'range--*__input'
};

var INPUT_ATTRIBUTES$2 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

/**
 * @attribute disabled
 * @description
 *   [en]Whether the element is disabled or not.[/en]
 *   [ja]`true`[/ja]
 */

var RangeElement = function (_BaseElement) {
  inherits(RangeElement, _BaseElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);
    return possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).apply(this, arguments));
  }

  createClass(RangeElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._updateBoundAttributes();
        _this2._onChange();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$17);

      autoStyle.prepare(this);

      if (!util.findChild(this, '.range__input')) {
        var input = document.createElement('input');
        input.setAttribute('type', 'range');
        input.classList.add('range__input');
        this.appendChild(input);
      }

      ModifierUtil.initModifier(this, scheme$24);

      this._updateDisabled();
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._input.style.backgroundSize = 100 * this._ratio + '% 2px';
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.stopPropagation();
      e.gesture.stopPropagation();
    }
  }, {
    key: '_updateDisabled',
    value: function _updateDisabled() {
      if (this.hasAttribute('disabled')) {
        ModifierUtil.addModifier(this, 'disabled');
      } else {
        ModifierUtil.removeModifier(this, 'disabled');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$24);
      } else if (name === 'class') {
        if (!this.classList.contains(defaultClassName$17)) {
          this.className = defaultClassName$17 + ' ' + current;
        }
      } else if (name === 'disabled') {
        this._updateDisabled();
      }

      if (INPUT_ATTRIBUTES$2.indexOf(name) >= 0) {
        contentReady(this, function () {
          _this3._updateBoundAttributes();

          if (name === 'min' || name === 'max') {
            _this3._onChange();
          }
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('dragstart', this._onDragstart);
      this.addEventListener('input', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('dragstart', this._onDragstart);
      this.removeEventListener('input', this._onChange);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this4 = this;

      INPUT_ATTRIBUTES$2.forEach(function (attr) {
        if (_this4.hasAttribute(attr)) {
          _this4._input.setAttribute(attr, _this4.getAttribute(attr));
        } else {
          _this4._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_ratio',
    get: function get() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input.range__input');
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]`true`[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.value = val;
        _this5._onChange();
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['class', 'modifier'].concat(INPUT_ATTRIBUTES$2);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['input', 'change'];
    }
  }]);
  return RangeElement;
}(BaseElement);

customElements.define('ons-range', RangeElement);

ons$1.TemplateElement = TemplateElement;
ons$1.IfElement = IfElement;
ons$1.AlertDialogElement = AlertDialogElement;
ons$1.BackButtonElement = BackButtonElement;
ons$1.BottomToolbarElement = BottomToolbarElement;
ons$1.ButtonElement = ButtonElement;
ons$1.CarouselItemElement = CarouselItemElement;
ons$1.CarouselElement = CarouselElement;
ons$1.ColElement = ColElement;
ons$1.DialogElement = DialogElement;
ons$1.FabElement = FabElement;
ons$1.GestureDetectorElement = GestureDetectorElement;
ons$1.IconElement = IconElement;
ons$1.LazyRepeatElement = LazyRepeatElement;
ons$1.ListHeaderElement = ListHeaderElement;
ons$1.ListItemElement = ListItemElement;
ons$1.ListElement = ListElement;
ons$1.InputElement = InputElement;
ons$1.ModalElement = ModalElement;
ons$1.NavigatorElement = NavigatorElement;
ons$1.PageElement = PageElement;
ons$1.PopoverElement = PopoverElement;
ons$1.ProgressBarElement = ProgressBarElement;
ons$1.ProgressCircularElement = ProgressCircularElement;
ons$1.PullHookElement = PullHookElement;
ons$1.RippleElement = RippleElement;
ons$1.RowElement = RowElement;
ons$1.SelectElement = SelectElement;
ons$1.SpeedDialItemElement = SpeedDialItemElement;
ons$1.SpeedDialElement = SpeedDialElement;
ons$1.SplitterContentElement = SplitterContentElement;
ons$1.SplitterMaskElement = SplitterMaskElement;
ons$1.SplitterSideElement = SplitterSideElement;
ons$1.SplitterElement = SplitterElement;
ons$1.SwitchElement = SwitchElement;
ons$1.TabElement = TabElement;
ons$1.TabbarElement = TabbarElement;
ons$1.ToolbarButtonElement = ToolbarButtonElement;
ons$1.ToolbarElement = ToolbarElement;
ons$1.RangeElement = RangeElement;

// fastclick
window.addEventListener('load', function () {
  ons$1.fastClick = FastClick.attach(document.body);
}, false);

// ons._defaultDeviceBackButtonHandler
window.addEventListener('DOMContentLoaded', function () {
  ons$1._deviceBackButtonDispatcher.enable();
  ons$1._defaultDeviceBackButtonHandler = ons$1._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
    navigator.app.exitApp();
  });
  document.body._gestureDetector = new ons$1.GestureDetector(document.body);
}, false);

// setup loading placeholder
ons$1.ready(function () {
  ons$1._setupLoadingPlaceHolders();
});

// viewport.js
new Viewport().setup();

return ons$1;

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUV2ZW50LmpzIiwiTXV0YXRpb25PYnNlcnZlckAwLjcuMjIvTXV0YXRpb25PYnNlcnZlci5qcyIsImNoaWxkTm9kZVJlbW92ZS5qcyIsImNsYXNzTGlzdC5qc0AxLjEuMjAxNTAzMTIvY2xhc3NMaXN0LmpzIiwiRmFzdENsaWNrQDEuMC42K21vZC9mYXN0Y2xpY2suanMiLCJtaWNyb2V2ZW50LmpzQDQ3Y2JjMTQrbW9kL21pY3JvZXZlbnQuanMiLCJwcm9taXNlLXBvbHlmaWxsQDYuMC4yK21vZC9wcm9taXNlLmpzIiwic2V0SW1tZWRpYXRlQDEuMC4yK21vZC9zZXRJbW1lZGlhdGUuanMiLCJ2aWV3cG9ydC5qcyIsIndpbnN0b3JlLWpzY29tcGF0QDM5OWZkOWYvd2luc3RvcmUtanNjb21wYXQuanMiLCJwb2x5ZmlsbC1zd2l0Y2hlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvY3VzdG9tLWVsZW1lbnRzLm1pbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsInBvbHlmaWxscy5qcyIsIm9ucy9wbGF0Zm9ybS5qcyIsIm9ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwib25zL2ludGVybmFsL2ludGVybmFsLmpzIiwib25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCJvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbC5qcyIsIm9ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdC5qcyIsIm9ucy9pbnRlcm5hbC9pbmRleC5qcyIsIm9ucy9hdXRvc3R5bGUuanMiLCJvbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwib25zL3V0aWwuanMiLCJvbnMvYW5pbWl0LmpzIiwib25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCJvbnMvY29udGVudC1yZWFkeS5qcyIsIm9ucy9ub3RpZmljYXRpb24uanMiLCJvbnMvb3JpZW50YXRpb24uanMiLCJvbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCJvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCJvbnMvZG9vcmxvY2suanMiLCJvbnMvcGFnZS1sb2FkZXIuanMiLCJvbnMvYmFzZS1hbmltYXRvci5qcyIsIm9ucy9vbnMuanMiLCJvbnMvYmFzZS1lbGVtZW50LmpzIiwiZWxlbWVudHMvb25zLXRlbXBsYXRlLmpzIiwiZWxlbWVudHMvb25zLWlmLmpzIiwiZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtYmFjay1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtYm90dG9tLXRvb2xiYXIuanMiLCJlbGVtZW50cy9vbnMtYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0uanMiLCJlbGVtZW50cy9vbnMtY2Fyb3VzZWwuanMiLCJlbGVtZW50cy9vbnMtY29sLmpzIiwiZWxlbWVudHMvb25zLWRpYWxvZy9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1kaWFsb2cvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtZmFiLmpzIiwiZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3IuanMiLCJlbGVtZW50cy9vbnMtaWNvbi5qcyIsImVsZW1lbnRzL29ucy1sYXp5LXJlcGVhdC5qcyIsImVsZW1lbnRzL29ucy1saXN0LWhlYWRlci5qcyIsImVsZW1lbnRzL29ucy1saXN0LWl0ZW0uanMiLCJlbGVtZW50cy9vbnMtbGlzdC5qcyIsImVsZW1lbnRzL29ucy1pbnB1dC5qcyIsImVsZW1lbnRzL29ucy1tb2RhbC9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1tb2RhbC9mYWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLXNsaWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3MtbGlmdC1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLXNsaWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1saWZ0LWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1mYWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9ub25lLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy10b29sYmFyLmpzIiwiZWxlbWVudHMvb25zLXBhZ2UuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1wb3BvdmVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXByb2dyZXNzLWJhci5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhci5qcyIsImVsZW1lbnRzL29ucy1wdWxsLWhvb2suanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2FuaW1hdG9yLWNzcy5qcyIsImVsZW1lbnRzL29ucy1yaXBwbGUvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtcm93LmpzIiwiZWxlbWVudHMvb25zLXNlbGVjdC5qcyIsImVsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCJsaWIvc3R5bGVyLmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUuanMiLCJlbGVtZW50cy9vbnMtc3dpdGNoLmpzIiwiZWxlbWVudHMvb25zLXRhYmJhci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdGFiLmpzIiwiZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLXJhbmdlLmpzIiwic2V0dXAuanMiXSwibmFtZXMiOlsid2luZG93IiwiY3VzdG9tRWxlbWVudHMiLCJmb3JjZVBvbHlmaWxsIiwiZyIsImFhIiwiU2V0Iiwic3BsaXQiLCJrIiwiYiIsImEiLCJoYXMiLCJ0ZXN0IiwibCIsImlzQ29ubmVjdGVkIiwiX19DRV9pc0ltcG9ydERvY3VtZW50IiwiRG9jdW1lbnQiLCJwYXJlbnROb2RlIiwiU2hhZG93Um9vdCIsImhvc3QiLCJtIiwibmV4dFNpYmxpbmciLCJuIiwiZSIsImMiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJkIiwiaCIsImxvY2FsTmFtZSIsImdldEF0dHJpYnV0ZSIsImltcG9ydCIsImFkZCIsImZpcnN0Q2hpbGQiLCJfX0NFX3NoYWRvd1Jvb3QiLCJxIiwiciIsIk1hcCIsImYiLCJiYSIsInNldCIsImNvbnN0cnVjdG9yIiwidCIsInB1c2giLCJ2IiwidyIsIl9fQ0VfcGF0Y2hlZCIsImxlbmd0aCIsIngiLCJfX0NFX3N0YXRlIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJ5IiwieiIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiQSIsInJlYWR5U3RhdGUiLCJfX0NFX2hhc1JlZ2lzdHJ5IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCIsImRlbGV0ZSIsImdldCIsImNvbnN0cnVjdGlvblN0YWNrIiwiRXJyb3IiLCJwb3AiLCJfX0NFX2RlZmluaXRpb24iLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJwcm90b3R5cGUiLCJjYWxsIiwiaW5kZXhPZiIsIkIiLCJNdXRhdGlvbk9ic2VydmVyIiwiYmluZCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiQyIsImRpc2Nvbm5lY3QiLCJhZGRlZE5vZGVzIiwiY2EiLCJQcm9taXNlIiwiRCIsIkUiLCJqIiwiZG9jdW1lbnQiLCJGdW5jdGlvbiIsIlR5cGVFcnJvciIsIlN5bnRheEVycm9yIiwidSIsInAiLCJQIiwiT2JqZWN0IiwidmEiLCJhZG9wdGVkQ2FsbGJhY2siLCJzaGlmdCIsIm8iLCJyZWplY3QiLCJDdXN0b21FbGVtZW50UmVnaXN0cnkiLCJkZWZpbmUiLCJ3aGVuRGVmaW5lZCIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJGIiwiY3JlYXRlRWxlbWVudCIsImRhIiwiY3JlYXRlRWxlbWVudE5TIiwiZWEiLCJpbXBvcnROb2RlIiwiZmEiLCJwcmVwZW5kIiwiZ2EiLCJhcHBlbmQiLCJHIiwiY2xvbmVOb2RlIiwiSCIsImFwcGVuZENoaWxkIiwiSSIsImluc2VydEJlZm9yZSIsIkoiLCJyZW1vdmVDaGlsZCIsIksiLCJyZXBsYWNlQ2hpbGQiLCJMIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTSIsIkVsZW1lbnQiLCJhdHRhY2hTaGFkb3ciLCJOIiwiTyIsIlEiLCJzZXRBdHRyaWJ1dGUiLCJSIiwicmVtb3ZlQXR0cmlidXRlIiwiUyIsImdldEF0dHJpYnV0ZU5TIiwiVCIsInNldEF0dHJpYnV0ZU5TIiwiVSIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiViIsImluc2VydEFkamFjZW50RWxlbWVudCIsImhhIiwiaWEiLCJqYSIsImJlZm9yZSIsImthIiwiYWZ0ZXIiLCJsYSIsInJlcGxhY2VXaXRoIiwibWEiLCJyZW1vdmUiLCJuYSIsIkhUTUxFbGVtZW50IiwiVyIsIlgiLCJvYSIsIlkiLCJzZXRQcm90b3R5cGVPZiIsInBhIiwiYXJndW1lbnRzIiwiZmlsdGVyIiwiaSIsImFwcGx5IiwicWEiLCJyYSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIlRFWFRfTk9ERSIsImNoaWxkTm9kZXMiLCJBcnJheSIsIkRvY3VtZW50RnJhZ21lbnQiLCJzbGljZSIsIm93bmVyRG9jdW1lbnQiLCJ0ZXh0Q29udGVudCIsImpvaW4iLCJjcmVhdGVUZXh0Tm9kZSIsInNhIiwidGEiLCJjb25zb2xlIiwid2FybiIsImlubmVySFRNTCIsImNvbnRlbnQiLCJaIiwidWEiLCJ2YWx1ZSIsInNlbGYiLCJnbG9iYWwiLCJtb2R1bGUiLCJNYXRoIiwiX19nIiwiY29yZSIsInZlcnNpb24iLCJfX2UiLCJpdCIsImlzT2JqZWN0IiwiZXhlYyIsInJlcXVpcmUkJDAiLCJpcyIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiZm4iLCJ2YWwiLCJ0b1N0cmluZyIsInZhbHVlT2YiLCJkUCIsIkF0dHJpYnV0ZXMiLCJ0b1ByaW1pdGl2ZSIsIklFOF9ET01fREVGSU5FIiwiYml0bWFwIiwib2JqZWN0Iiwia2V5IiwiY3JlYXRlRGVzYyIsImhhc093blByb3BlcnR5IiwiaWQiLCJweCIsInJhbmRvbSIsImNvbmNhdCIsInVuZGVmaW5lZCIsIlNSQyIsIlRPX1NUUklORyIsIiR0b1N0cmluZyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJzYWZlIiwiaXNGdW5jdGlvbiIsImhpZGUiLCJTdHJpbmciLCJ0aGF0IiwiUFJPVE9UWVBFIiwiJGV4cG9ydCIsInR5cGUiLCJuYW1lIiwic291cmNlIiwiSVNfRk9SQ0VEIiwiSVNfR0xPQkFMIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJJU19CSU5EIiwidGFyZ2V0IiwiZXhwb3J0cyIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiY3R4IiwicmVkZWZpbmUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNvZiIsIklPYmplY3QiLCJkZWZpbmVkIiwiZ09QRCIsInRvSU9iamVjdCIsInBJRSIsImNoZWNrIiwicHJvdG8iLCJidWdneSIsIl9fcHJvdG9fXyIsIlBsYXRmb3JtIiwiX3JlbmRlclBsYXRmb3JtIiwicGxhdGZvcm0iLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJjb3Jkb3ZhIiwicGhvbmVnYXAiLCJQaG9uZUdhcCIsImRldmljZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm9wZXJhIiwiSW5zdGFsbFRyaWdnZXIiLCJzYWZhcmkiLCJwdXNoTm90aWZpY2F0aW9uIiwiY2hyb21lIiwiZG9jdW1lbnRNb2RlIiwicGFyc2VJbnQiLCJ2ZXIiLCJtYXRjaCIsInJlcGxhY2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzV1AiLCJpc0lQaG9uZSIsImlzSVBhZCIsImlzSVBvZCIsInBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwib3ZlcndyaXRlIiwiX3ZhcmlhYmxlcyIsInBhcnQiLCJpbkludGVycG9sYXRpb24iLCJjdXJyZW50SW5kZXgiLCJ0b2tlbnMiLCJjaGFyQXQiLCJ0b2tlbiIsInN1YnN0cmluZyIsInJlIiwidmFyaWFibGUiLCJnZXRWYXJpYWJsZSIsInJ2IiwibWFwIiwiX3JlcGxhY2VUb2tlbiIsImV4cHJlc3Npb24iLCJfcGFyc2VQYXJ0IiwiX3JlcGxhY2VUb2tlbnMiLCJfcGFyc2VFeHByZXNzaW9uIiwiZGVmaW5lVmFyaWFibGUiLCJnZXRNb2JpbGVPUyIsImdldElPU0RldmljZSIsImlzV2ViVmlldyIsImludGVybmFsIiwiY29uZmlnIiwibnVsbEVsZW1lbnQiLCJpc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCIsImF1dG9TdGF0dXNCYXJGaWxsIiwibm9ybWFsaXplUGFnZUhUTUwiLCJodG1sIiwid2FpdERPTUNvbnRlbnRMb2FkZWQiLCJjYWxsYmFjayIsIm9uUmVhZHkiLCJzaG91bGRGaWxsU3RhdHVzQmFyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzSU9TN2Fib3ZlIiwidGVtcGxhdGVTdG9yZSIsIl9zdG9yYWdlIiwidGVtcGxhdGUiLCJub2RlTmFtZSIsInRlbXBsYXRlSWQiLCJyZWdpc3RlciIsInF1ZXJ5IiwidGVtcGxhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImdldFRlbXBsYXRlSFRNTEFzeW5jIiwicGFnZSIsInJlc29sdmUiLCJjYWNoZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzIiwib25lcnJvciIsInNlbmQiLCJnZXRQYWdlSFRNTEFzeW5jIiwicGFnZXMiLCJldmFsdWF0ZSIsImdldFBhZ2UiLCJ0aGVuIiwiZXJyb3IiLCJBbmltYXRvckZhY3RvcnkiLCJvcHRzIiwiX2FuaW1hdG9ycyIsImFuaW1hdG9ycyIsIl9iYXNlQ2xhc3MiLCJiYXNlQ2xhc3MiLCJfYmFzZUNsYXNzTmFtZSIsImJhc2VDbGFzc05hbWUiLCJfYW5pbWF0aW9uIiwiZGVmYXVsdEFuaW1hdGlvbiIsIl9hbmltYXRpb25PcHRpb25zIiwiZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnMiLCJvcHRpb25zIiwiZGVmYXVsdEFuaW1hdG9yIiwiYW5pbWF0b3IiLCJhbmltYXRpb24iLCJBbmltYXRvciIsImFuaW1hdGlvbk9wdHMiLCJ1dGlsIiwiZXh0ZW5kIiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbnNEaXNhYmxlZCIsImR1cmF0aW9uIiwiZGVsYXkiLCJqc29uU3RyaW5nIiwicmVzdWx0IiwiYW5pbWF0aW9uT3B0aW9uc1BhcnNlIiwiTW9kaWZpZXJVdGlsIiwibGFzdCIsImN1cnJlbnQiLCJtYWtlRGljdCIsInJlbW92ZWQiLCJrZXlzIiwicmVkdWNlIiwiYWRkZWQiLCJtb2RpZmllciIsImRpY3QiLCJmb3JFYWNoIiwiZGlmZiIsImNsYXNzTGlzdCIsImtsYXNzIiwiZWxlbWVudCIsInNjaGVtZSIsInNlbGVjdG9yIiwidGFyZ2V0RWxlbWVudHMiLCJhcHBseURpZmZUb0NsYXNzTGlzdCIsImFwcGx5RGlmZlRvRWxlbWVudCIsIm1vZGlmaWVyVG9rZW4iLCJoYXNBdHRyaWJ1dGUiLCJpbmRleCIsInNwbGljZSIsIkxhenlSZXBlYXREZWxlZ2F0ZSIsInVzZXJEZWxlZ2F0ZSIsInRlbXBsYXRlRWxlbWVudCIsIl91c2VyRGVsZWdhdGUiLCJfdGVtcGxhdGVFbGVtZW50IiwiX3JlbmRlciIsImRvbmUiLCJsb2FkSXRlbUVsZW1lbnQiLCJjcmVhdGVJdGVtQ29udGVudCIsImNvdW50IiwiY291bnRJdGVtcyIsIml0ZW0iLCJ1cGRhdGVJdGVtQ29udGVudCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJoZWlnaHQiLCJkZXN0cm95SXRlbSIsImRlc3Ryb3kiLCJpdGVtSGVpZ2h0IiwiTGF6eVJlcGVhdFByb3ZpZGVyIiwid3JhcHBlckVsZW1lbnQiLCJkZWxlZ2F0ZSIsIl93cmFwcGVyRWxlbWVudCIsIl9kZWxlZ2F0ZSIsIl9pbnNlcnRJbmRleCIsImNoaWxkcmVuIiwidGFnTmFtZSIsIl9wYWdlQ29udGVudCIsIl9maW5kUGFnZUNvbnRlbnRFbGVtZW50IiwibGFzdFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsInBhZGRpbmciLCJfdG9wUG9zaXRpb25zIiwiX3JlbmRlcmVkSXRlbXMiLCJfdW5rbm93bkl0ZW1IZWlnaHQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJfb25DaGFuZ2UiLCJwYWdlQ29udGVudCIsImZpbmRQYXJlbnQiLCJmaW5kQ2hpbGQiLCJfaXRlbUhlaWdodCIsIm9mZnNldEhlaWdodCIsImxhc3RWaXNpYmlsaXR5Iiwic3R5bGUiLCJ2aXNpYmlsaXR5Iiwic3RhdGljSXRlbUhlaWdodCIsIl9nZXRJdGVtSGVpZ2h0IiwibWF4IiwibWluIiwibGFzdEl0ZW1JbmRleCIsIl9sYXN0SXRlbVJlbmRlcmVkIiwiX2NvdW50SXRlbXMiLCJmaXJzdEl0ZW1JbmRleCIsIl9maXJzdEl0ZW1SZW5kZXJlZCIsIl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCIsIl9yZW1vdmVBbGxFbGVtZW50cyIsImZvcmNlU2Nyb2xsRG93biIsImZvcmNlRmlyc3RJbmRleCIsImZvcmNlTGFzdEluZGV4IiwiX2NoZWNrSXRlbUhlaWdodCIsImlzU2Nyb2xsVXAiLCJrZWVwIiwib2Zmc2V0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwibGltaXQiLCJpbm5lckhlaWdodCIsIml0ZW1zIiwic3RhcnQiLCJfY2FsY3VsYXRlU3RhcnRJbmRleCIsImhhc1JlbmRlckZ1bmN0aW9uIiwiX3JlbmRlckVsZW1lbnQiLCJsYXN0SW5kZXgiLCJfcmVtb3ZlRWxlbWVudCIsInVwZGF0ZUl0ZW0iLCJwYXJlbnRFbGVtZW50IiwiZW5kIiwiX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zIiwibWlkZGxlIiwiZmxvb3IiLCJpc05hTiIsImZ1bmMiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZW91dCIsImNhbGxOb3ciLCJzZXRUaW1lb3V0IiwiX2RlYm91bmNlIiwiYmluZExpc3RlbmVycyIsIl9ib3VuZE9uQ2hhbmdlIiwiX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQiLCJfcGFyZW50RWxlbWVudCIsIl9yZW1vdmVFdmVudExpc3RlbmVycyIsInBhZGRpbmdUb3AiLCJuZXdWYWx1ZSIsImF1dG9TdHlsZUVuYWJsZWQiLCJtb2RpZmllcnNNYXAiLCJwbGF0Zm9ybXMiLCJhbmRyb2lkIiwib2xkTW9kaWZpZXIiLCJuZXdNb2RpZmllciIsInVuc2hpZnQiLCJxdWVyeVNlbGVjdG9yIiwiaW9zIiwicmVtb3ZlTW9kaWZpZXIiLCJhZGRNb2RpZmllciIsInVubG9ja2VkIiwicHJlcGFyZUF1dG9TdHlsZSIsImZvcmNlIiwibW9iaWxlT1MiLCJvbnNQbGF0Zm9ybSIsIm1hcE1vZGlmaWVyIiwidW53cmFwIiwic3RyaW5nIiwiaXNPYmplY3RTdHJpbmciLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpc0FycmF5U3RyaW5nIiwiaXNRdW90ZWRTdHJpbmciLCJvcmlnaW5hbFN0cmluZyIsInByb2Nlc3NUb2tlbiIsInBhcnNlT2JqZWN0IiwicGFyc2VBcnJheSIsIm5leHRUb2tlbiIsInRyaW1MZWZ0IiwiY2hhckNvZGVBdCIsIm5lc3RlZE9iamVjdCIsImlzVmFsaWRLZXkiLCJyZWFkaW5nS2V5IiwicHJldmlvdXNUb2tlbiIsImFycmF5IiwicGFyc2UiLCJwcmVwYXJlUXVlcnkiLCJzIiwibWF0Y2hlcyIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwibm9kZSIsInBhcmVudCIsImlzQXR0YWNoZWQiLCJkb2N1bWVudEVsZW1lbnQiLCJoYXNBbnlDb21wb25lbnRBc1BhcmVudCIsInByb3BhZ2F0ZUFjdGlvbiIsImFjdGlvbiIsImNoaWxkIiwiY3JlYXRlIiwiY2xhc3NOYW1lIiwid3JhcHBlciIsImNyZWF0ZUZyYWdtZW50IiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZHN0IiwiYXJncyIsImFycmF5RnJvbSIsImFycmF5TGlrZSIsInBhcnNlSlNPTk9iamVjdFNhZmVseSIsImZhaWxTYWZlIiwiSlNPTiIsImZpbmRGcm9tUGF0aCIsInBhdGgiLCJlbCIsImdldFRvcFBhZ2UiLCJjb250YWluZXIiLCJ0b3BQYWdlIiwiZmluZFRvb2xiYXJQYWdlIiwiX2NvbnRlbnRFbGVtZW50IiwibmV4dFBhZ2UiLCJ0cmlnZ2VyRWxlbWVudEV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJoYXNNb2RpZmllciIsIm1vZGlmaWVyTmFtZSIsInNvbWUiLCJhdXRvU3R5bGUiLCJmb3JjZUF1dG9TdHlsZSIsIm1vZGlmaWVyQXR0cmlidXRlIiwibW9kaWZpZXJzIiwibmV3TW9kaWZpZXJzIiwidXBkYXRlUGFyZW50UG9zaXRpb24iLCJfcGFyZW50VXBkYXRlZCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicG9zaXRpb24iLCJ0b2dnbGVBdHRyaWJ1dGUiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwidG9VcHBlckNhc2UiLCJlYWNoIiwib2JqIiwidXBkYXRlUmlwcGxlIiwiaGFzUmlwcGxlIiwicmlwcGxlRWxlbWVudCIsImlzSW50ZWdlciIsImlzRmluaXRlIiwiZGVmZXIiLCJkZWZlcnJlZCIsInByb21pc2UiLCJ3YXJuaW5nc0Rpc2FibGVkIiwiVElNRU9VVF9SQVRJTyIsImNhcGl0YWxpemUiLCJzdHIiLCJidWlsZFRyYW5zaXRpb25WYWx1ZSIsInBhcmFtcyIsInByb3BlcnR5IiwidGltaW5nIiwicHJvcHMiLCJwcm9wIiwib25jZU9uVHJhbnNpdGlvbkVuZCIsInN0b3BQcm9wYWdhdGlvbiIsInJlbW92ZUxpc3RlbmVycyIsIl90cmFuc2l0aW9uRW5kRXZlbnRzIiwidmVuZG9yUHJlZml4IiwiX2Nzc1Byb3BlcnR5RGljdCIsInN0eWxlcyIsInVwcGVyIiwic3Vic3RyIiwiaGFzQ3NzUHJvcGVydHkiLCJwcmUiLCJPTGluayIsImZvcmNlTGF5b3V0QXRPbmNlIiwiZWxlbWVudHMiLCJiYXRjaEltbWVkaWF0ZSIsImNhbGxiYWNrcyIsImNvbmNyZWF0ZUNhbGxiYWNrcyIsImJhdGNoQW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0cmFuc2l0aW9uUHJvcGVydHlOYW1lIiwiQW5pbWl0IiwidHJhbnNpdGlvblF1ZXVlIiwibGFzdFN0eWxlQXR0cmlidXRlRGljdCIsInN0YXJ0QW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInF1ZXVlIiwiY3NzIiwiVHJhbnNpdGlvbiIsImJ1aWxkIiwic2Vjb25kcyIsInRyYW5zaXRpb25OYW1lIiwidHJhbnNpdGlvblZhbHVlIiwidGltZW91dElkIiwiY2xlYXJUcmFuc2l0aW9uIiwibGVuIiwicmVzZXQiLCJfZGVxdWV1ZVRyYW5zaXRpb24iLCJfY3VycmVudFRyYW5zaXRpb24iLCJjYWxsZWQiLCJydW5BbGwiLCJwbGF5IiwiY3JlYXRlQWN0dWFsQ3NzUHJvcHMiLCJwcmVmaXhlZCIsIkV2ZW50IiwiVXRpbHMiLCJEZXRlY3Rpb24iLCJQb2ludGVyRXZlbnQiLCJHZXN0dXJlRGV0ZWN0b3IiLCJJbnN0YW5jZSIsImRlZmF1bHRzIiwiRE9DVU1FTlQiLCJIQVNfUE9JTlRFUkVWRU5UUyIsInBvaW50ZXJFbmFibGVkIiwibXNQb2ludGVyRW5hYmxlZCIsIkhBU19UT1VDSEVWRU5UUyIsIklTX01PQklMRSIsIk5PX01PVVNFRVZFTlRTIiwiQ0FMQ1VMQVRFX0lOVEVSVkFMIiwiRVZFTlRfVFlQRVMiLCJESVJFQ1RJT05fRE9XTiIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1VQIiwiRElSRUNUSU9OX1JJR0hUIiwiUE9JTlRFUl9NT1VTRSIsIlBPSU5URVJfVE9VQ0giLCJQT0lOVEVSX1BFTiIsIkVWRU5UX1NUQVJUIiwiRVZFTlRfTU9WRSIsIkVWRU5UX0VORCIsIkVWRU5UX1JFTEVBU0UiLCJFVkVOVF9UT1VDSCIsIlJFQURZIiwicGx1Z2lucyIsImdlc3R1cmVzIiwic2V0dXAiLCJkZXRlcm1pbmVFdmVudFR5cGVzIiwiZ2VzdHVyZSIsIm9uVG91Y2giLCJkZXRlY3QiLCJ1dGlscyIsImRlc3QiLCJzcmMiLCJtZXJnZSIsIm9uIiwiaGFuZGxlciIsIm9mZiIsIml0ZXJhdG9yIiwiY29udGV4dCIsImluU3RyIiwiZmluZCIsImluQXJyYXkiLCJ0b0FycmF5IiwiaGFzUGFyZW50IiwiZ2V0Q2VudGVyIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsInRvdWNoIiwiZ2V0VmVsb2NpdHkiLCJkZWx0YVRpbWUiLCJkZWx0YVgiLCJkZWx0YVkiLCJhYnMiLCJnZXRBbmdsZSIsInRvdWNoMSIsInRvdWNoMiIsImF0YW4yIiwiUEkiLCJnZXREaXJlY3Rpb24iLCJnZXREaXN0YW5jZSIsInNxcnQiLCJnZXRTY2FsZSIsImdldFJvdGF0aW9uIiwiaXNWZXJ0aWNhbCIsImRpcmVjdGlvbiIsInNldFByZWZpeGVkQ3NzIiwidG9nZ2xlIiwicHJlZml4ZXMiLCJ0b0NhbWVsQ2FzZSIsInRvZ2dsZUJlaGF2aW9yIiwiZmFsc2VGbiIsInVzZXJTZWxlY3QiLCJvbnNlbGVjdHN0YXJ0IiwidXNlckRyYWciLCJvbmRyYWdzdGFydCIsImhvb2siLCJ0eXBlcyIsImV2ZW50VHlwZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXYiLCJzcmNUeXBlIiwiaXNQb2ludGVyIiwiaXNNb3VzZSIsInRyaWdnZXJUeXBlIiwicHJldmVudE1vdXNlRXZlbnRzIiwiYnV0dG9uIiwic2hvdWxkRGV0ZWN0IiwiYnV0dG9ucyIsIm1hdGNoVHlwZSIsInVwZGF0ZVBvaW50ZXIiLCJkb0RldGVjdCIsInRvdWNoTGlzdCIsImdldFRvdWNoTGlzdCIsInRvdWNoTGlzdExlbmd0aCIsInRyaWdnZXJDaGFuZ2UiLCJ0cmlnZ2VyIiwiY2hhbmdlZExlbmd0aCIsImNoYW5nZWRUb3VjaGVzIiwic3RhcnRlZCIsImV2RGF0YSIsImNvbGxlY3RFdmVudERhdGEiLCJpZGVudGlmaWVycyIsImlkZW50aWZpZXIiLCJwb2ludGVyVHlwZSIsIkRhdGUiLCJub3ciLCJzcmNFdmVudCIsInByZXZlbnRNYW5pcHVsYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BEZXRlY3QiLCJ0b3VjaGxpc3QiLCJwb2ludGVycyIsInBvaW50ZXIiLCJwb2ludGVyRXZlbnQiLCJwb2ludGVySWQiLCJwdCIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJNU1BPSU5URVJfVFlQRV9QRU4iLCJyZXNldExpc3QiLCJkZXRlY3Rpb24iLCJzdGFydERldGVjdCIsImluc3QiLCJldmVudERhdGEiLCJzdG9wcGVkIiwiZXh0ZW5kRXZlbnREYXRhIiwiaW5zdE9wdGlvbnMiLCJ0cmlnZ2VyR2VzdHVyZSIsImVuYWJsZWQiLCJsYXN0RXZlbnQiLCJwcmV2aW91cyIsImdldENhbGN1bGF0ZWREYXRhIiwiY2VudGVyIiwiY3VyIiwicmVjYWxjIiwiY2FsY0V2IiwibGFzdENhbGNFdmVudCIsImNhbGNEYXRhIiwibGFzdENhbGNEYXRhIiwidGltZVN0YW1wIiwiZnV0dXJlQ2FsY0V2ZW50IiwidmVsb2NpdHkiLCJhbmdsZSIsInZlbG9jaXR5WCIsInZlbG9jaXR5WSIsImludGVyaW1BbmdsZSIsImludGVyaW1EaXJlY3Rpb24iLCJzdGFydEV2Iiwic3RhcnRFdmVudCIsImxhc3RFdiIsInNvcnQiLCJiZWhhdmlvciIsImV2ZW50U3RhcnRIYW5kbGVyIiwiZXZlbnRIYW5kbGVycyIsIm9uRXZlbnQiLCJvZmZFdmVudCIsInRyaWdnZXJFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZW5hYmxlIiwic3RhdGUiLCJkaXNwb3NlIiwiZWgiLCJ0cmlnZ2VyZWQiLCJkcmFnR2VzdHVyZSIsImRyYWdNYXhUb3VjaGVzIiwiZGlzdGFuY2UiLCJkcmFnTWluRGlzdGFuY2UiLCJzdGFydENlbnRlciIsImRyYWdEaXN0YW5jZUNvcnJlY3Rpb24iLCJmYWN0b3IiLCJkcmFnTG9ja1RvQXhpcyIsImRyYWdMb2NrTWluRGlzdGFuY2UiLCJsYXN0RGlyZWN0aW9uIiwiZHJhZ0Jsb2NrVmVydGljYWwiLCJkcmFnQmxvY2tIb3Jpem9udGFsIiwiRHJhZyIsIkdlc3R1cmUiLCJyZWxlYXNlR2VzdHVyZSIsInRpbWVyIiwiaG9sZEdlc3R1cmUiLCJob2xkVGltZW91dCIsImhvbGRUaHJlc2hvbGQiLCJIb2xkIiwiUmVsZWFzZSIsIkluZmluaXR5IiwiU3dpcGUiLCJzd2lwZUdlc3R1cmUiLCJzd2lwZU1pblRvdWNoZXMiLCJzd2lwZU1heFRvdWNoZXMiLCJzd2lwZVZlbG9jaXR5WCIsInN3aXBlVmVsb2NpdHlZIiwiaGFzTW92ZWQiLCJ0YXBHZXN0dXJlIiwicHJldiIsInNpbmNlUHJldiIsImRpZERvdWJsZVRhcCIsInRhcE1heERpc3RhbmNlIiwidGFwTWF4VGltZSIsImRvdWJsZVRhcEludGVydmFsIiwiZG91YmxlVGFwRGlzdGFuY2UiLCJ0YXBBbHdheXMiLCJUYXAiLCJUb3VjaCIsInRvdWNoR2VzdHVyZSIsInByZXZlbnRNb3VzZSIsInRyYW5zZm9ybUdlc3R1cmUiLCJzY2FsZVRocmVzaG9sZCIsInNjYWxlIiwicm90YXRpb25UaHJlc2hvbGQiLCJyb3RhdGlvbiIsInRyYW5zZm9ybU1pblNjYWxlIiwidHJhbnNmb3JtTWluUm90YXRpb24iLCJUcmFuc2Zvcm0iLCJyZWFkeU1hcCIsIldlYWtNYXAiLCJxdWV1ZU1hcCIsImlzQ29udGVudFJlYWR5Iiwic2V0Q29udGVudFJlYWR5IiwiYWRkQ2FsbGJhY2siLCJjb25zdW1lUXVldWUiLCJjb250ZW50UmVhZHkiLCJvYnNlcnZlciIsImNoYXJhY3RlckRhdGEiLCJub3RpZmljYXRpb24iLCJfY3JlYXRlQWxlcnREaWFsb2ciLCJpbnB1dFN0cmluZyIsImlzUHJvbXB0IiwiaW5wdXRUeXBlIiwicGxhY2Vob2xkZXIiLCJkZWZhdWx0VmFsdWUiLCJidXR0b25MYWJlbHMiLCJsYWJlbCIsInByaW1hcnlCdXR0b25JbmRleCIsIl9kZXN0cm95RGlhbG9nIiwiZGlhbG9nIiwib25EaWFsb2dDYW5jZWwiLCJ0aXRsZSIsIm1lc3NhZ2UiLCJtZXNzYWdlSFRNTCIsInN1Ym1pdE9uRW50ZXIiLCJpbnB1dCIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwicmVzb2x2ZVZhbHVlIiwiZm9vdGVyIiwiYnV0dG9uRWxlbWVudCIsIm9uY2xpY2siLCJjYW5jZWxhYmxlIiwiYm9keSIsImNvbXBpbGUiLCJzaG93IiwiYXV0b2ZvY3VzIiwiZm9jdXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwiYnV0dG9uTGFiZWwiLCJpc0FycmF5IiwicGFyYW0iLCJhbGVydCIsImNvbmZpcm0iLCJwcm9tcHQiLCJfaXNQb3J0cmFpdCIsImlzUG9ydHJhaXQiLCJfb25ET01Db250ZW50TG9hZGVkIiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfb25SZXNpemUiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJtaXhpbiIsIl9pbml0Iiwic29mdHdhcmVLZXlib2FyZCIsIk1pY3JvRXZlbnQiLCJfdmlzaWJsZSIsIm9uU2hvdyIsIm9uSGlkZSIsImJpbmRFdmVudHMiLCJLZXlib2FyZCIsIm9uc2hvdyIsIm9uaGlkZSIsInZpc2libGUiLCJpc1Zpc2libGUiLCJub1BsdWdpbkVycm9yIiwiX2RvbUNvbnRlbnRMb2FkZWQiLCJfcmVhZHkiLCJIYW5kbGVyUmVwb3NpdG9yeSIsImRhdGFzZXQiLCJkZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkIiwiX2dlbklkIiwiX3N0b3JlIiwiRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJfaXNFbmFibGVkIiwiX2JvdW5kQ2FsbGJhY2siLCJfY2FsbGJhY2siLCJhZGRCYWNrQnV0dG9uTGlzdGVuZXIiLCJyZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIiLCJfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQiLCJfZWxlbWVudCIsInRyZWUiLCJfY2FwdHVyZVRyZWUiLCJfZmluZEhhbmRsZXJMZWFmRWxlbWVudCIsImNyZWF0ZVRyZWUiLCJhcnJheU9mIiwiY2hpbGRFbGVtZW50IiwiZGlzcGxheSIsInN1YlRyZWUiLCJjaGlsZE5vZGUiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0WiIsInpJbmRleCIsInJpZ2h0WiIsImdlbmVyYXRlSWQiLCJEb29yTG9jayIsIl9sb2NrTGlzdCIsIl93YWl0TGlzdCIsIl9sb2ciLCJsb2ciLCJ1bmxvY2siLCJfdW5sb2NrIiwiX3RyeVRvRnJlZVdhaXRMaXN0IiwiaXNMb2NrZWQiLCJsb2FkUGFnZSIsInBhZ2VFbGVtZW50IiwidW5sb2FkUGFnZSIsIl9kZXN0cm95IiwiUGFnZUxvYWRlciIsImxvYWRlciIsInVubG9hZGVyIiwiX2xvYWRlciIsIl91bmxvYWRlciIsImRlZmF1bHRQYWdlTG9hZGVyIiwiaW5zdGFudFBhZ2VMb2FkZXIiLCJCYXNlQW5pbWF0b3IiLCJwcm9wZXJ0aWVzIiwiZXh0ZW5kZWRBbmltYXRvciIsIm5ld0FuaW1hdG9yIiwib25zIiwiX3V0aWwiLCJhbmltaXQiLCJfZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsIl9pbnRlcm5hbCIsIlBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwiX2FuaW1hdGlvbk9wdGlvbnNQYXJzZXIiLCJhbmltYXRpb25PcHRpb25zUGFyc2VyIiwiX2F1dG9TdHlsZSIsIl9Eb29yTG9jayIsIl9jb250ZW50UmVhZHkiLCJfQmFzZUFuaW1hdG9yIiwiX3JlYWR5TG9jayIsInNlbGVjdCIsImxvY2F0aW9uIiwic2VhcmNoIiwid2FpdERldmljZVJlYWR5IiwiaXNSZWFkeSIsInJlYWR5Iiwid2FpdFVubG9jayIsInNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIiLCJsaXN0ZW5lciIsIl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJzZXRMaXN0ZW5lciIsImRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciIsImRpc2FibGUiLCJlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciIsImVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsIiwiZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsIiwiZGlzYWJsZUFuaW1hdGlvbnMiLCJlbmFibGVBbmltYXRpb25zIiwiX2Rpc2FibGVXYXJuaW5ncyIsIl9lbmFibGVXYXJuaW5ncyIsImRpc2FibGVBdXRvU3R5bGluZyIsImVuYWJsZUF1dG9TdHlsaW5nIiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl9wbGF0Zm9ybVVwZGF0ZSIsInByZXBhcmUiLCJfdXBkYXRlUG9zaXRpb24iLCJfY3JlYXRlUG9wb3Zlck9yaWdpbmFsIiwiZGl2IiwicG9wb3ZlciIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiX2NyZWF0ZURpYWxvZ09yaWdpbmFsIiwiY3JlYXRlRGlhbG9nIiwiX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwiLCJhbGVydERpYWxvZyIsImNyZWF0ZUFsZXJ0RGlhbG9nIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbCIsIl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwicmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciIsIl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMiLCJjb250ZW50RWxlbWVudCIsImNhdGNoIiwidW5sb2NrRGV2aWNlUmVhZHkiLCJsb2NrIiwiX3N1cGVyU2VjcmV0T25zIiwiZ2V0RWxlbWVudENsYXNzIiwiQmFzZUVsZW1lbnQiLCJpbml0IiwiVGVtcGxhdGVFbGVtZW50Iiwib3V0ZXJIVE1MIiwiYnViYmxlcyIsIklmRWxlbWVudCIsIl9pc0FsbG93ZWRQbGF0Zm9ybSIsImNvbmRpdGlvbmFsT3JpZW50YXRpb24iLCJjdXJyZW50T3JpZW50YXRpb24iLCJBbGVydERpYWxvZ0FuaW1hdG9yIiwiQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IiLCJfbWFzayIsIl9kaWFsb2ciLCJzYXZlU3R5bGUiLCJyZXN0b3JlU3R5bGUiLCJJT1NBbGVydERpYWxvZ0FuaW1hdG9yIiwiX2FuaW1hdG9yRGljdCIsIkFsZXJ0RGlhbG9nRWxlbWVudCIsIl9jb21waWxlIiwiX2Rvb3JMb2NrIiwiX2JvdW5kQ2FuY2VsIiwiX2NhbmNlbCIsIl91cGRhdGVBbmltYXRvckZhY3RvcnkiLCJfYW5pbWF0b3JGYWN0b3J5IiwibWFzayIsImJhY2tncm91bmRDb2xvciIsImluaXRNb2RpZmllciIsImNhbmNlbCIsInBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyIsInRyeVNob3ciLCJvcGFjaXR5IiwidHJ5SGlkZSIsIl9ydW5uaW5nIiwib25EZXZpY2VCYWNrQnV0dG9uIiwiY2FsbFBhcmVudEhhbmRsZXIiLCJfYmFja0J1dHRvbkhhbmRsZXIiLCJvbk1vZGlmaWVyQ2hhbmdlZCIsImNyZWF0ZUhhbmRsZXIiLCJkZWZhdWx0Q2xhc3NOYW1lIiwiQmFja0J1dHRvbkVsZW1lbnQiLCJfb3B0aW9ucyIsIl9ib3VuZE9uQ2xpY2siLCJfb25DbGljayIsImljb24iLCJvbkNsaWNrIiwicG9wUGFnZSIsImNvbnRhaW5zIiwiQm90dG9tVG9vbGJhckVsZW1lbnQiLCJCdXR0b25FbGVtZW50IiwiX3VwZGF0ZVJpcHBsZSIsIkNhcm91c2VsSXRlbUVsZW1lbnQiLCJ3aWR0aCIsIlZlcnRpY2FsTW9kZVRyYWl0IiwiX2N1cnJlbnRFbGVtZW50U2l6ZSIsInNjcm9sbCIsIl9zdHlsZSIsIl9kaW1lbnNpb25zIiwiY2VudGVyZWQiLCJwYWRkaW5nQm90dG9tIiwiX29mZnNldCIsIl9nZXRDYXJvdXNlbEl0ZW1TaXplIiwiX2dldENhcm91c2VsSXRlbUVsZW1lbnRzIiwic2l6ZUF0dHIiLCJfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIiLCJzaXplSW5mbyIsIl9kZWNvbXBvc2VTaXplU3RyaW5nIiwibnVtYmVyIiwidW5pdCIsIl91cGRhdGVEaW1lbnNpb25EYXRhIiwiX3VwZGF0ZU9mZnNldCIsIl9sYXlvdXRDYXJvdXNlbEl0ZW1zIiwiSG9yaXpvbnRhbE1vZGVUcmFpdCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiQ2Fyb3VzZWxFbGVtZW50IiwiX3Njcm9sbCIsIl9sYXN0QWN0aXZlSW5kZXgiLCJfYm91bmRPbkRyYWciLCJfb25EcmFnIiwiX2JvdW5kT25EcmFnRW5kIiwiX29uRHJhZ0VuZCIsIl9ib3VuZE9uUmVzaXplIiwiX21peGluIiwiX2lzVmVydGljYWwiLCJzZXRBY3RpdmVJbmRleCIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInJlZnJlc2giLCJfbGFzdFN0YXRlIiwiaXRlbUNvdW50IiwiZWxlbWVudFNpemUiLCJfZ2V0RWxlbWVudFNpemUiLCJyb3VuZCIsImF0dHJOYW1lIiwiaXRlbVNpemVBdHRyIiwic2l6ZSIsIl9nZXRJbml0aWFsSW5kZXgiLCJfc2Nyb2xsVG8iLCJfY2FsY3VsYXRlTWF4U2Nyb2xsIiwiX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQiLCJnZXRBY3RpdmVJbmRleCIsImNhcm91c2VsSXRlbVNpemUiLCJhdXRvU2Nyb2xsIiwiX2dlc3R1cmVEZXRlY3RvciIsIl9tdXRhdGlvbk9ic2VydmVyIiwiX3VwZGF0ZVN3aXBlYWJsZSIsIl91cGRhdGVBdXRvUmVmcmVzaCIsInN3aXBlYWJsZSIsImxhc3RBY3RpdmVJbmRleCIsIl9pc1dyb25nRGlyZWN0aW9uIiwiX2xhc3REcmFnRXZlbnQiLCJfZ2V0U2Nyb2xsRGVsdGEiLCJfaXNPdmVyU2Nyb2xsIiwid2FpdEZvckFjdGlvbiIsIl9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uIiwiX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwiLCJfc3RhcnRNb21lbnR1bVNjcm9sbCIsInRyYWl0IiwiX2dldFNjcm9sbFZlbG9jaXR5Iiwic2Nyb2xsRGVsdGEiLCJfbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24iLCJfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0iLCJhcnIiLCJuYnJPZkl0ZW1zIiwicG9zIiwibGFzdFNjcm9sbCIsInNjcm9sbFJhdGlvIiwiYXV0b1Njcm9sbFJhdGlvIiwiaXNPdmVyc2Nyb2xsYWJsZSIsIm92ZXJzY3JvbGxhYmxlIiwibm9ybWFsaXplU2Nyb2xsIiwicmF0aW8iLCJtYXhTY3JvbGwiLCJjZWlsIiwiX3NldHVwIiwiX3NhdmVMYXN0U3RhdGUiLCJjYXJvdXNlbCIsIl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMiLCJfc2V0dXBJbml0aWFsSW5kZXgiLCJfb25EaXJlY3Rpb25DaGFuZ2UiLCJhdHRyIiwicGFyc2VGbG9hdCIsIkNvbEVsZW1lbnQiLCJfdXBkYXRlV2lkdGgiLCJ3ZWJraXRCb3hGbGV4Iiwid2Via2l0RmxleCIsIm1vekJveEZsZXgiLCJtb3pGbGV4IiwibXNGbGV4IiwiZmxleCIsIm1heFdpZHRoIiwiRGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkRGlhbG9nQW5pbWF0b3IiLCJJT1NEaWFsb2dBbmltYXRvciIsImJvZHlIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJTbGlkZURpYWxvZ0FuaW1hdG9yIiwiRGlhbG9nRWxlbWVudCIsIkZhYkVsZW1lbnQiLCJ0cmFuc2Zvcm0iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IiwiSWNvbkVsZW1lbnQiLCJfdXBkYXRlIiwiX2NsZWFuQ2xhc3NBdHRyaWJ1dGUiLCJfYnVpbGRDbGFzc0FuZFN0eWxlIiwiX2dldEF0dHJpYnV0ZSIsInBhcnRzIiwiZGVmIiwibWQiLCJpY29uTmFtZSIsInJlbW92ZVByb3BlcnR5IiwiZm9udFNpemUiLCJMYXp5UmVwZWF0RWxlbWVudCIsIl9sYXp5UmVwZWF0UHJvdmlkZXIiLCJMaXN0SGVhZGVyRWxlbWVudCIsIkxpc3RJdGVtRWxlbWVudCIsIl9vblRvdWNoIiwiX29uUmVsZWFzZSIsIl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciIsInRhcHBlZCIsIl9zaG91bGRMb2NrT25EcmFnIiwiX3RyYW5zaXRpb24iLCJ3ZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIl90YXBwYWJsZSIsIl90YXBCYWNrZ3JvdW5kQ29sb3IiLCJib3hTaGFkb3ciLCJMaXN0RWxlbWVudCIsImRlZmF1bHRDaGVja2JveENsYXNzIiwiZGVmYXVsdFJhZGlvQnV0dG9uQ2xhc3MiLCJJTlBVVF9BVFRSSUJVVEVTIiwiSW5wdXRFbGVtZW50IiwiX2JvdW5kT25JbnB1dCIsIl9vbklucHV0IiwiX2JvdW5kT25Gb2N1c2luIiwiX29uRm9jdXNpbiIsIl9ib3VuZERlbGVnYXRlRXZlbnQiLCJfZGVsZWdhdGVFdmVudCIsImhlbHBlciIsIl9pbnB1dCIsIl9oZWxwZXIiLCJfdXBkYXRlQm91bmRBdHRyaWJ1dGVzIiwiX3VwZGF0ZUxhYmVsIiwiX3VwZGF0ZUxhYmVsQ2xhc3MiLCJjaGVja2VkIiwiX2JvdW5kT25Gb2N1c291dCIsImlubmVyVGV4dCIsIl9zZXRMYWJlbCIsIk1vZGFsQW5pbWF0b3IiLCJtb2RhbCIsIkZhZGVNb2RhbEFuaW1hdG9yIiwiTW9kYWxFbGVtZW50IiwiTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiZW50ZXJQYWdlIiwibGVhdmVQYWdlIiwiYmxvY2tlciIsIklPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiYmFja2dyb3VuZE1hc2siLCJ0b29sYmFyIiwiX2dldFRvb2xiYXJFbGVtZW50IiwiX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCIsImV4Y2x1ZGVCYWNrQnV0dG9uIiwib3RoZXIiLCJfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCIsIl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50IiwiX2dldENvbnRlbnRFbGVtZW50IiwiX2dldEJhY2tncm91bmRFbGVtZW50IiwiX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50IiwiYm90aFBhZ2VIYXNUb29sYmFyIiwiX2NhbkFuaW1hdGVUb29sYmFyIiwibm9NYXRlcmlhbFRvb2xiYXIiLCJkZWNvbXBvc2l0aW9uIiwicGFnZVJlY3QiLCJiYWNrQnV0dG9uTGFiZWwiLCJsYWJlbFJlY3QiLCJiYWNrQnV0dG9uSWNvbiIsInVuYmxvY2siLCJlbnRlclBhZ2VUYXJnZXQiLCJsZWF2ZVBhZ2VUYXJnZXQiLCJlbnRlclBhZ2VEZWNvbXBvc2l0aW9uIiwiX2RlY29tcG9zZSIsImxlYXZlUGFnZURlY29tcG9zaXRpb24iLCJkZWx0YSIsIl9jYWxjdWxhdGVEZWx0YSIsIm1hc2tDbGVhciIsInNob3VsZEFuaW1hdGVUb29sYmFyIiwiX3Nob3VsZEFuaW1hdGVUb29sYmFyIiwiZW50ZXJQYWdlVG9vbGJhckhlaWdodCIsImJvdHRvbVRvb2xiYXIiLCJiYWNrZ3JvdW5kIiwidG9vbGJhckNlbnRlciIsIklPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciIsImJsYWNrTWFza09wYWNpdHkiLCJNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwicmV3cml0YWJsZXMiLCJuYXZpZ2F0b3JFbGVtZW50IiwiTmF2aWdhdG9yRWxlbWVudCIsIl9pc1J1bm5pbmciLCJfaW5pdGlhbGl6ZWQiLCJfcGFnZUxvYWRlciIsIl9wYWdlTWFwIiwiX3BhZ2UiLCJfb25EZXZpY2VCYWNrQnV0dG9uIiwiX2dldFBhZ2VUYXJnZXQiLCJwdXNoUGFnZSIsIl9zaG93IiwiX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbiIsIl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMiLCJwb3BVcGRhdGUiLCJ1bmxvYWQiLCJfcG9wUGFnZSIsIl9wb3BQYWdlQW5kUmVmcmVzaCIsIm9sZFBhZ2UiLCJwdXNoZWRPcHRpb25zIiwiZGF0YSIsImxvYWQiLCJ1cGRhdGUiLCJfZW1pdFByZVBvcEV2ZW50IiwidXBkYXRlQmFja0J1dHRvbiIsIl9oaWRlIiwiX3ZlcmlmeVBhZ2VFbGVtZW50IiwicGFnZUhUTUwiLCJfcHVzaFBhZ2UiLCJfZW1pdFByZVB1c2hFdmVudCIsInBhZ2VMZW5ndGgiLCJyZXNvbHZlZFZhbHVlIiwiX25vcm1hbGl6ZUluZGV4IiwiX2xhc3RJbmRleE9mUGFnZSIsInBhZ2VOYW1lIiwiaXNDYW5jZWxlZCIsIl9lbWl0UHJlRXZlbnQiLCJ0ZW1wbGF0ZUhUTUwiLCJwYWdlTG9hZGVyIiwiVG9vbGJhckVsZW1lbnQiLCJfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cyIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIm51bGxUb29sYmFyRWxlbWVudCIsIlBhZ2VFbGVtZW50IiwiX2lzU2hvd24iLCJfaXNNdXRlZCIsIl9za2lwSW5pdCIsIl90cnlUb0ZpbGxTdGF0dXNCYXIiLCJiYWNrQnV0dG9uIiwiZmlsbGVkIiwiX2hhc0FQYWdlQ29udHJvbENoaWxkIiwib3ZlckxpbWl0Iiwic2Nyb2xsSGVpZ2h0IiwiX2luZmluaXRlU2Nyb2xsTGltaXQiLCJfb25JbmZpbml0ZVNjcm9sbCIsIl9sb2FkaW5nQ29udGVudCIsIm9uSW5maW5pdGVTY3JvbGwiLCJfZWxlbWVudFNob3VsZEJlTW92ZWQiLCJwcmV2Tm9kZSIsImZpeGVkRWxlbWVudHMiLCJfYm91bmRPblNjcm9sbCIsIl9vblNjcm9sbCIsIlBvcG92ZXJBbmltYXRvciIsImZyb20iLCJ0byIsInJlc3RvcmUiLCJhbmltYXRpb25zIiwiX2FuaW1hdGUiLCJmYWRlIiwiTURGYWRlUG9wb3ZlckFuaW1hdG9yIiwiX2FuaW1hdGVBbGwiLCJpbiIsIklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IiLCJ0ZW1wbGF0ZVNvdXJjZSIsInBvc2l0aW9ucyIsIlBvcG92ZXJFbGVtZW50IiwiX2luaXRBbmltYXRvckZhY3RvcnkiLCJmYWN0b3J5IiwiX2FuaW1hdG9yIiwicmFkaXVzIiwiX3JhZGl1cyIsIl9jb250ZW50IiwibWFyZ2luIiwiX21hcmdpbiIsInRhcmdldFJlY3QiLCJpc01EIiwiY292ZXIiLCJ0YXJnZXREaXN0YW5jZSIsImJvdHRvbSIsInRhcmdldENlbnRlckRpc3RhbmNlRnJvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwidmVydGljYWwiLCJwcmltYXJ5RGlyZWN0aW9uIiwicHJpbWFyeSIsInNlY29uZGFyeSIsInNpemVOYW1lIiwiY29udGVudFNpemUiLCJfcG9wb3ZlciIsInNlY29uZGFyeU9mZnNldCIsIl9hcnJvdyIsIl9jdXJyZW50VGFyZ2V0IiwiX3Bvc2l0aW9uUG9wb3ZlciIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsImFjdGlvbnMiLCJfcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMiLCJjYW5jZWxlZCIsIl9leGVjdXRlQWN0aW9uIiwiX2NsZWFyU3R5bGVzIiwiUHJvZ3Jlc3NCYXJFbGVtZW50IiwiX2lzQ29tcGlsZWQiLCJfdGVtcGxhdGUiLCJfcHJpbWFyeSIsIl9zZWNvbmRhcnkiLCJfdXBkYXRlRGV0ZXJtaW5hdGUiLCJfdXBkYXRlVmFsdWUiLCJiYXJFbGVtZW50IiwiUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQiLCJwZXIiLCJzdmciLCJTVEFURV9JTklUSUFMIiwiU1RBVEVfUFJFQUNUSU9OIiwiU1RBVEVfQUNUSU9OIiwicmVtb3ZlVHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwiV2Via2l0VHJhbnNpdGlvbiIsIlB1bGxIb29rRWxlbWVudCIsIl9ib3VuZE9uRHJhZ1N0YXJ0IiwiX29uRHJhZ1N0YXJ0IiwiX3NldFN0YXRlIiwibGluZUhlaWdodCIsIm1hcmdpblRvcCIsIl9wYWdlRWxlbWVudCIsImRpc2FibGVkIiwiX3N0YXJ0U2Nyb2xsIiwiX2N1cnJlbnRUcmFuc2xhdGlvbiIsIl9nZXRDdXJyZW50U2Nyb2xsIiwiX3RyYW5zaXRpb25EcmFnTGVuZ3RoIiwiX3RocmVzaG9sZEhlaWdodEVuYWJsZWQiLCJ0aHJlc2hvbGRIZWlnaHQiLCJfZmluaXNoIiwiX3RyYW5zbGF0ZVRvIiwiYW5pbWF0ZSIsIm9uQWN0aW9uIiwidGgiLCJub0V2ZW50IiwibGFzdFN0YXRlIiwiX2dldFN0YXRlIiwiX2lzQ29udGVudEZpeGVkIiwiX2dldFNjcm9sbGFibGVFbGVtZW50IiwiX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0iLCJfZHJhZ0xvY2tEaXNhYmxlZCIsIl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMiLCJfY3JlYXRlRXZlbnRMaXN0ZW5lcnMiLCJfc2V0U3R5bGUiLCJfb25BY3Rpb24iLCJBbmltYXRvckNTUyIsImZpbmFsIiwiZ2V0VGltZSIsImluaXRpYWwiLCJuZXh0IiwidXBkYXRlU3R5bGVzIiwiY2xlYXJUaW1lb3V0IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic3RvcE5leHQiLCJjYiIsIm5ld0R1cmF0aW9uIiwicGFzc2VkIiwicmVtYWluaW5nIiwic3BlZWRVcFRpbWUiLCJzdG9wIiwibWlsbGlzZWNvbmRzIiwic3BlZWQiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJfb25TdG9wQW5pbWF0aW9ucyIsIl9xdWV1ZSIsIl9pbmRleCIsInN0b3BBbmltYXRpb25zIiwiUmlwcGxlRWxlbWVudCIsIl93YXZlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9iYWNrZ3JvdW5kIiwiX2NlbnRlciIsIl9taW5SIiwiX2NhbGN1bGF0ZUNvb3JkcyIsInN0b3BBbGwiLCJjb21wdXRlZFN0eWxlIiwiX3VwZGF0ZVBhcmVudCIsIl9yaXBwbGVBbmltYXRpb24iLCJfaG9sZGluZyIsIl9ib3VuZE9uUmVsZWFzZSIsIl9vblRhcCIsIl9wYXJlbnROb2RlIiwiX2JvdW5kT25UYXAiLCJfYm91bmRPbkhvbGQiLCJfb25Ib2xkIiwicG4iLCJSb3dFbGVtZW50IiwiU2VsZWN0RWxlbWVudCIsIl9zZWxlY3QiLCJzZWwiLCJfX2RlZmluZUdldHRlcl9fIiwiX19kZWZpbmVTZXR0ZXJfXyIsIm9wdGlvbiIsIlNwZWVkRGlhbEl0ZW1FbGVtZW50IiwiX3VwZGF0ZUNsYXNzTmFtZSIsImV2ZXJ5Iiwic3R5bGVyIiwiX3ByZWZpeCIsInByZWZpeCIsImNsZWFyIiwiX2NsZWFyIiwiU3BlZWREaWFsRWxlbWVudCIsIl9pdGVtU2hvd24iLCJfdXBkYXRlRGlyZWN0aW9uIiwidG9nZ2xlSXRlbXMiLCJpbmxpbmUiLCJfZmFiIiwiaGlkZUl0ZW1zIiwidG90YWxEZWxheSIsImlzT3BlbiIsInNob3dJdGVtcyIsIlNwbGl0dGVyQ29udGVudEVsZW1lbnQiLCJvbGRDb250ZW50IiwiU3BsaXR0ZXJNYXNrRWxlbWVudCIsIl9zaWRlcyIsInNpZGUiLCJtb2RlIiwiY2xvc2UiLCJTcGxpdHRlckFuaW1hdG9yIiwic2lkZUVsZW1lbnQiLCJzcGxpdHRlciIsIl9zaWRlIiwibWludXMiLCJTcGxpdHRlckVsZW1lbnQiLCJfbGF5b3V0IiwiX3dpZHRoIiwiX2JvdW5kT25Nb2RlQ2hhbmdlIiwiX29uTW9kZUNoYW5nZSIsIl9nZXRTaWRlIiwiU1BMSVRfTU9ERSIsIkNPTExBUFNFX01PREUiLCJDTE9TRURfU1RBVEUiLCJPUEVOX1NUQVRFIiwiQ0hBTkdJTkdfU1RBVEUiLCJXQVRDSEVEX0FUVFJJQlVURVMiLCJzcGxpdHRlclNpZGVFbGVtZW50IiwiQ29sbGFwc2VEZXRlY3Rpb24iLCJjaGFuZ2VUYXJnZXQiLCJfdGFyZ2V0IiwiX29yaWVudGF0aW9uIiwiYWN0aXZhdGUiLCJfdXBkYXRlTW9kZSIsIl9tYXRjaCIsIl9xdWVyeVJlc3VsdCIsIm1hdGNoTWVkaWEiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwid2lkdGhUb1B4Iiwib2Zmc2V0V2lkdGgiLCJDb2xsYXBzZU1vZGUiLCJfYWN0aXZlIiwiX3N0YXRlIiwiX2xvY2siLCJfaXNPcGVuT3RoZXJTaWRlTWVudSIsIl9pZ25vcmVEcmFnIiwic2Nyb2xsaW5nIiwiYXJlYSIsIl9zd2lwZVRhcmdldFdpZHRoIiwiX3N0YXJ0RGlzdGFuY2UiLCJfZGlzdGFuY2UiLCJ0cmFuc2xhdGUiLCJzaG91bGRPcGVuIiwiX3RocmVzaG9sZCIsImV4ZWN1dGVBY3Rpb24iLCJsYXlvdXQiLCJGSU5BTF9TVEFURSIsIl9lbWl0RXZlbnQiLCJ3aXRob3V0QW5pbWF0aW9uIiwiU3BsaXR0ZXJTaWRlRWxlbWVudCIsIl9jb2xsYXBzZU1vZGUiLCJfY29sbGFwc2VEZXRlY3Rpb24iLCJfYm91bmRIYW5kbGVHZXN0dXJlIiwiaGFuZGxlR2VzdHVyZSIsIl93YXRjaGVkQXR0cmlidXRlcyIsIl9tb2RlIiwidGhyZXNob2xkIiwidXBkYXRlT3B0aW9ucyIsImxvY2F0aW9ucyIsIlN3aXRjaEVsZW1lbnQiLCJfY2hlY2tlZCIsIl9kaXNhYmxlZCIsIl9jaGVja2JveCIsIl9oYW5kbGUiLCJjbGljayIsIl9sb2NhdGlvbnMiLCJfc3RhcnRYIiwiX2dldFBvc2l0aW9uIiwicHJldmlvdXNWYWx1ZSIsIl9pc01hdGVyaWFsIiwiVGFiYmFyQW5pbWF0b3IiLCJlbnRlclBhZ2VJbmRleCIsImxlYXZlUGFnZUluZGV4IiwiVGFiYmFyTm9uZUFuaW1hdG9yIiwiZW50ZXJJbmRleCIsImxlYXZlSW5kZXgiLCJUYWJiYXJGYWRlQW5pbWF0b3IiLCJUYWJiYXJTbGlkZUFuaW1hdG9yIiwic2duIiwidGFiYmFyRWxlbWVudCIsIlRhYmJhckVsZW1lbnQiLCJfdGFiYmFySWQiLCJhY3RpdmVJbmRleCIsInRhYmJhciIsIl90YWJiYXJFbGVtZW50IiwiYmFyIiwiX3RvcCIsIm9sZFBhZ2VFbGVtZW50IiwiX29sZFBhZ2VFbGVtZW50Iiwic2VsZWN0ZWRUYWJJbmRleCIsInByZXZpb3VzVGFiSW5kZXgiLCJwcmV2aW91c1RhYiIsIl9nZXRBY3RpdmVUYWJFbGVtZW50Iiwic2VsZWN0ZWRUYWIiLCJfZ2V0VGFiRWxlbWVudCIsImdldEFjdGl2ZVRhYkluZGV4IiwicHJldmlvdXNQYWdlRWxlbWVudCIsIl9nZXRDdXJyZW50UGFnZUVsZW1lbnQiLCJzZXRJbmFjdGl2ZSIsInNldEFjdGl2ZSIsIl9sb2FkUGFnZUVsZW1lbnQiLCJfc3dpdGNoUGFnZSIsIl9nZXRUYWJiYXJFbGVtZW50Iiwic2V0VGFiYmFyVmlzaWJpbGl0eSIsInRhYnMiLCJUYWJFbGVtZW50IiwiaXNBY3RpdmUiLCJjdXJyZW50UGFnZUVsZW1lbnQiLCJkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSIsImhhc0lucHV0IiwiaGFzQnV0dG9uIiwiX2J1dHRvbiIsIl90ZW1wbGF0ZUxvYWRlZCIsImhhc0NoaWxkcmVuIiwiX2hhc0RlZmF1bHRUZW1wbGF0ZSIsIl91cGRhdGVEZWZhdWx0VGVtcGxhdGUiLCJiYWRnZSIsImljb25FbGVtZW50IiwibGFiZWxFbGVtZW50IiwiYmFkZ2VFbGVtZW50IiwiX2ZpbmRUYWJiYXJFbGVtZW50Iiwic2V0QWN0aXZlVGFiIiwiX2ZpbmRUYWJJbmRleCIsIl9sb2FkZWRQYWdlIiwiX2xvYWRpbmdQYWdlIiwiX2Vuc3VyZUVsZW1lbnRQb3NpdGlvbiIsImhhc0xvYWRlZCIsIlRvb2xiYXJCdXR0b25FbGVtZW50IiwiUmFuZ2VFbGVtZW50IiwiX3VwZGF0ZURpc2FibGVkIiwiYmFja2dyb3VuZFNpemUiLCJfcmF0aW8iLCJfb25EcmFnc3RhcnQiLCJmYXN0Q2xpY2siLCJGYXN0Q2xpY2siLCJhdHRhY2giLCJhcHAiLCJleGl0QXBwIiwiVmlld3BvcnQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxVQUFVQyxNQUFWLENBQWlCM2tELFNBQVNnMEIsSUFBMUIsQ0FBaEI7Q0FESixFQUVHLEtBRkg7OztBQUtBcDVCLE9BQU95RCxnQkFBUCxDQUF3QixrQkFBeEIsRUFBNEMsWUFBTTtRQUM1QzA3QiwyQkFBSixDQUFnQ3pMLE1BQWhDO1FBQ0k2TSwrQkFBSixHQUFzQ3ZCLE1BQUlHLDJCQUFKLENBQWdDK0YsYUFBaEMsQ0FBOENsbEMsT0FBT29GLFFBQVAsQ0FBZ0JnMEIsSUFBOUQsRUFBb0UsWUFBTTtjQUNwRzR3QixHQUFWLENBQWNDLE9BQWQ7R0FEb0MsQ0FBdEM7V0FHUzd3QixJQUFULENBQWNnUSxnQkFBZCxHQUFpQyxJQUFJcEssTUFBSTFWLGVBQVIsQ0FBd0Jsa0IsU0FBU2cwQixJQUFqQyxDQUFqQztDQUxGLEVBTUcsS0FOSDs7O0FBU0E0RixNQUFJbUIsS0FBSixDQUFVLFlBQVc7UUFDZm1DLHlCQUFKO0NBREY7OztBQUtBLElBQUk0bkIsUUFBSixHQUFlai9CLEtBQWYsR0FFQSIsImZpbGUiOiJvbnNlbnVpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKCF3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBDdXN0b21FdmVudDtcblxuICAgIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgdmFyIGV2dDtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgfSkoKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjIyXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiX19zdFwiICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArIFwiX19cIik7XG4gICAgfTtcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZW50cnlbMF0gPSBlbnRyeVsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuV2Vha01hcCA9IFdlYWtNYXA7XG4gIH0pKCk7XG59XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XG4gIH1cbn0pKHNlbGYpOyIsIi8qXHJcbiAqIGNoaWxkTm9kZS5yZW1vdmUgbWV0aG9kIHBvbHlmaWxsIGZvciBJRS5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NoaWxkTm9kZS9yZW1vdmVcclxuICovXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0aWYgKCEoJ3JlbW92ZScgaW4gRWxlbWVudC5wcm90b3R5cGUpKSB7XHJcblx0ICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHQgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG5cdCAgICBcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHR9XHJcbn0pKCk7XHJcbiIsIi8qXHJcbiAqIGNsYXNzTGlzdC5qczogQ3Jvc3MtYnJvd3NlciBmdWxsIGVsZW1lbnQuY2xhc3NMaXN0IGltcGxlbWVudGF0aW9uLlxyXG4gKiAxLjEuMjAxNTAzMTJcclxuICpcclxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxyXG4gKiBMaWNlbnNlOiBEZWRpY2F0ZWQgdG8gdGhlIHB1YmxpYyBkb21haW4uXHJcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXHJcbiAqL1xyXG5cclxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xyXG5cclxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cclxuXHJcbmlmIChcImRvY3VtZW50XCIgaW4gc2VsZikge1xyXG5cclxuLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxyXG4vLyBJbmNsdWRpbmcgSUUgPCBFZGdlIG1pc3NpbmcgU1ZHRWxlbWVudC5jbGFzc0xpc3RcclxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSlcclxuICB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJnXCIpKSkge1xyXG5cclxuKGZ1bmN0aW9uICh2aWV3KSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xyXG5cclxudmFyXHJcbiAgICBjbGFzc0xpc3RQcm9wID0gXCJjbGFzc0xpc3RcIlxyXG4gICwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxyXG4gICwgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF1cclxuICAsIG9iakN0ciA9IE9iamVjdFxyXG4gICwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XHJcbiAgfVxyXG4gICwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgdmFyXHJcbiAgICAgICAgaSA9IDBcclxuICAgICAgLCBsZW4gPSB0aGlzLmxlbmd0aFxyXG4gICAgO1xyXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuICAvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcclxuICAsIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubmFtZSA9IHR5cGU7XHJcbiAgICB0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gIH1cclxuICAsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XHJcbiAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4KFxyXG4gICAgICAgICAgXCJTWU5UQVhfRVJSXCJcclxuICAgICAgICAsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXHJcbiAgICAgICAgICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXHJcbiAgICAgICAgLCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xyXG4gIH1cclxuICAsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXJcclxuICAgICAgICB0cmltbWVkQ2xhc3NlcyA9IHN0clRyaW0uY2FsbChlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpXHJcbiAgICAgICwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXHJcbiAgICAgICwgaSA9IDBcclxuICAgICAgLCBsZW4gPSBjbGFzc2VzLmxlbmd0aFxyXG4gICAgO1xyXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcclxuICAgIH07XHJcbiAgfVxyXG4gICwgY2xhc3NMaXN0UHJvdG8gPSBDbGFzc0xpc3RbcHJvdG9Qcm9wXSA9IFtdXHJcbiAgLCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcclxuICB9XHJcbjtcclxuLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxyXG4vLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cclxuRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XHJcbmNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xyXG4gIHJldHVybiB0aGlzW2ldIHx8IG51bGw7XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgdG9rZW4gKz0gXCJcIjtcclxuICByZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXJcclxuICAgICAgdG9rZW5zID0gYXJndW1lbnRzXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXHJcbiAgICAsIHRva2VuXHJcbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxyXG4gIDtcclxuICBkbyB7XHJcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XHJcbiAgICBpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5wdXNoKHRva2VuKTtcclxuICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlICgrK2kgPCBsKTtcclxuXHJcbiAgaWYgKHVwZGF0ZWQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhclxyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcclxuICAgICwgaSA9IDBcclxuICAgICwgbCA9IHRva2Vucy5sZW5ndGhcclxuICAgICwgdG9rZW5cclxuICAgICwgdXBkYXRlZCA9IGZhbHNlXHJcbiAgICAsIGluZGV4XHJcbiAgO1xyXG4gIGRvIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcclxuICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcclxuICAgIHdoaWxlIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoKytpIDwgbCk7XHJcblxyXG4gIGlmICh1cGRhdGVkKSB7XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcclxuICB0b2tlbiArPSBcIlwiO1xyXG5cclxuICB2YXJcclxuICAgICAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcclxuICAgICwgbWV0aG9kID0gcmVzdWx0ID9cclxuICAgICAgZm9yY2UgIT09IHRydWUgJiYgXCJyZW1vdmVcIlxyXG4gICAgOlxyXG4gICAgICBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIlxyXG4gIDtcclxuXHJcbiAgaWYgKG1ldGhvZCkge1xyXG4gICAgdGhpc1ttZXRob2RdKHRva2VuKTtcclxuICB9XHJcblxyXG4gIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmb3JjZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICFyZXN1bHQ7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcclxufTtcclxuXHJcbmlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcclxuICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XHJcbiAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyXHJcbiAgICAsIGVudW1lcmFibGU6IHRydWVcclxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfTtcclxuICB0cnkge1xyXG4gICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xyXG4gIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxyXG4gICAgaWYgKGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcclxuICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcclxuICBlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xyXG59XHJcblxyXG59KHNlbGYpKTtcclxuXHJcbn0gZWxzZSB7XHJcbi8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxyXG4vLyB0byBub3JtYWxpemUgdGhlIGFkZC9yZW1vdmUgYW5kIHRvZ2dsZSBBUElzLlxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIik7XHJcblxyXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpO1xyXG5cclxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAvMTEgYW5kIEZpcmVmb3ggPDI2LCB3aGVyZSBjbGFzc0xpc3QuYWRkIGFuZFxyXG4gIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxyXG4gIGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzJcIikpIHtcclxuICAgIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xyXG5cclxuICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICB2YXIgaSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgIG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjcmVhdGVNZXRob2QoJ2FkZCcpO1xyXG4gICAgY3JlYXRlTWV0aG9kKCdyZW1vdmUnKTtcclxuICB9XHJcblxyXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XHJcblxyXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcclxuICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAgaWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMzXCIpKSB7XHJcbiAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xyXG5cclxuICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24odG9rZW4sIGZvcmNlKSB7XHJcbiAgICAgIGlmICgxIGluIGFyZ3VtZW50cyAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgfVxyXG5cclxuICB0ZXN0RWxlbWVudCA9IG51bGw7XHJcbn0oKSk7XHJcblxyXG59XHJcblxyXG59XHJcblxyXG4iLCI7KGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBAcHJlc2VydmUgRmFzdENsaWNrOiBwb2x5ZmlsbCB0byByZW1vdmUgY2xpY2sgZGVsYXlzIG9uIGJyb3dzZXJzIHdpdGggdG91Y2ggVUlzLlxuXHQgKlxuXHQgKiBAY29kaW5nc3RhbmRhcmQgZnRsYWJzLWpzdjJcblx0ICogQGNvcHlyaWdodCBUaGUgRmluYW5jaWFsIFRpbWVzIExpbWl0ZWQgW0FsbCBSaWdodHMgUmVzZXJ2ZWRdXG5cdCAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChzZWUgTElDRU5TRS50eHQpXG5cdCAqL1xuXG5cdC8qanNsaW50IGJyb3dzZXI6dHJ1ZSwgbm9kZTp0cnVlKi9cblx0LypnbG9iYWwgZGVmaW5lLCBFdmVudCwgTm9kZSovXG5cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGUgZmFzdC1jbGlja2luZyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCBsYXllci5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0ZnVuY3Rpb24gRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0dmFyIG9sZE9uQ2xpY2s7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgYSBjbGljayBpcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGltZXN0YW1wIGZvciB3aGVuIGNsaWNrIHRyYWNraW5nIHN0YXJ0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbGVtZW50IGJlaW5nIHRyYWNrZWQgZm9yIGEgY2xpY2suXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFdmVudFRhcmdldFxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFgtY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFggPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBZLWNvb3JkaW5hdGUgb2YgdG91Y2ggc3RhcnQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogSUQgb2YgdGhlIGxhc3QgdG91Y2gsIHJldHJpZXZlZCBmcm9tIFRvdWNoLmlkZW50aWZpZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUb3VjaG1vdmUgYm91bmRhcnksIGJleW9uZCB3aGljaCBhIGNsaWNrIHdpbGwgYmUgY2FuY2VsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaEJvdW5kYXJ5ID0gb3B0aW9ucy50b3VjaEJvdW5kYXJ5IHx8IDEwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgRmFzdENsaWNrIGxheWVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiB0YXAodG91Y2hzdGFydCBhbmQgdG91Y2hlbmQpIGV2ZW50c1xuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBEZWxheSA9IG9wdGlvbnMudGFwRGVsYXkgfHwgMjAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gdGltZSBmb3IgYSB0YXBcblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudGFwVGltZW91dCA9IG9wdGlvbnMudGFwVGltZW91dCB8fCA3MDA7XG5cblx0XHRpZiAoRmFzdENsaWNrLm5vdE5lZWRlZChsYXllcikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBBbmRyb2lkIGRvbid0IGhhdmUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0XHRmdW5jdGlvbiBiaW5kKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7IH07XG5cdFx0fVxuXG5cblx0XHR2YXIgbWV0aG9kcyA9IFsnb25Nb3VzZScsICdvbkNsaWNrJywgJ29uVG91Y2hTdGFydCcsICdvblRvdWNoTW92ZScsICdvblRvdWNoRW5kJywgJ29uVG91Y2hDYW5jZWwnXTtcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29udGV4dFttZXRob2RzW2ldXSA9IGJpbmQoY29udGV4dFttZXRob2RzW2ldXSwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGFzIHJlcXVpcmVkXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblxuXHRcdC8vIEhhY2sgaXMgcmVxdWlyZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdC8vIHdoaWNoIGlzIGhvdyBGYXN0Q2xpY2sgbm9ybWFsbHkgc3RvcHMgY2xpY2sgZXZlbnRzIGJ1YmJsaW5nIHRvIGNhbGxiYWNrcyByZWdpc3RlcmVkIG9uIHRoZSBGYXN0Q2xpY2tcblx0XHQvLyBsYXllciB3aGVuIHRoZXkgYXJlIGNhbmNlbGxlZC5cblx0XHRpZiAoIUV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgcm12ID0gTm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRybXYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgYWR2ID0gTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgKGNhbGxiYWNrLmhpamFja2VkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmICghZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSwgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWR2LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhhbmRsZXIgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGUgZWxlbWVudCdzIG9uY2xpY2sgYXR0cmlidXRlLCBpdCB3aWxsIGJlIGZpcmVkIGJlZm9yZVxuXHRcdC8vIEZhc3RDbGljaydzIG9uQ2xpY2sgaGFuZGxlci4gRml4IHRoaXMgYnkgcHVsbGluZyBvdXQgdGhlIHVzZXItZGVmaW5lZCBoYW5kbGVyIGZ1bmN0aW9uIGFuZFxuXHRcdC8vIGFkZGluZyBpdCBhcyBsaXN0ZW5lci5cblx0XHRpZiAodHlwZW9mIGxheWVyLm9uY2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblxuXHRcdFx0Ly8gQW5kcm9pZCBicm93c2VyIG9uIGF0IGxlYXN0IDMuMiByZXF1aXJlcyBhIG5ldyByZWZlcmVuY2UgdG8gdGhlIGZ1bmN0aW9uIGluIGxheWVyLm9uY2xpY2tcblx0XHRcdC8vIC0gdGhlIG9sZCBvbmUgd29uJ3Qgd29yayBpZiBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lciBkaXJlY3RseS5cblx0XHRcdG9sZE9uQ2xpY2sgPSBsYXllci5vbmNsaWNrO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRvbGRPbkNsaWNrKGV2ZW50KTtcblx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdGxheWVyLm9uY2xpY2sgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIFdpbmRvd3MgUGhvbmUgOC4xIGZha2VzIHVzZXIgYWdlbnQgc3RyaW5nIHRvIGxvb2sgbGlrZSBBbmRyb2lkIGFuZCBpUGhvbmUuXG5cdCpcblx0KiBAdHlwZSBib29sZWFuXG5cdCovXG5cdHZhciBkZXZpY2VJc1dpbmRvd3NQaG9uZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPj0gMDtcblxuXHQvKipcblx0ICogQW5kcm9pZCByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPiAwICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TID0gL2lQKGFkfGhvbmV8b2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNCByZXF1aXJlcyBhbiBleGNlcHRpb24gZm9yIHNlbGVjdCBlbGVtZW50cy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TNCA9IGRldmljZUlzSU9TICYmICgvT1MgNF9cXGQoX1xcZCk/LykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNi4wLTcuKiByZXF1aXJlcyB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gYmUgbWFudWFsbHkgZGVyaXZlZFxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyBbNi03XV9cXGQvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBCbGFja0JlcnJ5IHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0JsYWNrQmVycnkxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQkIxMCcpID4gMDtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgbmF0aXZlIGNsaWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBuZWVkcyBhIG5hdGl2ZSBjbGlja1xuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0NsaWNrID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayB0byBkaXNhYmxlZCBpbnB1dHMgKGlzc3VlICM2Milcblx0XHRjYXNlICdidXR0b24nOlxuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0aWYgKHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHQvLyBGaWxlIGlucHV0cyBuZWVkIHJlYWwgY2xpY2tzIG9uIGlPUyA2IGR1ZSB0byBhIGJyb3dzZXIgYnVnIChpc3N1ZSAjNjgpXG5cdFx0XHRpZiAoKGRldmljZUlzSU9TICYmIHRhcmdldC50eXBlID09PSAnZmlsZScpIHx8IHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGFiZWwnOlxuXHRcdGNhc2UgJ2lmcmFtZSc6IC8vIGlPUzggaG9tZXNjcmVlbiBhcHBzIGNhbiBwcmV2ZW50IGV2ZW50cyBidWJibGluZyBpbnRvIGZyYW1lc1xuXHRcdGNhc2UgJ3ZpZGVvJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL1xcYm5lZWRzY2xpY2tcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgY2xpY2sgaW50byBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgbmF0aXZlIGNsaWNrLlxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0ZvY3VzID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdGNhc2UgJ3RleHRhcmVhJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0XHRyZXR1cm4gIWRldmljZUlzQW5kcm9pZDtcblx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRzd2l0Y2ggKHRhcmdldC50eXBlKSB7XG5cdFx0XHRjYXNlICdidXR0b24nOlxuXHRcdFx0Y2FzZSAnY2hlY2tib3gnOlxuXHRcdFx0Y2FzZSAnZmlsZSc6XG5cdFx0XHRjYXNlICdpbWFnZSc6XG5cdFx0XHRjYXNlICdyYWRpbyc6XG5cdFx0XHRjYXNlICdzdWJtaXQnOlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIHBvaW50IGluIGF0dGVtcHRpbmcgdG8gZm9jdXMgZGlzYWJsZWQgaW5wdXRzXG5cdFx0XHRyZXR1cm4gIXRhcmdldC5kaXNhYmxlZCAmJiAhdGFyZ2V0LnJlYWRPbmx5O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKC9cXGJuZWVkc2ZvY3VzXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogU2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnNlbmRDbGljayA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50KSB7XG5cdFx0dmFyIGNsaWNrRXZlbnQsIHRvdWNoO1xuXG5cdFx0Ly8gT24gc29tZSBBbmRyb2lkIGRldmljZXMgYWN0aXZlRWxlbWVudCBuZWVkcyB0byBiZSBibHVycmVkIG90aGVyd2lzZSB0aGUgc3ludGhldGljIGNsaWNrIHdpbGwgaGF2ZSBubyBlZmZlY3QgKCMyNClcblx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50KSB7XG5cdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblx0XHR9XG5cblx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gU3ludGhlc2l6ZSBhIGNsaWNrIGV2ZW50LCB3aXRoIGFuIGV4dHJhIGF0dHJpYnV0ZSBzbyBpdCBjYW4gYmUgdHJhY2tlZFxuXHRcdGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRjbGlja0V2ZW50LmluaXRNb3VzZUV2ZW50KHRoaXMuZGV0ZXJtaW5lRXZlbnRUeXBlKHRhcmdldEVsZW1lbnQpLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIHRvdWNoLnNjcmVlblgsIHRvdWNoLnNjcmVlblksIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0XHRjbGlja0V2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQgPSB0cnVlO1xuXHRcdHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcblx0fTtcblxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRldGVybWluZUV2ZW50VHlwZSA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblxuXHRcdC8vSXNzdWUgIzE1OTogQW5kcm9pZCBDaHJvbWUgU2VsZWN0IEJveCBkb2VzIG5vdCBvcGVuIHdpdGggYSBzeW50aGV0aWMgY2xpY2sgZXZlbnRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkICYmIHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuXHRcdFx0cmV0dXJuICdtb3VzZWRvd24nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnY2xpY2snO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgbGVuZ3RoO1xuXG5cdFx0Ly8gSXNzdWUgIzE2MDogb24gaU9TIDcsIHNvbWUgaW5wdXQgZWxlbWVudHMgKGUuZy4gZGF0ZSBkYXRldGltZSBtb250aCkgdGhyb3cgYSB2YWd1ZSBUeXBlRXJyb3Igb24gc2V0U2VsZWN0aW9uUmFuZ2UuIFRoZXNlIGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gaW50ZWdlciB2YWx1ZSBmb3IgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgcHJvcGVydGllcywgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdCBjYW4ndCBiZSB1c2VkIGZvciBkZXRlY3Rpb24gYmVjYXVzZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnRpZXMgYWxzbyB0aHJvd3MgYSBUeXBlRXJyb3IuIEp1c3QgY2hlY2sgdGhlIHR5cGUgaW5zdGVhZC4gRmlsZWQgYXMgQXBwbGUgYnVnICMxNTEyMjcyNC5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSAmJiB0YXJnZXRFbGVtZW50LnR5cGUuaW5kZXhPZignZGF0ZScpICE9PSAwICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ3RpbWUnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ21vbnRoJykge1xuXHRcdFx0bGVuZ3RoID0gdGFyZ2V0RWxlbWVudC52YWx1ZS5sZW5ndGg7XG5cdFx0XHR0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciBhbmQgaWYgc28sIHNldCBhIGZsYWcgb24gaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS51cGRhdGVTY3JvbGxQYXJlbnQgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudCwgcGFyZW50RWxlbWVudDtcblxuXHRcdHNjcm9sbFBhcmVudCA9IHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkaXNjb3ZlciB3aGV0aGVyIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgc2Nyb2xsYWJsZSBsYXllci4gUmUtY2hlY2sgaWYgdGhlXG5cdFx0Ly8gdGFyZ2V0IGVsZW1lbnQgd2FzIG1vdmVkIHRvIGFub3RoZXIgcGFyZW50LlxuXHRcdGlmICghc2Nyb2xsUGFyZW50IHx8ICFzY3JvbGxQYXJlbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdHBhcmVudEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAocGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSBwYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdH0gd2hpbGUgKHBhcmVudEVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdC8vIEFsd2F5cyB1cGRhdGUgdGhlIHNjcm9sbCB0b3AgdHJhY2tlciBpZiBwb3NzaWJsZS5cblx0XHRpZiAoc2Nyb2xsUGFyZW50KSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihldmVudFRhcmdldCkge1xuXG5cdFx0Ly8gT24gc29tZSBvbGRlciBicm93c2VycyAobm90YWJseSBTYWZhcmkgb24gaU9TIDQuMSAtIHNlZSBpc3N1ZSAjNTYpIHRoZSBldmVudCB0YXJnZXQgbWF5IGJlIGEgdGV4dCBub2RlLlxuXHRcdGlmIChldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdHJldHVybiBldmVudFRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudFRhcmdldDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBzdGFydCwgcmVjb3JkIHRoZSBwb3NpdGlvbiBhbmQgc2Nyb2xsIG9mZnNldC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldEVsZW1lbnQsIHRvdWNoLCBzZWxlY3Rpb247XG5cblx0XHQvLyBJZ25vcmUgbXVsdGlwbGUgdG91Y2hlcywgb3RoZXJ3aXNlIHBpbmNoLXRvLXpvb20gaXMgcHJldmVudGVkIGlmIGJvdGggZmluZ2VycyBhcmUgb24gdGhlIEZhc3RDbGljayBlbGVtZW50IChpc3N1ZSAjMTExKS5cblx0XHRpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cdFx0dG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gSWdub3JlIHRvdWNoZXMgb24gY29udGVudGVkaXRhYmxlIGVsZW1lbnRzIHRvIHByZXZlbnQgY29uZmxpY3Qgd2l0aCB0ZXh0IHNlbGVjdGlvbi5cblx0XHQvLyAoRm9yIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mdGxhYnMvZmFzdGNsaWNrL3B1bGwvMjExIClcblx0XHRpZiAodGFyZ2V0RWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzSU9TKSB7XG5cblx0XHRcdC8vIE9ubHkgdHJ1c3RlZCBldmVudHMgd2lsbCBkZXNlbGVjdCB0ZXh0IG9uIGlPUyAoaXNzdWUgIzQ5KVxuXHRcdFx0c2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0aWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdFx0Ly8gV2VpcmQgdGhpbmdzIGhhcHBlbiBvbiBpT1Mgd2hlbiBhbiBhbGVydCBvciBjb25maXJtIGRpYWxvZyBpcyBvcGVuZWQgZnJvbSBhIGNsaWNrIGV2ZW50IGNhbGxiYWNrIChpc3N1ZSAjMjMpOlxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cdFx0XHRcdC8vIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciBhcyB0aGUgdG91Y2ggZXZlbnQgdGhhdCBwcmV2aW91c2x5IHRyaWdnZXJlZCB0aGUgY2xpY2sgdGhhdCB0cmlnZ2VyZWQgdGhlIGFsZXJ0LlxuXHRcdFx0XHQvLyBTYWRseSwgdGhlcmUgaXMgYW4gaXNzdWUgb24gaU9TIDQgdGhhdCBjYXVzZXMgc29tZSBub3JtYWwgdG91Y2ggZXZlbnRzIHRvIGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllciBhcyBhblxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBCYXNlZCBvbiBhIHRvdWNobW92ZSBldmVudCBvYmplY3QsIGNoZWNrIHdoZXRoZXIgdGhlIHRvdWNoIGhhcyBtb3ZlZCBwYXN0IGEgYm91bmRhcnkgc2luY2UgaXQgc3RhcnRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnRvdWNoSGFzTW92ZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLCBib3VuZGFyeSA9IHRoaXMudG91Y2hCb3VuZGFyeTtcblxuXHRcdGlmIChNYXRoLmFicyh0b3VjaC5wYWdlWCAtIHRoaXMudG91Y2hTdGFydFgpID4gYm91bmRhcnkgfHwgTWF0aC5hYnModG91Y2gucGFnZVkgLSB0aGlzLnRvdWNoU3RhcnRZKSA+IGJvdW5kYXJ5KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsYXN0IHBvc2l0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgdG91Y2ggaGFzIG1vdmVkLCBjYW5jZWwgdGhlIGNsaWNrIHRyYWNraW5nXG5cdFx0aWYgKHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCkgfHwgdGhpcy50b3VjaEhhc01vdmVkKGV2ZW50KSkge1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gZmluZCB0aGUgbGFiZWxsZWQgY29udHJvbCBmb3IgdGhlIGdpdmVuIGxhYmVsIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8SFRNTExhYmVsRWxlbWVudH0gbGFiZWxFbGVtZW50XG5cdCAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZpbmRDb250cm9sID0gZnVuY3Rpb24obGFiZWxFbGVtZW50KSB7XG5cblx0XHQvLyBGYXN0IHBhdGggZm9yIG5ld2VyIGJyb3dzZXJzIHN1cHBvcnRpbmcgdGhlIEhUTUw1IGNvbnRyb2wgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5jb250cm9sICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsYWJlbEVsZW1lbnQuY29udHJvbDtcblx0XHR9XG5cblx0XHQvLyBBbGwgYnJvd3NlcnMgdW5kZXIgdGVzdCB0aGF0IHN1cHBvcnQgdG91Y2ggZXZlbnRzIGFsc28gc3VwcG9ydCB0aGUgSFRNTDUgaHRtbEZvciBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50Lmh0bWxGb3IpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsYWJlbEVsZW1lbnQuaHRtbEZvcik7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gZm9yIGF0dHJpYnV0ZSBleGlzdHMsIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGZpcnN0IGxhYmVsbGFibGUgZGVzY2VuZGFudCBlbGVtZW50XG5cdFx0Ly8gdGhlIGxpc3Qgb2Ygd2hpY2ggaXMgZGVmaW5lZCBoZXJlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxhYmVsXG5cdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24sIGlucHV0Om5vdChbdHlwZT1oaWRkZW5dKSwga2V5Z2VuLCBtZXRlciwgb3V0cHV0LCBwcm9ncmVzcywgc2VsZWN0LCB0ZXh0YXJlYScpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGVuZCwgZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IGF0IG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZm9yRWxlbWVudCwgdHJhY2tpbmdDbGlja1N0YXJ0LCB0YXJnZXRUYWdOYW1lLCBzY3JvbGxQYXJlbnQsIHRvdWNoLCB0YXJnZXRFbGVtZW50ID0gdGhpcy50YXJnZXRFbGVtZW50O1xuXG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0KSA+IHRoaXMudGFwVGltZW91dCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgdG8gcHJldmVudCB3cm9uZyBjbGljayBjYW5jZWwgb24gaW5wdXQgKGlzc3VlICMxNTYpLlxuXHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gZmFsc2U7XG5cblx0XHR0aGlzLmxhc3RDbGlja1RpbWUgPSBldmVudC50aW1lU3RhbXA7XG5cblx0XHR0cmFja2luZ0NsaWNrU3RhcnQgPSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydDtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblx0XHQvLyBPbiBzb21lIGlPUyBkZXZpY2VzLCB0aGUgdGFyZ2V0RWxlbWVudCBzdXBwbGllZCB3aXRoIHRoZSBldmVudCBpcyBpbnZhbGlkIGlmIHRoZSBsYXllclxuXHRcdC8vIGlzIHBlcmZvcm1pbmcgYSB0cmFuc2l0aW9uIG9yIHNjcm9sbCwgYW5kIGhhcyB0byBiZSByZS1kZXRlY3RlZCBtYW51YWxseS4gTm90ZSB0aGF0XG5cdFx0Ly8gZm9yIHRoaXMgdG8gZnVuY3Rpb24gY29ycmVjdGx5LCBpdCBtdXN0IGJlIGNhbGxlZCAqYWZ0ZXIqIHRoZSBldmVudCB0YXJnZXQgaXMgY2hlY2tlZCFcblx0XHQvLyBTZWUgaXNzdWUgIzU3OyBhbHNvIGZpbGVkIGFzIHJkYXI6Ly8xMzA0ODU4OSAuXG5cdFx0aWYgKGRldmljZUlzSU9TV2l0aEJhZFRhcmdldCkge1xuXHRcdFx0dG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0Ly8gSW4gY2VydGFpbiBjYXNlcyBhcmd1bWVudHMgb2YgZWxlbWVudEZyb21Qb2ludCBjYW4gYmUgbmVnYXRpdmUsIHNvIHByZXZlbnQgc2V0dGluZyB0YXJnZXRFbGVtZW50IHRvIG51bGxcblx0XHRcdHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCkgfHwgdGFyZ2V0RWxlbWVudDtcblx0XHRcdHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50ID0gdGhpcy50YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHR9XG5cblx0XHR0YXJnZXRUYWdOYW1lID0gdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKHRhcmdldFRhZ05hbWUgPT09ICdsYWJlbCcpIHtcblx0XHRcdGZvckVsZW1lbnQgPSB0aGlzLmZpbmRDb250cm9sKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0aWYgKGZvckVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldEVsZW1lbnQgPSBmb3JFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5uZWVkc0ZvY3VzKHRhcmdldEVsZW1lbnQpKSB7XG5cblx0XHRcdC8vIENhc2UgMTogSWYgdGhlIHRvdWNoIHN0YXJ0ZWQgYSB3aGlsZSBhZ28gKGJlc3QgZ3Vlc3MgaXMgMTAwbXMgYmFzZWQgb24gdGVzdHMgZm9yIGlzc3VlICMzNikgdGhlbiBmb2N1cyB3aWxsIGJlIHRyaWdnZXJlZCBhbnl3YXkuIFJldHVybiBlYXJseSBhbmQgdW5zZXQgdGhlIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZSBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IGNsaWNrIHdpbGwgYmUgYWxsb3dlZCB0aHJvdWdoLlxuXHRcdFx0Ly8gQ2FzZSAyOiBXaXRob3V0IHRoaXMgZXhjZXB0aW9uIGZvciBpbnB1dCBlbGVtZW50cyB0YXBwZWQgd2hlbiB0aGUgZG9jdW1lbnQgaXMgY29udGFpbmVkIGluIGFuIGlmcmFtZSwgdGhlbiBhbnkgaW5wdXR0ZWQgdGV4dCB3b24ndCBiZSB2aXNpYmxlIGV2ZW4gdGhvdWdoIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgdXBkYXRlZCBhcyB0aGUgdXNlciB0eXBlcyAoaXNzdWUgIzM3KS5cblx0XHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdHJhY2tpbmdDbGlja1N0YXJ0KSA+IDEwMCB8fCAoZGV2aWNlSXNJT1MgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICYmIHRhcmdldFRhZ05hbWUgPT09ICdpbnB1dCcpKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblxuXHRcdFx0Ly8gU2VsZWN0IGVsZW1lbnRzIG5lZWQgdGhlIGV2ZW50IHRvIGdvIHRocm91Z2ggb24gaU9TIDQsIG90aGVyd2lzZSB0aGUgc2VsZWN0b3IgbWVudSB3b24ndCBvcGVuLlxuXHRcdFx0Ly8gQWxzbyB0aGlzIGJyZWFrcyBvcGVuaW5nIHNlbGVjdHMgd2hlbiBWb2ljZU92ZXIgaXMgYWN0aXZlIG9uIGlPUzYsIGlPUzcgKGFuZCBwb3NzaWJseSBvdGhlcnMpXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TIHx8IHRhcmdldFRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgcGFyZW50IGxheWVyIHRoYXQgd2FzIHNjcm9sbGVkXG5cdFx0XHQvLyBhbmQgdGhpcyB0YXAgaXMgYmVpbmcgdXNlZCB0byBzdG9wIHRoZSBzY3JvbGxpbmcgKHVzdWFsbHkgaW5pdGlhdGVkIGJ5IGEgZmxpbmcgLSBpc3N1ZSAjNDIpLlxuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0XHRpZiAoc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wICE9PSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgdGhlIGFjdHVhbCBjbGljayBmcm9tIGdvaW5nIHRob3VnaCAtIHVubGVzcyB0aGUgdGFyZ2V0IG5vZGUgaXMgbWFya2VkIGFzIHJlcXVpcmluZ1xuXHRcdC8vIHJlYWwgY2xpY2tzIG9yIGlmIGl0IGlzIGluIHRoZSB3aGl0ZWxpc3QgaW4gd2hpY2ggY2FzZSBvbmx5IG5vbi1wcm9ncmFtbWF0aWMgY2xpY2tzIGFyZSBwZXJtaXR0ZWQuXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGNhbmNlbCwgc3RvcCB0cmFja2luZyB0aGUgY2xpY2suXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgbW91c2UgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbk1vdXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vIElmIGEgdGFyZ2V0IGVsZW1lbnQgd2FzIG5ldmVyIHNldCAoYmVjYXVzZSBhIHRvdWNoIGV2ZW50IHdhcyBuZXZlciBmaXJlZCkgYWxsb3cgdGhlIGV2ZW50XG5cdFx0aWYgKCF0aGlzLnRhcmdldEVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcm9ncmFtbWF0aWNhbGx5IGdlbmVyYXRlZCBldmVudHMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZWxlbWVudCBzaG91bGQgYmUgcGVybWl0dGVkXG5cdFx0aWYgKCFldmVudC5jYW5jZWxhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBEZXJpdmUgYW5kIGNoZWNrIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzZWUgd2hldGhlciB0aGUgbW91c2UgZXZlbnQgbmVlZHMgdG8gYmUgcGVybWl0dGVkO1xuXHRcdC8vIHVubGVzcyBleHBsaWNpdGx5IGVuYWJsZWQsIHByZXZlbnQgbm9uLXRvdWNoIGNsaWNrIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgYWN0aW9ucyxcblx0XHQvLyB0byBwcmV2ZW50IGdob3N0L2RvdWJsZWNsaWNrcy5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0aGlzLnRhcmdldEVsZW1lbnQpIHx8IHRoaXMuY2FuY2VsTmV4dENsaWNrKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgYW55IHVzZXItYWRkZWQgbGlzdGVuZXJzIGRlY2xhcmVkIG9uIEZhc3RDbGljayBlbGVtZW50IGZyb20gYmVpbmcgZmlyZWQuXG5cdFx0XHRpZiAoZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJ0IG9mIHRoZSBoYWNrIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcblx0XHRcdFx0ZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FuY2VsIHRoZSBldmVudFxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1vdXNlIGV2ZW50IGlzIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiBhY3R1YWwgY2xpY2tzLCBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgdG91Y2gtZ2VuZXJhdGVkIGNsaWNrLCBhIGNsaWNrIGFjdGlvbiBvY2N1cnJpbmdcblx0ICogbmF0dXJhbGx5IGFmdGVyIGEgZGVsYXkgYWZ0ZXIgYSB0b3VjaCAod2hpY2ggbmVlZHMgdG8gYmUgY2FuY2VsbGVkIHRvIGF2b2lkIGR1cGxpY2F0aW9uKSwgb3Jcblx0ICogYW4gYWN0dWFsIGNsaWNrIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcGVybWl0dGVkO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3IgYW5vdGhlciBGYXN0Q2xpY2stbGlrZSBsaWJyYXJ5IGRlbGl2ZXJlZCB3aXRoIHRoaXJkLXBhcnR5IGNvZGUgdG8gZmlyZSBhIGNsaWNrIGV2ZW50IGJlZm9yZSBGYXN0Q2xpY2sgZG9lcyAoaXNzdWUgIzQ0KS4gSW4gdGhhdCBjYXNlLCBzZXQgdGhlIGNsaWNrLXRyYWNraW5nIGZsYWcgYmFjayB0byBmYWxzZSBhbmQgcmV0dXJuIGVhcmx5LiBUaGlzIHdpbGwgY2F1c2Ugb25Ub3VjaEVuZCB0byByZXR1cm4gZWFybHkuXG5cdFx0aWYgKHRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmVyeSBvZGQgYmVoYXZpb3Igb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIG5vbi1wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9IaDc2NzMxMy5hc3B4XG5cdFx0aWYgKGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgRmFzdENsaWNrIG9iamVjdFxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHNcblx0ICovXG5cdEZhc3RDbGljay5hdHRhY2ggPSBmdW5jdGlvbihsYXllciwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKTtcblx0fTtcblxuICB3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xufSgpKTtcbiIsIi8qKlxuICogTWljcm9FdmVudCAtIHRvIG1ha2UgYW55IGpzIG9iamVjdCBhbiBldmVudCBlbWl0dGVyIChzZXJ2ZXIgb3IgYnJvd3NlcilcbiAqIFxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG4gKiAtIGRvbnQgcmVseSBvbiB0aGUgYnJvd3NlciBkb21zXG4gKiAtIHN1cGVyIHNpbXBsZSAtIHlvdSBnZXQgaXQgaW1tZWRpYXRlbHksIG5vIG15c3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogLSBjcmVhdGUgYSBNaWNyb0V2ZW50RGVidWcgd2l0aCBnb29kaWVzIHRvIGRlYnVnXG4gKiAgIC0gbWFrZSBpdCBzYWZlciB0byB1c2VcbiovXG5cbi8qKiBOT1RFOiBUaGlzIGxpYnJhcnkgaXMgY3VzdG9taXplZCBmb3IgT25zZW4gVUkuICovXG5cbnZhciBNaWNyb0V2ZW50ICA9IGZ1bmN0aW9uKCl7fTtcbk1pY3JvRXZlbnQucHJvdG90eXBlICA9IHtcbiAgb24gIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuICB9LFxuICBvbmNlIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9mZihldmVudCwgd3JhcHBlcik7XG4gICAgICByZXR1cm4gZmN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLm9uKGV2ZW50LCB3cmFwcGVyKTtcbiAgfSxcbiAgb2ZmICA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xuXG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oX2ZjdCkge1xuICAgICAgICBpZiAoZmN0KSB7XG4gICAgICAgICAgIHJldHVybiBmY3QgIT09IF9mY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSxcbiAgZW1pdCA6IGZ1bmN0aW9uKGV2ZW50IC8qICwgYXJncy4uLiAqLyl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmKCBldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlICApICByZXR1cm47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XVtpXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogbWl4aW4gd2lsbCBkZWxlZ2F0ZSBhbGwgTWljcm9FdmVudC5qcyBmdW5jdGlvbiBpbiB0aGUgZGVzdGluYXRpb24gb2JqZWN0XG4gKlxuICogLSByZXF1aXJlKCdNaWNyb0V2ZW50JykubWl4aW4oRm9vYmFyKSB3aWxsIG1ha2UgRm9vYmFyIGFibGUgdG8gdXNlIE1pY3JvRXZlbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGhlIG9iamVjdCB3aGljaCB3aWxsIHN1cHBvcnQgTWljcm9FdmVudFxuKi9cbk1pY3JvRXZlbnQubWl4aW4gID0gZnVuY3Rpb24oZGVzdE9iamVjdCl7XG4gIHZhciBwcm9wcyA9IFsnb24nLCAnb25jZScsICdvZmYnLCAnZW1pdCddO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICsrKXtcbiAgICBpZiggdHlwZW9mIGRlc3RPYmplY3QgPT09ICdmdW5jdGlvbicgKXtcbiAgICAgIGRlc3RPYmplY3QucHJvdG90eXBlW3Byb3BzW2ldXSAgPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfWVsc2V7XG4gICAgICBkZXN0T2JqZWN0W3Byb3BzW2ldXSA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZXhwb3J0IGluIGNvbW1vbiBqc1xuaWYoIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgKCdleHBvcnRzJyBpbiBtb2R1bGUpKXtcbiAgbW9kdWxlLmV4cG9ydHMgID0gTWljcm9FdmVudDtcbn1cblxud2luZG93Lk1pY3JvRXZlbnQgPSBNaWNyb0V2ZW50O1xuIiwiKGZ1bmN0aW9uIChyb290KSB7XG5cbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBzZXRUaW1lb3V0RnVuYyA9IHNldFRpbWVvdXQ7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFxuICAvLyBQb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlZmVycmVkcyA9IFtdO1xuXG4gICAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICAgIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgICAgc2VsZiA9IHNlbGYuX3ZhbHVlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICAgIHNlbGYuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5faGFuZGxlZCA9IHRydWU7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5fc3RhdGUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlbjtcbiAgICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3Qoc2VsZiwgZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgc2VsZi5fc3RhdGUgPSAyO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuKHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gICAgfVxuICAgIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAgICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gICAqXG4gICAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAgICovXG4gIGZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZWplY3Qoc2VsZiwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICByZWplY3Qoc2VsZiwgZXgpO1xuICAgIH1cbiAgfVxuXG4gIFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbSA9IG5ldyAodGhpcy5jb25zdHJ1Y3Rvcikobm9vcCk7XG5cbiAgICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgICByZXR1cm4gcHJvbTtcbiAgfTtcblxuICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcbiAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoZm4pIHsgc2V0SW1tZWRpYXRlKGZuKTsgfSkgfHxcbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXRGdW5jKGZuLCAwKTtcbiAgICB9O1xuXG4gIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltbWVkaWF0ZSBmdW5jdGlvbiB0byBleGVjdXRlIGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRJbW1lZGlhdGVGbiA9IGZ1bmN0aW9uIF9zZXRJbW1lZGlhdGVGbihmbikge1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gZm47XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4oZm4pIHtcbiAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZuO1xuICB9O1xuXG4gIGlmICghd2luZG93LlByb21pc2UpIHtcbiAgICB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2U7XG4gIH1cbn0pKHRoaXMpO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxMiBCYXJuZXNhbmRub2JsZS5jb20sIGxsYywgRG9uYXZvbiBXZXN0LCBhbmQgRG9tZW5pYyBEZW5pY29sYVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHNlbGYpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcblxuICAgICAgICB0aGlzLlBSRV9JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLklPUzdfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG4gICAgICAgIHRoaXMuREVGQVVMVF9WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcblxuICAgICAgICB0aGlzLmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0ge307XG4gICAgICAgIHRoaXMucGxhdGZvcm0ubmFtZSA9IHRoaXMuZ2V0UGxhdGZvcm1OYW1lKCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0udmVyc2lvbiA9IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5lbnN1cmVWaWV3cG9ydEVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcbiAgICAgICAgaWYoIXRoaXMudmlld3BvcnRFbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQubmFtZSA9IFwidmlld3BvcnRcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3cG9ydEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5vLWFkanVzdCcpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5uYW1lID09ICdpb3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0udmVyc2lvbiA+PSA3ICYmIGlzV2ViVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLkRFRkFVTFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNXZWJWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImFuZHJvaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpb3NcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVua25vd25cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPUyAnKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5OdW1iZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuc3Vic3RyKHN0YXJ0ICsgMywgMykucmVwbGFjZSgnXycsICcuJykpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuVmlld3BvcnQgPSBWaWV3cG9ydDtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBPcGVuIFRlY2hub2xvZ2llcywgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbi8vIEphdmFTY3JpcHQgRHluYW1pYyBDb250ZW50IHNoaW0gZm9yIFdpbmRvd3MgU3RvcmUgYXBwc1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh3aW5kb3cuTVNBcHAgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcblxuICAgICAgICAvLyBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhbiBcImF0dHJpYnV0ZXNcIiBwcm9wZXJ0eSB3aGljaCBzaGFkb3dzIHRoZSBOb2RlLnByb3RvdHlwZS5hdHRyaWJ1dGVzIHByb3BlcnR5XG4gICAgICAgIC8vICBhbmQgbWVhbnMgd2UgZG9uJ3QgYWN0dWFsbHkgc2VlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBOb2RlIChpbnRlcmVzdGluZ2x5IHRoZSBWUyBkZWJ1ZyBjb25zb2xlXG4gICAgICAgIC8vICBhcHBlYXJzIHRvIHN1ZmZlciBmcm9tIHRoZSBzYW1lIGlzc3VlKS5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIEVsZW1lbnRfc2V0QXR0cmlidXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJzZXRBdHRyaWJ1dGVcIikudmFsdWU7XG4gICAgICAgIHZhciBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwicmVtb3ZlQXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIpO1xuICAgICAgICB2YXIgTm9kZV9nZXRfYXR0cmlidXRlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBOb2RlX2dldF9jaGlsZE5vZGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIpLmdldDtcbiAgICAgICAgdmFyIGRldGVjdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfYXR0cmlidXRlcy5jYWxsKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkTm9kZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2NoaWxkTm9kZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEhUTUwoZWxlbWVudCwgcG9zaXRpb24sIGh0bWwpIHtcbiAgICAgICAgICAgIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvci52YWx1ZS5jYWxsKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluVW5zYWZlTW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBpc1Vuc2FmZSA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvbkRpdi5pbm5lckhUTUwgPSBcIjx0ZXN0Lz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlzVW5zYWZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1Vuc2FmZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2UoaHRtbCwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNsZWFuZXIgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJjbGVhbmVyXCIpO1xuICAgICAgICAgICAgZW1wdHkoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50SFRNTChjbGVhbmVyLmRvY3VtZW50RWxlbWVudCwgXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gY2xlYW5lci5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2NyaXB0cywgZnVuY3Rpb24gKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NyaXB0LnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvanNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9saXZlc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwidGV4dC9cIi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJhcHBsaWNhdGlvbi9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwiYXBwbGljYXRpb24vXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhdHRyaWJ1dGVzIGNvbGxlY3Rpb24gaXMgbGl2ZSBpdCBpcyBzaW1wbGVyIHRvIHF1ZXVlIHVwIHRoZSByZW5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5hbWVbMF0gPT09IFwib1wiIHx8IG5hbWVbMF0gPT09IFwiT1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lWzFdID09PSBcIm5cIiB8fCBuYW1lWzFdID09PSBcIk5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyBuYW1lOiBhdHRyaWJ1dGUubmFtZSwgdmFsdWU6IGF0dHJpYnV0ZS52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBcIngtXCIgKyBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZE5vZGVzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgY2xlYW5lZE5vZGVzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCkuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5oZWFkKS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5ib2R5KS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZVByb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2V0dGVyID0gcHJvcGVydHlEZXNjcmlwdG9yLnNldDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5XaW5KUyAmJiB3aW5kb3cuV2luSlMuX2V4ZWNVbnNhZmUgJiYgaW5VbnNhZmVNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY2xlYW5zZSh2YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHByb3BlcnR5RGVzY3JpcHRvciwgdGhhdCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcImlubmVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbXB0eSh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcIm91dGVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0oKSk7IiwiLy8gRm9yIEB3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50c1xuaWYgKHdpbmRvdy5jdXN0b21FbGVtZW50cykgeyAvLyBldmVuIGlmIG5hdGl2ZSBDRTEgaW1wbCBleGlzdHMsIHVzZSBwb2x5ZmlsbFxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsID0gdHJ1ZTtcbn1cbiIsIihmdW5jdGlvbigpe1xuJ3VzZSBzdHJpY3QnO3ZhciBnPW5ldyBmdW5jdGlvbigpe307dmFyIGFhPW5ldyBTZXQoXCJhbm5vdGF0aW9uLXhtbCBjb2xvci1wcm9maWxlIGZvbnQtZmFjZSBmb250LWZhY2Utc3JjIGZvbnQtZmFjZS11cmkgZm9udC1mYWNlLWZvcm1hdCBmb250LWZhY2UtbmFtZSBtaXNzaW5nLWdseXBoXCIuc3BsaXQoXCIgXCIpKTtmdW5jdGlvbiBrKGIpe3ZhciBhPWFhLmhhcyhiKTtiPS9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QoYik7cmV0dXJuIWEmJmJ9ZnVuY3Rpb24gbChiKXt2YXIgYT1iLmlzQ29ubmVjdGVkO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGE7Zm9yKDtiJiYhKGIuX19DRV9pc0ltcG9ydERvY3VtZW50fHxiIGluc3RhbmNlb2YgRG9jdW1lbnQpOyliPWIucGFyZW50Tm9kZXx8KHdpbmRvdy5TaGFkb3dSb290JiZiIGluc3RhbmNlb2YgU2hhZG93Um9vdD9iLmhvc3Q6dm9pZCAwKTtyZXR1cm4hKCFifHwhKGIuX19DRV9pc0ltcG9ydERvY3VtZW50fHxiIGluc3RhbmNlb2YgRG9jdW1lbnQpKX1cbmZ1bmN0aW9uIG0oYixhKXtmb3IoO2EmJmEhPT1iJiYhYS5uZXh0U2libGluZzspYT1hLnBhcmVudE5vZGU7cmV0dXJuIGEmJmEhPT1iP2EubmV4dFNpYmxpbmc6bnVsbH1cbmZ1bmN0aW9uIG4oYixhLGUpe2U9ZT9lOm5ldyBTZXQ7Zm9yKHZhciBjPWI7Yzspe2lmKGMubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGQ9YzthKGQpO3ZhciBoPWQubG9jYWxOYW1lO2lmKFwibGlua1wiPT09aCYmXCJpbXBvcnRcIj09PWQuZ2V0QXR0cmlidXRlKFwicmVsXCIpKXtjPWQuaW1wb3J0O2lmKGMgaW5zdGFuY2VvZiBOb2RlJiYhZS5oYXMoYykpZm9yKGUuYWRkKGMpLGM9Yy5maXJzdENoaWxkO2M7Yz1jLm5leHRTaWJsaW5nKW4oYyxhLGUpO2M9bShiLGQpO2NvbnRpbnVlfWVsc2UgaWYoXCJ0ZW1wbGF0ZVwiPT09aCl7Yz1tKGIsZCk7Y29udGludWV9aWYoZD1kLl9fQ0Vfc2hhZG93Um9vdClmb3IoZD1kLmZpcnN0Q2hpbGQ7ZDtkPWQubmV4dFNpYmxpbmcpbihkLGEsZSl9Yz1jLmZpcnN0Q2hpbGQ/Yy5maXJzdENoaWxkOm0oYixjKX19ZnVuY3Rpb24gcShiLGEsZSl7YlthXT1lfTtmdW5jdGlvbiByKCl7dGhpcy5hPW5ldyBNYXA7dGhpcy5mPW5ldyBNYXA7dGhpcy5jPVtdO3RoaXMuYj0hMX1mdW5jdGlvbiBiYShiLGEsZSl7Yi5hLnNldChhLGUpO2IuZi5zZXQoZS5jb25zdHJ1Y3RvcixlKX1mdW5jdGlvbiB0KGIsYSl7Yi5iPSEwO2IuYy5wdXNoKGEpfWZ1bmN0aW9uIHYoYixhKXtiLmImJm4oYSxmdW5jdGlvbihhKXtyZXR1cm4gdyhiLGEpfSl9ZnVuY3Rpb24gdyhiLGEpe2lmKGIuYiYmIWEuX19DRV9wYXRjaGVkKXthLl9fQ0VfcGF0Y2hlZD0hMDtmb3IodmFyIGU9MDtlPGIuYy5sZW5ndGg7ZSsrKWIuY1tlXShhKX19ZnVuY3Rpb24geChiLGEpe3ZhciBlPVtdO24oYSxmdW5jdGlvbihiKXtyZXR1cm4gZS5wdXNoKGIpfSk7Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyl7dmFyIGM9ZVthXTsxPT09Yy5fX0NFX3N0YXRlP2IuY29ubmVjdGVkQ2FsbGJhY2soYyk6eShiLGMpfX1cbmZ1bmN0aW9uIHooYixhKXt2YXIgZT1bXTtuKGEsZnVuY3Rpb24oYil7cmV0dXJuIGUucHVzaChiKX0pO2ZvcihhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBjPWVbYV07MT09PWMuX19DRV9zdGF0ZSYmYi5kaXNjb25uZWN0ZWRDYWxsYmFjayhjKX19XG5mdW5jdGlvbiBBKGIsYSxlKXtlPWU/ZTpuZXcgU2V0O3ZhciBjPVtdO24oYSxmdW5jdGlvbihkKXtpZihcImxpbmtcIj09PWQubG9jYWxOYW1lJiZcImltcG9ydFwiPT09ZC5nZXRBdHRyaWJ1dGUoXCJyZWxcIikpe3ZhciBhPWQuaW1wb3J0O2EgaW5zdGFuY2VvZiBOb2RlJiZcImNvbXBsZXRlXCI9PT1hLnJlYWR5U3RhdGU/KGEuX19DRV9pc0ltcG9ydERvY3VtZW50PSEwLGEuX19DRV9oYXNSZWdpc3RyeT0hMCk6ZC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5pbXBvcnQ7YS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWR8fChhLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZD0hMCxhLl9fQ0VfaXNJbXBvcnREb2N1bWVudD0hMCxhLl9fQ0VfaGFzUmVnaXN0cnk9ITAsbmV3IFNldChlKSxlLmRlbGV0ZShhKSxBKGIsYSxlKSl9KX1lbHNlIGMucHVzaChkKX0sZSk7aWYoYi5iKWZvcihhPTA7YTxjLmxlbmd0aDthKyspdyhiLGNbYV0pO2ZvcihhPTA7YTxjLmxlbmd0aDthKyspeShiLFxuY1thXSl9XG5mdW5jdGlvbiB5KGIsYSl7aWYodm9pZCAwPT09YS5fX0NFX3N0YXRlKXt2YXIgZT1iLmEuZ2V0KGEubG9jYWxOYW1lKTtpZihlKXtlLmNvbnN0cnVjdGlvblN0YWNrLnB1c2goYSk7dmFyIGM9ZS5jb25zdHJ1Y3Rvcjt0cnl7dHJ5e2lmKG5ldyBjIT09YSl0aHJvdyBFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuXCIpO31maW5hbGx5e2UuY29uc3RydWN0aW9uU3RhY2sucG9wKCl9fWNhdGNoKGYpe3Rocm93IGEuX19DRV9zdGF0ZT0yLGY7fWEuX19DRV9zdGF0ZT0xO2EuX19DRV9kZWZpbml0aW9uPWU7aWYoZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spZm9yKGU9ZS5vYnNlcnZlZEF0dHJpYnV0ZXMsYz0wO2M8ZS5sZW5ndGg7YysrKXt2YXIgZD1lW2NdLGg9YS5nZXRBdHRyaWJ1dGUoZCk7bnVsbCE9PWgmJmIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGEsZCxudWxsLGgsbnVsbCl9bChhKSYmYi5jb25uZWN0ZWRDYWxsYmFjayhhKX19fVxuci5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oYil7dmFyIGE9Yi5fX0NFX2RlZmluaXRpb247YS5jb25uZWN0ZWRDYWxsYmFjayYmYS5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGIpfTtyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbihiKXt2YXIgYT1iLl9fQ0VfZGVmaW5pdGlvbjthLmRpc2Nvbm5lY3RlZENhbGxiYWNrJiZhLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwoYil9O3IucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaz1mdW5jdGlvbihiLGEsZSxjLGQpe3ZhciBoPWIuX19DRV9kZWZpbml0aW9uO2guYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiYtMTxoLm9ic2VydmVkQXR0cmlidXRlcy5pbmRleE9mKGEpJiZoLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKGIsYSxlLGMsZCl9O2Z1bmN0aW9uIEIoYixhKXt0aGlzLmM9Yjt0aGlzLmE9YTt0aGlzLmI9dm9pZCAwO0EodGhpcy5jLHRoaXMuYSk7XCJsb2FkaW5nXCI9PT10aGlzLmEucmVhZHlTdGF0ZSYmKHRoaXMuYj1uZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmYuYmluZCh0aGlzKSksdGhpcy5iLm9ic2VydmUodGhpcy5hLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pKX1mdW5jdGlvbiBDKGIpe2IuYiYmYi5iLmRpc2Nvbm5lY3QoKX1CLnByb3RvdHlwZS5mPWZ1bmN0aW9uKGIpe3ZhciBhPXRoaXMuYS5yZWFkeVN0YXRlO1wiaW50ZXJhY3RpdmVcIiE9PWEmJlwiY29tcGxldGVcIiE9PWF8fEModGhpcyk7Zm9yKGE9MDthPGIubGVuZ3RoO2ErKylmb3IodmFyIGU9YlthXS5hZGRlZE5vZGVzLGM9MDtjPGUubGVuZ3RoO2MrKylBKHRoaXMuYyxlW2NdKX07ZnVuY3Rpb24gY2EoKXt2YXIgYj10aGlzO3RoaXMuYj10aGlzLmE9dm9pZCAwO3RoaXMuYz1uZXcgUHJvbWlzZShmdW5jdGlvbihhKXtiLmI9YTtiLmEmJmEoYi5hKX0pfWZ1bmN0aW9uIEQoYil7aWYoYi5hKXRocm93IEVycm9yKFwiQWxyZWFkeSByZXNvbHZlZC5cIik7Yi5hPXZvaWQgMDtiLmImJmIuYih2b2lkIDApfTtmdW5jdGlvbiBFKGIpe3RoaXMuZj0hMTt0aGlzLmE9Yjt0aGlzLmg9bmV3IE1hcDt0aGlzLmc9ZnVuY3Rpb24oYil7cmV0dXJuIGIoKX07dGhpcy5iPSExO3RoaXMuYz1bXTt0aGlzLmo9bmV3IEIoYixkb2N1bWVudCl9XG5FLnByb3RvdHlwZS5sPWZ1bmN0aW9uKGIsYSl7dmFyIGU9dGhpcztpZighKGEgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBtdXN0IGJlIGZ1bmN0aW9ucy5cIik7aWYoIWsoYikpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIGVsZW1lbnQgbmFtZSAnXCIrYitcIicgaXMgbm90IHZhbGlkLlwiKTtpZih0aGlzLmEuYS5nZXQoYikpdGhyb3cgRXJyb3IoXCJBIGN1c3RvbSBlbGVtZW50IHdpdGggbmFtZSAnXCIrYitcIicgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlwiKTtpZih0aGlzLmYpdGhyb3cgRXJyb3IoXCJBIGN1c3RvbSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgZGVmaW5lZC5cIik7dGhpcy5mPSEwO3ZhciBjLGQsaCxmLHU7dHJ5e3ZhciBwPWZ1bmN0aW9uKGIpe3ZhciBhPVBbYl07aWYodm9pZCAwIT09YSYmIShhIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IEVycm9yKFwiVGhlICdcIitiK1wiJyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xucmV0dXJuIGF9LFA9YS5wcm90b3R5cGU7aWYoIShQIGluc3RhbmNlb2YgT2JqZWN0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIGlzIG5vdCBhbiBvYmplY3QuXCIpO2M9cChcImNvbm5lY3RlZENhbGxiYWNrXCIpO2Q9cChcImRpc2Nvbm5lY3RlZENhbGxiYWNrXCIpO2g9cChcImFkb3B0ZWRDYWxsYmFja1wiKTtmPXAoXCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcIik7dT1hLm9ic2VydmVkQXR0cmlidXRlc3x8W119Y2F0Y2godmEpe3JldHVybn1maW5hbGx5e3RoaXMuZj0hMX1iYSh0aGlzLmEsYix7bG9jYWxOYW1lOmIsY29uc3RydWN0b3I6YSxjb25uZWN0ZWRDYWxsYmFjazpjLGRpc2Nvbm5lY3RlZENhbGxiYWNrOmQsYWRvcHRlZENhbGxiYWNrOmgsYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOmYsb2JzZXJ2ZWRBdHRyaWJ1dGVzOnUsY29uc3RydWN0aW9uU3RhY2s6W119KTt0aGlzLmMucHVzaChiKTt0aGlzLmJ8fCh0aGlzLmI9XG4hMCx0aGlzLmcoZnVuY3Rpb24oKXtpZighMSE9PWUuYilmb3IoZS5iPSExLEEoZS5hLGRvY3VtZW50KTswPGUuYy5sZW5ndGg7KXt2YXIgYj1lLmMuc2hpZnQoKTsoYj1lLmguZ2V0KGIpKSYmRChiKX19KSl9O0UucHJvdG90eXBlLmdldD1mdW5jdGlvbihiKXtpZihiPXRoaXMuYS5hLmdldChiKSlyZXR1cm4gYi5jb25zdHJ1Y3Rvcn07RS5wcm90b3R5cGUubz1mdW5jdGlvbihiKXtpZighayhiKSlyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFN5bnRheEVycm9yKFwiJ1wiK2IrXCInIGlzIG5vdCBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUuXCIpKTt2YXIgYT10aGlzLmguZ2V0KGIpO2lmKGEpcmV0dXJuIGEuYzthPW5ldyBjYTt0aGlzLmguc2V0KGIsYSk7dGhpcy5hLmEuZ2V0KGIpJiYtMT09PXRoaXMuYy5pbmRleE9mKGIpJiZEKGEpO3JldHVybiBhLmN9O0UucHJvdG90eXBlLm09ZnVuY3Rpb24oYil7Qyh0aGlzLmopO3ZhciBhPXRoaXMuZzt0aGlzLmc9ZnVuY3Rpb24oZSl7cmV0dXJuIGIoZnVuY3Rpb24oKXtyZXR1cm4gYShlKX0pfX07XG53aW5kb3cuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5PUU7RS5wcm90b3R5cGUuZGVmaW5lPUUucHJvdG90eXBlLmw7RS5wcm90b3R5cGUuZ2V0PUUucHJvdG90eXBlLmdldDtFLnByb3RvdHlwZS53aGVuRGVmaW5lZD1FLnByb3RvdHlwZS5vO0UucHJvdG90eXBlLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2s9RS5wcm90b3R5cGUubTt2YXIgRj13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQsZGE9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMsZWE9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLGZhPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUucHJlcGVuZCxnYT13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmFwcGVuZCxHPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsSD13aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsST13aW5kb3cuTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLEo9d2luZG93Lk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLEs9d2luZG93Lk5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZCxMPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk5vZGUucHJvdG90eXBlLFwidGV4dENvbnRlbnRcIiksTT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93LE49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsXG5cImlubmVySFRNTFwiKSxPPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsUT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFI9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxTPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyxUPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyxVPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxWPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRBZGphY2VudEVsZW1lbnQsaGE9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQsaWE9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZCxqYT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlLGthPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hZnRlcixsYT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZVdpdGgsbWE9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSxcbm5hPXdpbmRvdy5IVE1MRWxlbWVudCxXPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKSxYPXdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50O2Z1bmN0aW9uIG9hKCl7dmFyIGI9WTt3aW5kb3cuSFRNTEVsZW1lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGE9dGhpcy5jb25zdHJ1Y3RvcixjPWIuZi5nZXQoYSk7aWYoIWMpdGhyb3cgRXJyb3IoXCJUaGUgY3VzdG9tIGVsZW1lbnQgYmVpbmcgY29uc3RydWN0ZWQgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggYGN1c3RvbUVsZW1lbnRzYC5cIik7dmFyIGQ9Yy5jb25zdHJ1Y3Rpb25TdGFjaztpZighZC5sZW5ndGgpcmV0dXJuIGQ9Ri5jYWxsKGRvY3VtZW50LGMubG9jYWxOYW1lKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoZCxhLnByb3RvdHlwZSksZC5fX0NFX3N0YXRlPTEsZC5fX0NFX2RlZmluaXRpb249Yyx3KGIsZCksZDt2YXIgYz1kLmxlbmd0aC0xLGg9ZFtjXTtpZihoPT09Zyl0aHJvdyBFcnJvcihcIlRoZSBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciB3YXMgZWl0aGVyIGNhbGxlZCByZWVudHJhbnRseSBmb3IgdGhpcyBjb25zdHJ1Y3RvciBvciBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXCIpO1xuZFtjXT1nO09iamVjdC5zZXRQcm90b3R5cGVPZihoLGEucHJvdG90eXBlKTt3KGIsaCk7cmV0dXJuIGh9YS5wcm90b3R5cGU9bmEucHJvdG90eXBlO3JldHVybiBhfSgpfTtmdW5jdGlvbiBwYShiLGEsZSl7YS5wcmVwZW5kPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZD1bXSxjPTA7Yzxhcmd1bWVudHMubGVuZ3RoOysrYylkW2MtMF09YXJndW1lbnRzW2NdO2M9ZC5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBOb2RlJiZsKGIpfSk7ZS5pLmFwcGx5KHRoaXMsZCk7Zm9yKHZhciBmPTA7ZjxjLmxlbmd0aDtmKyspeihiLGNbZl0pO2lmKGwodGhpcykpZm9yKGM9MDtjPGQubGVuZ3RoO2MrKylmPWRbY10sZiBpbnN0YW5jZW9mIEVsZW1lbnQmJngoYixmKX07YS5hcHBlbmQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBkPVtdLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7KytjKWRbYy0wXT1hcmd1bWVudHNbY107Yz1kLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIE5vZGUmJmwoYil9KTtlLmFwcGVuZC5hcHBseSh0aGlzLGQpO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKXooYixjW2ZdKTtpZihsKHRoaXMpKWZvcihjPTA7YzxcbmQubGVuZ3RoO2MrKylmPWRbY10sZiBpbnN0YW5jZW9mIEVsZW1lbnQmJngoYixmKX19O2Z1bmN0aW9uIHFhKCl7dmFyIGI9WTtxKERvY3VtZW50LnByb3RvdHlwZSxcImNyZWF0ZUVsZW1lbnRcIixmdW5jdGlvbihhKXtpZih0aGlzLl9fQ0VfaGFzUmVnaXN0cnkpe3ZhciBlPWIuYS5nZXQoYSk7aWYoZSlyZXR1cm4gbmV3IGUuY29uc3RydWN0b3J9YT1GLmNhbGwodGhpcyxhKTt3KGIsYSk7cmV0dXJuIGF9KTtxKERvY3VtZW50LnByb3RvdHlwZSxcImltcG9ydE5vZGVcIixmdW5jdGlvbihhLGUpe2E9ZWEuY2FsbCh0aGlzLGEsZSk7dGhpcy5fX0NFX2hhc1JlZ2lzdHJ5P0EoYixhKTp2KGIsYSk7cmV0dXJuIGF9KTtxKERvY3VtZW50LnByb3RvdHlwZSxcImNyZWF0ZUVsZW1lbnROU1wiLGZ1bmN0aW9uKGEsZSl7aWYodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5JiYobnVsbD09PWF8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YSkpe3ZhciBjPWIuYS5nZXQoZSk7aWYoYylyZXR1cm4gbmV3IGMuY29uc3RydWN0b3J9YT1kYS5jYWxsKHRoaXMsYSxlKTt3KGIsYSk7cmV0dXJuIGF9KTtcbnBhKGIsRG9jdW1lbnQucHJvdG90eXBlLHtpOmZhLGFwcGVuZDpnYX0pfTtmdW5jdGlvbiByYSgpe3ZhciBiPVk7ZnVuY3Rpb24gYShhLGMpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwidGV4dENvbnRlbnRcIix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpjLmdldCxzZXQ6ZnVuY3Rpb24oYSl7aWYodGhpcy5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFKWMuc2V0LmNhbGwodGhpcyxhKTtlbHNle3ZhciBkPXZvaWQgMDtpZih0aGlzLmZpcnN0Q2hpbGQpe3ZhciBlPXRoaXMuY2hpbGROb2Rlcyx1PWUubGVuZ3RoO2lmKDA8dSYmbCh0aGlzKSlmb3IodmFyIGQ9QXJyYXkodSkscD0wO3A8dTtwKyspZFtwXT1lW3BdfWMuc2V0LmNhbGwodGhpcyxhKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspeihiLGRbYV0pfX19KX1xKE5vZGUucHJvdG90eXBlLFwiaW5zZXJ0QmVmb3JlXCIsZnVuY3Rpb24oYSxjKXtpZihhIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGEuY2hpbGROb2Rlcyk7XG5hPUkuY2FsbCh0aGlzLGEsYyk7aWYobCh0aGlzKSlmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKXgoYixkW2NdKTtyZXR1cm4gYX1kPWwoYSk7Yz1JLmNhbGwodGhpcyxhLGMpO2QmJnooYixhKTtsKHRoaXMpJiZ4KGIsYSk7cmV0dXJuIGN9KTtxKE5vZGUucHJvdG90eXBlLFwiYXBwZW5kQ2hpbGRcIixmdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGEuY2hpbGROb2Rlcyk7YT1ILmNhbGwodGhpcyxhKTtpZihsKHRoaXMpKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXgoYixjW2RdKTtyZXR1cm4gYX1jPWwoYSk7ZD1ILmNhbGwodGhpcyxhKTtjJiZ6KGIsYSk7bCh0aGlzKSYmeChiLGEpO3JldHVybiBkfSk7cShOb2RlLnByb3RvdHlwZSxcImNsb25lTm9kZVwiLGZ1bmN0aW9uKGEpe2E9Ry5jYWxsKHRoaXMsYSk7dGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnk/QShiLGEpOnYoYixhKTtcbnJldHVybiBhfSk7cShOb2RlLnByb3RvdHlwZSxcInJlbW92ZUNoaWxkXCIsZnVuY3Rpb24oYSl7dmFyIGM9bChhKSxkPUouY2FsbCh0aGlzLGEpO2MmJnooYixhKTtyZXR1cm4gZH0pO3EoTm9kZS5wcm90b3R5cGUsXCJyZXBsYWNlQ2hpbGRcIixmdW5jdGlvbihhLGMpe2lmKGEgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYS5jaGlsZE5vZGVzKTthPUsuY2FsbCh0aGlzLGEsYyk7aWYobCh0aGlzKSlmb3IoeihiLGMpLGM9MDtjPGQubGVuZ3RoO2MrKyl4KGIsZFtjXSk7cmV0dXJuIGF9dmFyIGQ9bChhKSxlPUsuY2FsbCh0aGlzLGEsYyksZj1sKHRoaXMpO2YmJnooYixjKTtkJiZ6KGIsYSk7ZiYmeChiLGEpO3JldHVybiBlfSk7TCYmTC5nZXQ/YShOb2RlLnByb3RvdHlwZSxMKTp0KGIsZnVuY3Rpb24oYil7YShiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9W10sYj1cbjA7Yjx0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO2IrKylhLnB1c2godGhpcy5jaGlsZE5vZGVzW2JdLnRleHRDb250ZW50KTtyZXR1cm4gYS5qb2luKFwiXCIpfSxzZXQ6ZnVuY3Rpb24oYSl7Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KUouY2FsbCh0aGlzLHRoaXMuZmlyc3RDaGlsZCk7SC5jYWxsKHRoaXMsZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSkpfX0pfSl9O2Z1bmN0aW9uIHNhKGIpe3ZhciBhPUVsZW1lbnQucHJvdG90eXBlO2EuYmVmb3JlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhcmd1bWVudHMubGVuZ3RoOysrZCljW2QtMF09YXJndW1lbnRzW2RdO2Q9Yy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBOb2RlJiZsKGEpfSk7amEuYXBwbHkodGhpcyxjKTtmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyl6KGIsZFtlXSk7aWYobCh0aGlzKSlmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWU9Y1tkXSxlIGluc3RhbmNlb2YgRWxlbWVudCYmeChiLGUpfTthLmFmdGVyPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhcmd1bWVudHMubGVuZ3RoOysrZCljW2QtMF09YXJndW1lbnRzW2RdO2Q9Yy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBOb2RlJiZsKGEpfSk7a2EuYXBwbHkodGhpcyxjKTtmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyl6KGIsZFtlXSk7aWYobCh0aGlzKSlmb3IoZD1cbjA7ZDxjLmxlbmd0aDtkKyspZT1jW2RdLGUgaW5zdGFuY2VvZiBFbGVtZW50JiZ4KGIsZSl9O2EucmVwbGFjZVdpdGg9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPVtdLGQ9MDtkPGFyZ3VtZW50cy5sZW5ndGg7KytkKWNbZC0wXT1hcmd1bWVudHNbZF07dmFyIGQ9Yy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBOb2RlJiZsKGEpfSksZT1sKHRoaXMpO2xhLmFwcGx5KHRoaXMsYyk7Zm9yKHZhciBmPTA7ZjxkLmxlbmd0aDtmKyspeihiLGRbZl0pO2lmKGUpZm9yKHooYix0aGlzKSxkPTA7ZDxjLmxlbmd0aDtkKyspZT1jW2RdLGUgaW5zdGFuY2VvZiBFbGVtZW50JiZ4KGIsZSl9O2EucmVtb3ZlPWZ1bmN0aW9uKCl7dmFyIGE9bCh0aGlzKTttYS5jYWxsKHRoaXMpO2EmJnooYix0aGlzKX19O2Z1bmN0aW9uIHRhKCl7dmFyIGI9WTtmdW5jdGlvbiBhKGEsYyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJpbm5lckhUTUxcIix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpjLmdldCxzZXQ6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcyxlPXZvaWQgMDtsKHRoaXMpJiYoZT1bXSxuKHRoaXMsZnVuY3Rpb24oYSl7YSE9PWQmJmUucHVzaChhKX0pKTtjLnNldC5jYWxsKHRoaXMsYSk7aWYoZSlmb3IodmFyIGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGg9ZVtmXTsxPT09aC5fX0NFX3N0YXRlJiZiLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGgpfXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5P0EoYix0aGlzKTp2KGIsdGhpcyk7cmV0dXJuIGF9fSl9ZnVuY3Rpb24gZShhLGMpe3EoYSxcImluc2VydEFkamFjZW50RWxlbWVudFwiLGZ1bmN0aW9uKGEsZCl7dmFyIGU9bChkKTthPWMuY2FsbCh0aGlzLGEsZCk7ZSYmeihiLGQpO2woYSkmJngoYixkKTtcbnJldHVybiBhfSl9TT9xKEVsZW1lbnQucHJvdG90eXBlLFwiYXR0YWNoU2hhZG93XCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX19DRV9zaGFkb3dSb290PWE9TS5jYWxsKHRoaXMsYSl9KTpjb25zb2xlLndhcm4oXCJDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2F0dGFjaFNoYWRvd2Agd2FzIG5vdCBwYXRjaGVkLlwiKTtpZihOJiZOLmdldClhKEVsZW1lbnQucHJvdG90eXBlLE4pO2Vsc2UgaWYoVyYmVy5nZXQpYShIVE1MRWxlbWVudC5wcm90b3R5cGUsVyk7ZWxzZXt2YXIgYz1GLmNhbGwoZG9jdW1lbnQsXCJkaXZcIik7dChiLGZ1bmN0aW9uKGIpe2EoYix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEcuY2FsbCh0aGlzLCEwKS5pbm5lckhUTUx9LHNldDpmdW5jdGlvbihhKXt2YXIgYj1cInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT90aGlzLmNvbnRlbnQ6dGhpcztmb3IoYy5pbm5lckhUTUw9YTswPGIuY2hpbGROb2Rlcy5sZW5ndGg7KUouY2FsbChiLFxuYi5jaGlsZE5vZGVzWzBdKTtmb3IoOzA8Yy5jaGlsZE5vZGVzLmxlbmd0aDspSC5jYWxsKGIsYy5jaGlsZE5vZGVzWzBdKX19KX0pfXEoRWxlbWVudC5wcm90b3R5cGUsXCJzZXRBdHRyaWJ1dGVcIixmdW5jdGlvbihhLGMpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIFEuY2FsbCh0aGlzLGEsYyk7dmFyIGQ9Ty5jYWxsKHRoaXMsYSk7US5jYWxsKHRoaXMsYSxjKTtjPU8uY2FsbCh0aGlzLGEpO2QhPT1jJiZiLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGEsZCxjLG51bGwpfSk7cShFbGVtZW50LnByb3RvdHlwZSxcInNldEF0dHJpYnV0ZU5TXCIsZnVuY3Rpb24oYSxjLGUpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIFQuY2FsbCh0aGlzLGEsYyxlKTt2YXIgZD1TLmNhbGwodGhpcyxhLGMpO1QuY2FsbCh0aGlzLGEsYyxlKTtlPVMuY2FsbCh0aGlzLGEsYyk7ZCE9PWUmJmIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYyxkLGUsYSl9KTtxKEVsZW1lbnQucHJvdG90eXBlLFxuXCJyZW1vdmVBdHRyaWJ1dGVcIixmdW5jdGlvbihhKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBSLmNhbGwodGhpcyxhKTt2YXIgYz1PLmNhbGwodGhpcyxhKTtSLmNhbGwodGhpcyxhKTtudWxsIT09YyYmYi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxhLGMsbnVsbCxudWxsKX0pO3EoRWxlbWVudC5wcm90b3R5cGUsXCJyZW1vdmVBdHRyaWJ1dGVOU1wiLGZ1bmN0aW9uKGEsYyl7aWYoMSE9PXRoaXMuX19DRV9zdGF0ZSlyZXR1cm4gVS5jYWxsKHRoaXMsYSxjKTt2YXIgZD1TLmNhbGwodGhpcyxhLGMpO1UuY2FsbCh0aGlzLGEsYyk7dmFyIGU9Uy5jYWxsKHRoaXMsYSxjKTtkIT09ZSYmYi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxjLGQsZSxhKX0pO1g/ZShIVE1MRWxlbWVudC5wcm90b3R5cGUsWCk6Vj9lKEVsZW1lbnQucHJvdG90eXBlLFYpOmNvbnNvbGUud2FybihcIkN1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuXCIpO1xucGEoYixFbGVtZW50LnByb3RvdHlwZSx7aTpoYSxhcHBlbmQ6aWF9KTtzYShiKX07LypcblxuIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbnZhciBaPXdpbmRvdy5jdXN0b21FbGVtZW50cztpZighWnx8Wi5mb3JjZVBvbHlmaWxsfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBaLmRlZmluZXx8XCJmdW5jdGlvblwiIT10eXBlb2YgWi5nZXQpe3ZhciBZPW5ldyByO29hKCk7cWEoKTtyYSgpO3RhKCk7ZG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT0hMDt2YXIgdWE9bmV3IEUoWSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdyxcImN1c3RvbUVsZW1lbnRzXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnVhfSl9O1xufSkuY2FsbChzZWxmKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWVsZW1lbnRzLm1pbi5qcy5tYXBcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFNSQyAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKVxuICAsIFRPX1NUUklORyA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddXG4gICwgVFBMICAgICAgID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIGtleSwgdmFsLCBzYWZlKXtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZihPW2tleV0gPT09IHZhbClyZXR1cm47XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmKE8gPT09IGdsb2JhbCl7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGlmKCFzYWZlKXtcbiAgICAgIGRlbGV0ZSBPW2tleV07XG4gICAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoT1trZXldKU9ba2V5XSA9IHZhbDtcbiAgICAgIGVsc2UgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfVxuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KVxuICAgICwga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldClyZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KWV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTsiLCIvLyBDYXV0aW9uOlxuLy8gRG8gbm90IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMuXG4vL1xuLy8gSWYgeW91IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMsXG4vLyB0aGUgY29kZXMgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgZm9sbG93aW5nIHBvbHlmaWxscyBhcmUgaW1wb3J0ZWRcbi8vIGJlY2F1c2UgaW1wb3J0IHN0YXRlbWVudHMgYXJlIGhvaXN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLlxuaW1wb3J0ICcuL3BvbHlmaWxsLXN3aXRjaGVzJztcblxuLy8gUG9seWZpbGwgQ3VzdG9tIEVsZW1lbnRzIHYxIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzJztcblxuLy8gUG9seWZpbGwgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mJztcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZWxlY3RcbiAgICogQHNpZ25hdHVyZSBzZWxlY3QocGxhdGZvcm0pXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGxhdGZvcm0gTmFtZSBvZiB0aGUgcGxhdGZvcm0uXG4gICAqICAgW2VuXVBvc3NpYmxlIHZhbHVlcyBhcmU6IFwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiIG9yIFwid3BcIi5bL2VuXVxuICAgKiAgIFtqYV1cIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiwgXCJ3cFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldHMgdGhlIHBsYXRmb3JtIHVzZWQgdG8gcmVuZGVyIHRoZSBlbGVtZW50cy4gVXNlZnVsIGZvciB0ZXN0aW5nLlsvZW5dXG4gICAqICAgW2phXeimgee0oOOCkuaPj+eUu+OBmeOCi+OBn+OCgeOBq+WIqeeUqOOBmeOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOWQjeOCkuioreWumuOBl+OBvuOBmeOAguODhuOCueODiOOBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuICBzZWxlY3QocGxhdGZvcm0pIHtcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAgICogICBbamFdQ29yZG92YeWGheOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dlYlZpZXcoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1dlYlZpZXcoKSBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIGRvbSBjb250ZW50cyBsb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpb3MnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYW5kcm9pZCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnd3AnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL1dpbjMyTlR8V2luQ0UvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9zIGlzSVBob25lXG4gICAqIEBzaWduYXR1cmUgaXNJUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lLlsvZW5dXG4gICAqICAgW2phXWlQaG9uZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lQYWRcbiAgICogQHNpZ25hdHVyZSBpc0lQYWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBhZC5bL2VuXVxuICAgKiAgIFtqYV1pUGFk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBhZCgpIHtcbiAgICByZXR1cm4gL2lQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQb2QoKSB7XG4gICAgcmV0dXJuIC9pUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQmxhY2tCZXJyeVxuICAgKiBAc2lnbmF0dXJlIGlzQmxhY2tCZXJyeSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBCbGFja0JlcnJ5LlsvZW5dXG4gICAqICAgW2phXUJsYWNrQmVycnnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNCbGFja0JlcnJ5KCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYmxhY2tiZXJyeSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5fFJJTSBUYWJsZXQgT1N8QkIxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLlsvZW5dXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT3BlcmEoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdvcGVyYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxuICAgKiBAc2lnbmF0dXJlIGlzRmlyZWZveCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2ZpcmVmb3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTYWZhcmkoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdzYWZhcmknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwKSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2FmYXJpUmVtb3RlTm90aWZpY2F0aW9uXScgfSkoIXdpbmRvd1snc2FmYXJpJ10gfHwgc2FmYXJpLnB1c2hOb3RpZmljYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQ2hyb21lXG4gICAqIEBzaWduYXR1cmUgaXNDaHJvbWUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9tZS5bL2VuXVxuICAgKiAgIFtqYV1DaHJvbWXkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNDaHJvbWUoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdjaHJvbWUnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCEhd2luZG93LmNocm9tZSAmJiAhKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKSAmJiAhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSUVcbiAgICogQHNpZ25hdHVyZSBpc0lFKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3Jlci5bL2VuXVxuICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lFKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnaWUnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2UgfHwgISFkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNFZGdlXG4gICAqIEBzaWduYXR1cmUgaXNFZGdlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBFZGdlLlsvZW5dXG4gICAqICAgW2phXUVkZ2XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNFZGdlKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnZWRnZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1M3YWJvdmVcbiAgICogQHNpZ25hdHVyZSBpc0lPUzdhYm92ZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGlPUyB2ZXJzaW9uIGlzIDcgb3IgYWJvdmUuWy9lbl1cbiAgICogICBbamFdaU9TN+S7peS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUzdhYm92ZSgpIHtcbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gKC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkgJiYgKHBhcnNlSW50KGRldmljZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pID49IDcpKTtcbiAgICB9IGVsc2UgaWYoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zdCB2ZXIgPSAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFxiWzAtOV0rX1swLTldKyg/Ol9bMC05XSspP1xcYi8pIHx8IFsnJ10pWzBdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgIHJldHVybiAocGFyc2VJbnQodmVyLnNwbGl0KCcuJylbMF0pID49IDcpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TW9iaWxlT1MoKSB7XG4gICAgaWYgKHRoaXMuaXNBbmRyb2lkKCkpIHtcbiAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJT1MoKSkge1xuICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzV1AoKSkge1xuICAgICAgcmV0dXJuICd3cCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldElPU0RldmljZSgpIHtcbiAgICBpZiAodGhpcy5pc0lQaG9uZSgpKSB7XG4gICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUGFkKCkpIHtcbiAgICAgIHJldHVybiAnaXBhZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUG9kKCkpIHtcbiAgICAgIHJldHVybiAnaXBvZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICduYSc7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFBsYXRmb3JtKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgY29uc3QgcmUgPSAvXlxcJHsoLio/KX0kLyxcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCByZXR1cm4gYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmludGVybmFsLmNvbmZpZyA9IHtcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2UsXG4gIHdhcm5pbmdzRGlzYWJsZWQ6IGZhbHNlXG59O1xuXG5pbnRlcm5hbC5udWxsRWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5pbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgcmV0dXJuICEhaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5pbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCA9IGh0bWwgPT4ge1xuICBodG1sID0gKCcnICsgaHRtbCkudHJpbSgpO1xuXG4gIGlmICghaHRtbC5tYXRjaCgvXjxvbnMtcGFnZS8pKSB7XG4gICAgaHRtbCA9ICc8b25zLXBhZ2UgX211dGVkPicgKyBodG1sICsgJzwvb25zLXBhZ2U+JztcbiAgfVxuXG4gIHJldHVybiBodG1sO1xufTtcblxuaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsID0gYWN0aW9uID0+IHtcbiAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhcigpKSB7XG4gICAgICBhY3Rpb24oKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgb25SZWFkeSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgfSBlbHNlIGlmIChbJ2NvbXBsZXRlJywgJ2ludGVyYWN0aXZlJ10uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA9PT0gLTEpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBvblJlYWR5KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb25SZWFkeSgpO1xuICB9XG59O1xuXG5pbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyID0gKCkgPT4gaW50ZXJuYWwuaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwoKSAmJiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSAmJiBwbGF0Zm9ybS5pc0lPUzdhYm92ZSgpO1xuXG5pbnRlcm5hbC50ZW1wbGF0ZVN0b3JlID0ge1xuICBfc3RvcmFnZToge30sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0KGtleSwgdGVtcGxhdGUpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gPSB0ZW1wbGF0ZTtcbiAgfVxufTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ190ZW1wbGF0ZWxvYWRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGVtcGxhdGUnKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQoZS50ZW1wbGF0ZUlkLCBlLnRlbXBsYXRlKTtcbiAgfVxufSwgZmFsc2UpO1xuXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L29ucy10ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L3RlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIl0nKTtcblxuICBmdW5jdGlvbiByZWdpc3RlcihxdWVyeSkge1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQodGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgdGVtcGxhdGVzW2ldLnRleHRDb250ZW50KTtcbiAgICB9XG4gIH1cbn0sIGZhbHNlKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5nZXQocGFnZSk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjb25zdCBodG1sID0gdHlwZW9mIGNhY2hlID09PSAnc3RyaW5nJyA/IGNhY2hlIDogY2FjaGVbMV07XG4gICAgICAgIHJlc29sdmUoaHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBjb25zdCBodG1sID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICAgICAgcmVqZWN0KGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhZ2UgaXMgbm90IGZvdW5kOiAke3BhZ2V9YCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIGNvbnN0IHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XG5cbiAgY29uc3QgZ2V0UGFnZSA9IChwYWdlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNdXN0IHNwZWNpZnkgYSBwYWdlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyhwYWdlKVxuICAgICAgLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHBhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnRoZW4oaHRtbCA9PiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKSk7XG4gIH07XG5cbiAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL2ludGVybmFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JGYWN0b3J5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYW5pbWF0b3JzIFRoZSBkaWN0aW9uYXJ5IGZvciBhbmltYXRvciBjbGFzc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuYmFzZUNsYXNzIFRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuYmFzZUNsYXNzTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnNdIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JzID0gb3B0cy5hbmltYXRvcnM7XG4gICAgdGhpcy5fYmFzZUNsYXNzID0gb3B0cy5iYXNlQ2xhc3M7XG4gICAgdGhpcy5fYmFzZUNsYXNzTmFtZSA9IG9wdHMuYmFzZUNsYXNzTmFtZSB8fCBvcHRzLmJhc2VDbGFzcy5uYW1lO1xuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbiB8fCAnZGVmYXVsdCc7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIXRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggYW5pbWF0aW9uOiAnICsgdGhpcy5fYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0L251bGx9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKGpzb25TdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dIFRoZSBhbmltYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc10gVGhlIGFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0QW5pbWF0b3IgVGhlIGRlZmF1bHQgYW5pbWF0b3IgaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBhbmltYXRvciBpbnN0YW5jZVxuICAgKi9cbiAgbmV3QW5pbWF0b3Iob3B0aW9ucyA9IHt9LCBkZWZhdWx0QW5pbWF0b3IpIHtcblxuICAgIGxldCBhbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgQW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JzW29wdGlvbnMuYW5pbWF0aW9uXTtcbiAgICB9XG5cbiAgICBpZiAoIUFuaW1hdG9yICYmIGRlZmF1bHRBbmltYXRvcikge1xuICAgICAgYW5pbWF0b3IgPSBkZWZhdWx0QW5pbWF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFuaW1hdG9yID0gQW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl07XG5cbiAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA/IHtkdXJhdGlvbjogMCwgZGVsYXk6IDB9IDoge31cbiAgICAgICk7XG5cbiAgICAgIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGFuaW1hdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFuaW1hdG9yID0gbmV3IGFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShhbmltYXRvciBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJhbmltYXRvclwiIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiAnICsgdGhpcy5fYmFzZUNsYXNzTmFtZSArICcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdG9yO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LmFkZChrbGFzcykpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBjbGFzc0xpc3QucmVtb3ZlKGtsYXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3IgaW4gc2NoZW1lKSB7XG4gICAgICBpZiAoc2NoZW1lLmhhc093blByb3BlcnR5KHNlbGVjdG9yKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCB1dGlsLm1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKSA/IFtlbGVtZW50XSA6IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgdGFyZ2V0RWxlbWVudHNbaV0uY2xhc3NMaXN0LCBzY2hlbWVbc2VsZWN0b3JdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBvbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICByZXR1cm4gTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xuICAgICAgcmVtb3ZlZDogW10sXG4gICAgICBhZGRlZDogTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKVxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllci50cmltKCkuc3BsaXQoLyArLykuZmlsdGVyKHRva2VuID0+IHRva2VuICE9PSAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG1vZGlmaWVyIHRva2VuIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICBzdGF0aWMgYWRkTW9kaWZpZXIoZWxlbWVudCwgbW9kaWZpZXJUb2tlbikge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG1vZGlmaWVyVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgaWYgKHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pID09IC0xKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCB0b2tlbnMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG1vZGlmaWVyIHRva2VuIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyByZW1vdmVNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgY29uc3QgaW5kZXggPSB0b2tlbnMuaW5kZXhPZihtb2RpZmllclRva2VuKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcblxuICBjb25zdHJ1Y3Rvcih1c2VyRGVsZWdhdGUsIHRlbXBsYXRlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWxlZ2F0ZSAhPT0gJ29iamVjdCcgfHwgdXNlckRlbGVnYXRlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJkZWxlZ2F0ZVwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdXNlckRlbGVnYXRlO1xuXG4gICAgaWYgKCEodGVtcGxhdGVFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkgJiYgdGVtcGxhdGVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJ0ZW1wbGF0ZUVsZW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50IG9yIG51bGwuJyk7XG4gICAgfVxuICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRlbXBsYXRlRWxlbWVudDtcbiAgfVxuXG4gIGdldCBpdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuaXRlbUhlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzUmVuZGVyRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5fcmVuZGVyIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIF9yZW5kZXIoKSB7XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIuYXBwbHkodGhpcy5fdXNlckRlbGVnYXRlLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIEEgZnVuY3Rpb24gdGhhdCB0YWtlIGl0ZW0gb2JqZWN0IGFzIHBhcmFtZXRlci5cbiAgICovXG4gIGxvYWRJdGVtRWxlbWVudChpbmRleCwgZG9uZSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNyZWF0ZUl0ZW1Db250ZW50KGluZGV4LCB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjcmVhdGVJdGVtQ29udGVudCgpIG11c3QgcmV0dXJuIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUoe2VsZW1lbnR9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY291bnRJdGVtcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VudEl0ZW1zKCkgbXVzdCByZXR1cm4gYSBudW1iZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBpdGVtLmVsZW1lbnRcbiAgICovXG4gIHVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS51cGRhdGVJdGVtQ29udGVudChpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoaW5kZXgpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaW5kZXgpO1xuXG4gICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NhbGN1bGF0ZUl0ZW1IZWlnaHQoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICovXG4gIGRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlIGNvcmUgZnVuY3Rpb25zIGZvciBvbnMtbGF6eS1yZXBlYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0UHJvdmlkZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHdyYXBwZXJFbGVtZW50XG4gICAqIEBwYXJhbSB7TGF6eVJlcGVhdERlbGVnYXRlfSBkZWxlZ2F0ZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgaWYgKCEoZGVsZWdhdGUgaW5zdGFuY2VvZiBMYXp5UmVwZWF0RGVsZWdhdGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJkZWxlZ2F0ZVwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIExhenlSZXBlYXREZWxlZ2F0ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IHdyYXBwZXJFbGVtZW50O1xuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5faW5zZXJ0SW5kZXggPSAodGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0gJiYgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ09OUy1MQVpZLVJFUEVBVCcpID8gMSA6IDA7XG5cbiAgICBpZiAod3JhcHBlckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QnKSB7XG4gICAgICB3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYXp5LWxpc3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudCA9IHRoaXMuX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbnMtbGF6eS1yZXBlYXQgbXVzdCBiZSBhIGRlc2NlbmRhbnQgb2YgYW4gPG9ucy1wYWdlPiBvciBhbiBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMuX3RvcFBvc2l0aW9ucyA9IFswXTtcbiAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XG5cbiAgICBpZiAoIXRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgJiYgIXRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoMCkpIHtcbiAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCwgMTApO1xuICB9XG5cbiAgc2V0IHBhZGRpbmcobmV3VmFsdWUpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gbmV3VmFsdWUgKyAncHgnO1xuICB9XG5cbiAgX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpIHtcbiAgICBjb25zdCBwYWdlQ29udGVudCA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICBpZiAocGFnZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBwYWdlQ29udGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHBhZ2UsICcuY29udGVudCcpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfY2hlY2tJdGVtSGVpZ2h0KGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KDAsIGl0ZW0gPT4ge1xuICAgICAgaWYgKCF0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtLmVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbSgwLCBpdGVtKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID4gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0cnkgdG8gbWVhc3VyZSBvZmZzZXQgaGVpZ2h0XG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGFuZ3VsYXIyIGRpcmVjdGl2ZVxuICAgICAgY29uc3QgbGFzdFZpc2liaWxpdHkgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBzdGF0ZTogdGhpcy5faXRlbUhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBsYXN0VmlzaWJpbGl0eTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc3RhdGljSXRlbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCB8fCB0aGlzLl9pdGVtSGVpZ2h0O1xuICB9XG4gIF9jb3VudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gIH1cblxuICBfZ2V0SXRlbUhlaWdodChpKSB7XG4gICAgLy8gSXRlbSBpcyByZW5kZXJlZFxuICAgIGlmICh0aGlzLl9yZW5kZXJlZEl0ZW1zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGVpZ2h0ID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBJdGVtIGlzIG5vdCByZW5kZXJlZCwgc2Nyb2xsIHVwXG4gICAgaWYgKHRoaXMuX3RvcFBvc2l0aW9uc1tpICsgMV0gJiYgdGhpcy5fdG9wUG9zaXRpb25zW2ldKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSAtIHRoaXMuX3RvcFBvc2l0aW9uc1tpXTtcbiAgICB9XG4gICAgLy8gSXRlbSBpcyBub3QgcmVuZGVyZWQsIHNjcm9sbCBkb3duXG4gICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZVJlbmRlcmVkSGVpZ2h0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KCsoYikpLCAwKVxuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG5cbiAgX2xhc3RJdGVtUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLk9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpKVxuICB9XG5cbiAgX2ZpcnN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSlcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IE1hdGgubWluKHRoaXMuX2xhc3RJdGVtUmVuZGVyZWQoKSwgdGhpcy5fY291bnRJdGVtcygpIC0gMSk7XG4gICAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSB0aGlzLl9maXJzdEl0ZW1SZW5kZXJlZCgpO1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tmaXJzdEl0ZW1JbmRleF0gKyB0aGlzLl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCgpICsgJ3B4JztcbiAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbZmlyc3RJdGVtSW5kZXhdO1xuICAgIHRoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XG4gICAgdGhpcy5fcmVuZGVyKHtmb3JjZVNjcm9sbERvd246IHRydWUsIGZvcmNlRmlyc3RJbmRleDogZmlyc3RJdGVtSW5kZXgsIGZvcmNlTGFzdEluZGV4OiBsYXN0SXRlbUluZGV4fSk7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICB9XG5cbiAgX3JlbmRlcih7Zm9yY2VTY3JvbGxEb3duID0gZmFsc2UsIGZvcmNlRmlyc3RJbmRleCwgZm9yY2VMYXN0SW5kZXh9ID0ge30pIHtcbiAgICBpZiAodGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcywgYXJndW1lbnRzWzBdKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNTY3JvbGxVcCA9ICFmb3JjZVNjcm9sbERvd24gJiYgdGhpcy5sYXN0U2Nyb2xsVG9wID4gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBrZWVwID0ge307XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgY29uc3QgbGltaXQgPSA0ICogd2luZG93LmlubmVySGVpZ2h0IC0gb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRJdGVtcygpO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZvcmNlRmlyc3RJbmRleCB8fCBNYXRoLm1heCgwLCB0aGlzLl9jYWxjdWxhdGVTdGFydEluZGV4KG9mZnNldCkgLSAzMCk7XG4gICAgbGV0IGkgPSBzdGFydDtcblxuICAgIGZvcihsZXQgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKHN0YXJ0LCBpLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tzdGFydF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAga2VlcFtqXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaiwgaXNTY3JvbGxVcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcmNlTGFzdEluZGV4IHx8IE1hdGgubWF4KGkgLSAxLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gICAgICBmb3IgKGxldCBqID0gc3RhcnQ7IGogPD0gbGFzdEluZGV4OyBqKyspIHtcbiAgICAgICAga2VlcFtqXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaiwgaXNTY3JvbGxVcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4ga2VlcFtrZXldIHx8IHRoaXMuX3JlbW92ZUVsZW1lbnQoa2V5LCBpc1Njcm9sbFVwKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNTY3JvbGxVcFxuICAgKi9cbiAgX3JlbmRlckVsZW1lbnQoaW5kZXgsIGlzU2Nyb2xsVXApIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLnVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pOyAvLyB1cGRhdGUgaWYgaXQgZXhpc3RzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KGluZGV4LCBpdGVtID0+IHtcbiAgICAgIGlmIChpc1Njcm9sbFVwKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50Lmluc2VydEJlZm9yZShpdGVtLmVsZW1lbnQsIHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuW3RoaXMuX2luc2VydEluZGV4XSlcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgaXRlbS5oZWlnaHQgPSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXggKyAxXSAtIHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNTY3JvbGxVcFxuICAgKi9cbiAgX3JlbW92ZUVsZW1lbnQoaW5kZXgsIGlzU2Nyb2xsVXAgPSB0cnVlKSB7XG4gICAgaW5kZXggPSArKGluZGV4KTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pO1xuXG4gICAgaWYgKGlzU2Nyb2xsVXApIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleCArIDFdID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLnBhZGRpbmcgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICB9XG5cbiAgX3JlbW92ZUFsbEVsZW1lbnRzKCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IHRoaXMuX3JlbW92ZUVsZW1lbnQoa2V5KSk7XG4gIH1cblxuICBfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpXSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVN0YXJ0SW5kZXgoY3VycmVudCkge1xuICAgIGNvbnN0IGZpcnN0SXRlbUluZGV4ID0gdGhpcy5fZmlyc3RJdGVtUmVuZGVyZWQoKTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5fbGFzdEl0ZW1SZW5kZXJlZCgpO1xuXG4gICAgLy8gRml4IGZvciBTYWZhcmkgc2Nyb2xsIGFuZCBBbmd1bGFyIDJcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucyhmaXJzdEl0ZW1JbmRleCwgbGFzdEl0ZW1JbmRleCk7XG5cbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSB0aGlzLl9jb3VudEl0ZW1zKCkgLSAxO1xuXG4gICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgaW5kZXggYXQgdG9wIG9mIHNjcmVlbiBzbyB3ZSBjYW4gc3BlZWQgdXAgcmVuZGVyaW5nLlxuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50ICsgdGhpcy5fdG9wUG9zaXRpb25zW21pZGRsZV07XG5cbiAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gMCAmJiB2YWx1ZSArIHRoaXMuX2dldEl0ZW1IZWlnaHQobWlkZGxlKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID49IDApIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBfZG91YmxlRmlyZU9uVG91Y2hlbmQoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fZGVib3VuY2UodGhpcy5fcmVuZGVyLmJpbmQodGhpcyksIDEwMCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdXRpbC5iaW5kTGlzdGVuZXJzKHRoaXMsIFsnX29uQ2hhbmdlJywgJ19kb3VibGVGaXJlT25Ub3VjaGVuZCddKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fZGVib3VuY2UodGhpcy5fYm91bmRPbkNoYW5nZSwgMzApO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kLCB0cnVlKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IHtMYXp5UmVwZWF0UHJvdmlkZXIsIExhenlSZXBlYXREZWxlZ2F0ZX0gZnJvbSAnLi9sYXp5LXJlcGVhdCc7XG5cbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbmludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmxldCBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcblxuLy8gTW9kaWZpZXJzXG5jb25zdCBtb2RpZmllcnNNYXAgPSB7XG4gICdxdWlldCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdsaWdodCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdvdXRsaW5lJzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2N0YSc6ICcnLFxuICAnbGFyZ2UtLXF1aWV0JzogJ21hdGVyaWFsLS1mbGF0IGxhcmdlJyxcbiAgJ2xhcmdlLS1jdGEnOiAnbGFyZ2UnLFxuICAnbm9ib3JkZXInOiAnJyxcbiAgJ2NoZXZyb24nOiAnJyxcbiAgJ3RhcHBhYmxlJzogJydcbn07XG5cbmNvbnN0IHBsYXRmb3JtcyA9IHt9O1xuXG5wbGF0Zm9ybXMuYW5kcm9pZCA9IGVsZW1lbnQgPT4ge1xuXG4gIGlmICghL29ucy1mYWJ8b25zLXNwZWVkLWRpYWx8b25zLXByb2dyZXNzLy50ZXN0KGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICEvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG5cbiAgICBjb25zdCBvbGRNb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcbiAgICBuZXdNb2RpZmllci51bnNoaWZ0KCdtYXRlcmlhbCcpO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XG4gIH1cblxuICAvLyBFZmZlY3RzXG4gIGlmICgvb25zLWJ1dHRvbnxvbnMtbGlzdC1pdGVtfG9ucy1mYWJ8b25zLXNwZWVkLWRpYWx8b25zLXRhYiQvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKVxuICAgICYmICFlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1yaXBwbGUnKSkge1xuXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnBsYXRmb3Jtcy5pb3MgPSBlbGVtZW50ID0+IHtcblxuIC8vIE1vZGlmaWVyc1xuIGlmICgvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG4gICB1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpO1xuXG4gICBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwtLWZsYXQnKSkge1xuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XG4gICB9XG5cbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICB9XG4gfVxuXG4gLy8gRWZmZWN0c1xuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXBwYWJsZScsICcnKTtcbiAgIH1cblxuICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuIH1cbn07XG5cbmNvbnN0IHVubG9ja2VkID0ge1xuICBhbmRyb2lkOiB0cnVlXG59O1xuXG5jb25zdCBwcmVwYXJlQXV0b1N0eWxlID0gKGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGlmIChhdXRvU3R5bGVFbmFibGVkICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZS1hdXRvLXN0eWxpbmcnKSkge1xuICAgIGNvbnN0IG1vYmlsZU9TID0gb25zUGxhdGZvcm0uZ2V0TW9iaWxlT1MoKTtcbiAgICBpZiAocGxhdGZvcm1zLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSAmJiAodW5sb2NrZWQuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpIHx8IGZvcmNlKSkge1xuICAgICAgcGxhdGZvcm1zW21vYmlsZU9TXShlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IG1hcE1vZGlmaWVyID0gKG1vZGlmaWVyLCBlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHJldHVybiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkobW9kaWZpZXIpID8gbW9kaWZpZXJzTWFwW21vZGlmaWVyXSA6IG1vZGlmaWVyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtb2RpZmllcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNFbmFibGVkOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkLFxuICBlbmFibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlLFxuICBkaXNhYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gZmFsc2UsXG4gIHByZXBhcmU6IHByZXBhcmVBdXRvU3R5bGUsXG4gIG1hcE1vZGlmaWVyXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1bndyYXAgPSBzdHJpbmcgPT4gc3RyaW5nLnNsaWNlKDEsIC0xKTtcbmNvbnN0IGlzT2JqZWN0U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCd7JykgJiYgc3RyaW5nLmVuZHNXaXRoKCd9Jyk7XG5jb25zdCBpc0FycmF5U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCdbJykgJiYgc3RyaW5nLmVuZHNXaXRoKCddJyk7XG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHN0cmluZyA9PiAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcJycpICYmIHN0cmluZy5lbmRzV2l0aCgnXFwnJykpIHx8IChzdHJpbmcuc3RhcnRzV2l0aCgnXCInKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1wiJykpO1xuXG5jb25zdCBlcnJvciA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG59O1xuXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgcmV0dXJuICsodG9rZW4pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgbmV4dFRva2VuID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbUxlZnQoKTtcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcblxuICBpZiAoc3RyaW5nWzBdID09PSAnOicgfHwgc3RyaW5nWzBdID09PSAnLCcpIHtcblxuICAgIGxpbWl0ID0gMTtcblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYykge1xuICAgICAgICBuZXN0ZWRPYmplY3QrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMgKyAyKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdC0tO1xuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XG4gICAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ1xcJycgfHwgc3RyaW5nWzBdID09PSAnXFxcIicpIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSBzdHJpbmdbMF0pIHtcbiAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcbn07XG5cbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBpc1ZhbGlkS2V5ID0ga2V5ID0+IC9eW0EtWl9cXCRdW0EtWjAtOV9cXCRdKiQvaS50ZXN0KGtleSk7XG5cbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xuXG4gICAgaWYgKCh0b2tlbiA9PT0gJzonICYmICghcmVhZGluZ0tleSB8fCAhcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKVxuICAgICAgIHx8ICh0b2tlbiA9PT0gJywnICYmIHJlYWRpbmdLZXkpXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBwYXJzZUFycmF5ID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi9hdXRvc3R5bGUnO1xuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZSBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudXRpbC5wcmVwYXJlUXVlcnkgPSAocXVlcnkpID0+IHtcbiAgcmV0dXJuIHF1ZXJ5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBxdWVyeSA6IChlbGVtZW50KSA9PiB1dGlsLm1hdGNoKGVsZW1lbnQsIHF1ZXJ5KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcyBDU1MgU2VsZWN0b3IuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLm1hdGNoID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZENoaWxkID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIC8vIENhdXRpb246IGBlbGVtZW50LmNoaWxkcmVuYCBpcyBgdW5kZWZpbmVkYCBpbiBzb21lIGVudmlyb25tZW50cyBpZiBgZWxlbWVudGAgaXMgYHN2Z2BcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgeyAvLyBwcm9jZXNzIG9ubHkgZWxlbWVudCBub2Rlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZFBhcmVudCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtYXRjaChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNBdHRhY2hlZCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgd2hpbGUgKGVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhvbnMtbmF2aWdhdG9yfG9ucy10YWJiYXJ8b25zLW1vZGFsfG9ucy1zbGlkaW5nLW1lbnV8b25zLXNwbGl0LXZpZXcpLykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0byBwcm9wYWdhdGVcbiAqL1xudXRpbC5wcm9wYWdhdGVBY3Rpb24gPSAoZWxlbWVudCwgYWN0aW9uKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkW2FjdGlvbl0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgY2hpbGRbYWN0aW9uXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbihjaGlsZCwgYWN0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSB0YWcgYW5kIGNsYXNzIG9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZSA9IChzZWxlY3RvciA9ICcnLCBzdHlsZSA9IHt9KSA9PiB7XG4gIGNvbnN0IGNsYXNzTGlzdCA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNsYXNzTGlzdC5zaGlmdCgpIHx8ICdkaXYnKTtcblxuICBpZiAoY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NMaXN0LmpvaW4oJyAnKTtcbiAgfVxuXG4gIHV0aWwuZXh0ZW5kKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlRWxlbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaHRtbFwiIG11c3QgYmUgb25lIHdyYXBwZXIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyLmNoaWxkcmVuWzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxuICovXG51dGlsLmNyZWF0ZUZyYWdtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLypcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNyYyBTb3VyY2Ugb2JqZWN0KHMpLlxuICogQHJldHVybnMge09iamVjdH0gUmVmZXJlbmNlIHRvIGBkc3RgLlxuICovXG51dGlsLmV4dGVuZCA9IChkc3QsIC4uLmFyZ3MpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyZ3NbaV0pIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmdzW2ldKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBkc3Rba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZHN0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xudXRpbC5hcnJheUZyb20gPSAoYXJyYXlMaWtlKSA9PiB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXlMaWtlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmFpbFNhZmVdXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnV0aWwucGFyc2VKU09OT2JqZWN0U2FmZWx5ID0gKGpzb25TdHJpbmcsIGZhaWxTYWZlID0ge30pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKCcnICsganNvblN0cmluZyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWlsU2FmZTtcbiAgfVxuICByZXR1cm4gZmFpbFNhZmU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gcGF0aCBzdWNoIGFzICdteUFwcC5jb250cm9sbGVycy5kYXRhLmxvYWREYXRhJ1xuICogQHJldHVybiB7QW55fSAtIHdoYXRldmVyIGlzIGxvY2F0ZWQgYXQgdGhhdCBwYXRoXG4gKi9cbnV0aWwuZmluZEZyb21QYXRoID0gKHBhdGgpID0+IHtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGVsID0gd2luZG93LCBrZXk7XG4gIHdoaWxlIChrZXkgPSBwYXRoLnNoaWZ0KCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgIGVsID0gZWxba2V5XTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIFBhZ2Ugb3IgcGFnZS1jb250YWluZXIgdGhhdCBpbXBsZW1lbnRzICd0b3BQYWdlJ1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gLSBWaXNpYmxlIHBhZ2UgZWxlbWVudCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAqL1xudXRpbC5nZXRUb3BQYWdlID0gY29udGFpbmVyID0+IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1wYWdlJyA/IGNvbnRhaW5lciA6IGNvbnRhaW5lci50b3BQYWdlKSB8fCBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIEVsZW1lbnQgd2hlcmUgdGhlIHNlYXJjaCBiZWdpbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IC0gUGFnZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHZpc2libGUgdG9vbGJhciBvciBudWxsLlxuICovXG51dGlsLmZpbmRUb29sYmFyUGFnZSA9IGNvbnRhaW5lciA9PiB7XG4gIGNvbnN0IHBhZ2UgPSB1dGlsLmdldFRvcFBhZ2UoY29udGFpbmVyKTtcblxuICBpZiAocGFnZSkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZChwYWdlLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSB1dGlsLmdldFRvcFBhZ2UocGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0pO1xuICAgICAgaWYgKG5leHRQYWdlKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbmRUb29sYmFyUGFnZShuZXh0UGFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxdXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cbiAqL1xudXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50ID0gKHRhcmdldCwgZXZlbnROYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9KTtcblxuICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goa2V5ID0+IHtcbiAgICBldmVudFtrZXldID0gZGV0YWlsW2tleV07XG4gIH0pO1xuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKS5zcGxpdCgvXFxzKy8pLnNvbWUoZSA9PiBlID09PSBtb2RpZmllck5hbWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXG4gKi9cbnV0aWwuYWRkTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy5hdXRvU3R5bGUpIHtcbiAgICBtb2RpZmllck5hbWUgPSBhdXRvU3R5bGUubWFwTW9kaWZpZXIobW9kaWZpZXJOYW1lLCB0YXJnZXQsIG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUpO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9kaWZpZXJOYW1lID0gbW9kaWZpZXJOYW1lLnRyaW0oKTtcbiAgY29uc3QgbW9kaWZpZXJBdHRyaWJ1dGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIChtb2RpZmllckF0dHJpYnV0ZSArICcgJyArIG1vZGlmaWVyTmFtZSkudHJpbSgpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdXRvU3R5bGUgTWFwcyB0aGUgbW9kaWZpZXJOYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlZCBtb2RpZmllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZvcmNlQXV0b1N0eWxlIElnbm9yZXMgcGxhdGZvcm0gbGltaXRhdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC5yZW1vdmVNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dG9TdHlsZSkge1xuICAgIG1vZGlmaWVyTmFtZSA9IGF1dG9TdHlsZS5tYXBNb2RpZmllcihtb2RpZmllck5hbWUsIHRhcmdldCwgb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSk7XG4gIH1cblxuICBjb25zdCBtb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLyk7XG5cbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lKTtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKTtcblxuICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcbn07XG5cbi8vIFRPRE86IEZJWFxudXRpbC51cGRhdGVQYXJlbnRQb3NpdGlvbiA9IChlbCkgPT4ge1xuICBpZiAoIWVsLl9wYXJlbnRVcGRhdGVkICYmIGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwucGFyZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBlbC5fcGFyZW50VXBkYXRlZCA9IHRydWU7XG4gIH1cbn07XG5cbnV0aWwudG9nZ2xlQXR0cmlidXRlID0gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufTtcblxudXRpbC5iaW5kTGlzdGVuZXJzID0gKGVsZW1lbnQsIGxpc3RlbmVyTmFtZXMpID0+IHtcbiAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGJvdW5kTmFtZSA9IG5hbWUucmVwbGFjZSgvXl9bYS16XS8sICdfYm91bmQnICsgbmFtZVsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBlbGVtZW50W2JvdW5kTmFtZV0gPSBlbGVtZW50W2JvdW5kTmFtZV0gfHwgZWxlbWVudFtuYW1lXS5iaW5kKGVsZW1lbnQpO1xuICB9KTtcbn07XG5cbnV0aWwuZWFjaCA9IChvYmosIGYpID0+IE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gZihrZXksIG9ialtrZXldKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBoYXNSaXBwbGVcbiAqL1xudXRpbC51cGRhdGVSaXBwbGUgPSAodGFyZ2V0LCBoYXNSaXBwbGUpID0+IHtcbiAgaWYgKGhhc1JpcHBsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGFzUmlwcGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJyk7XG4gIH1cblxuICBjb25zdCByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xuXG4gIGlmIChoYXNSaXBwbGUpIHtcbiAgICBpZiAoIXJpcHBsZUVsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXJpcHBsZScpLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpcHBsZUVsZW1lbnQpIHtcbiAgICByaXBwbGVFbGVtZW50LnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmVqY3R9IERlZmVycmVkIHByb21pc2UuXG4gKi9cbnV0aWwuZGVmZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxuLyoqXG4gKiBTaG93IHdhcm5pbmdzIHdoZW4gdGhleSBhcmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGFyZ3VtZW50cyB0byBjb25zb2xlLndhcm5cbiAqL1xudXRpbC53YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCkge1xuICAgIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cblxuLyoqXG4gKiBNaW5pbWFsIGFuaW1hdGlvbiBsaWJyYXJ5IGZvciBtYW5hZ2luZyBjc3MgdHJhbnNpdGlvbiBvbiBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRJTUVPVVRfUkFUSU8gPSAxLjQ7XG5cbnZhciB1dGlsID0ge1xufTtcblxuLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbnV0aWwuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnByb3BlcnR5XG4gKiBAcGFyYW0ge0Zsb2F0fSBwYXJhbXMuZHVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXG4gKi9cbnV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zLnByb3BlcnR5ID0gcGFyYW1zLnByb3BlcnR5IHx8ICdhbGwnO1xuICBwYXJhbXMuZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb24gfHwgMC40O1xuICBwYXJhbXMudGltaW5nID0gcGFyYW1zLnRpbWluZyB8fCAnbGluZWFyJztcblxuICB2YXIgcHJvcHMgPSBwYXJhbXMucHJvcGVydHkuc3BsaXQoLyArLyk7XG5cbiAgcmV0dXJuIHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgKyAnICcgKyBwYXJhbXMuZHVyYXRpb24gKyAncyAnICsgcGFyYW1zLnRpbWluZztcbiAgfSkuam9pbignLCAnKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIgb24gXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQuXG4gKi9cbnV0aWwub25jZU9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBldmVudC50YXJnZXQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICB9KTtcblxuICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJzO1xufTtcblxudXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cyA9IChmdW5jdGlvbigpIHtcblxuICBpZiAoJ29udHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIFsndHJhbnNpdGlvbmVuZCddO1xuICB9XG5cbiAgaWYgKCdvbndlYmtpdHRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnXTtcbiAgfVxuXG4gIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcbiAgICByZXR1cm4gW3V0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufSkoKTtcblxudXRpbC5fY3NzUHJvcGVydHlEaWN0ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gIHZhciBkaWN0ID0ge307XG4gIHZhciBhID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG4gIHZhciB6ID0gJ3onLmNoYXJDb2RlQXQoMCk7XG5cbiAgdmFyIHVwcGVyID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnN1YnN0cigxKS50b1VwcGVyQ2FzZSgpO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICB2YXIga2V5ID0gc3R5bGVzW2ldXG4gICAgLnJlcGxhY2UoL15bXFwtXSsvLCAnJylcbiAgICAucmVwbGFjZSgvW1xcLV1bYS16XS9nLCB1cHBlcilcbiAgICAucmVwbGFjZSgvXm1vei8sICdNb3onKTtcblxuICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIGlmIChrZXkgIT09ICdjc3NUZXh0JyAmJiBrZXkgIT09ICdwYXJlbnRUZXh0Jykge1xuICAgICAgICBkaWN0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWN0O1xufSkoKTtcblxudXRpbC5oYXNDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xufTtcblxuLyoqXG4gKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gKi9cbnV0aWwudmVuZG9yUHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbn0pKCk7XG5cbnV0aWwuZm9yY2VMYXlvdXRBdE9uY2UgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spIHtcbiAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIGZvcmNlIGxheW91dFxuICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59O1xuXG51dGlsLmJhdGNoSW1tZWRpYXRlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiAndHJhbnNpdGlvbic7XG4gIH1cblxuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiB1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xufSkoKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xudmFyIEFuaW1pdCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFuaW1pdCkpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1pdChlbGVtZW50KTtcbiAgfVxuXG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gW2VsZW1lbnRdO1xuICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50O1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9yIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50LicpO1xuICB9XG5cbiAgdGhpcy50cmFuc2l0aW9uUXVldWUgPSBbXTtcbiAgdGhpcy5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0ID0gW107XG59O1xuXG5BbmltaXQucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgKi9cbiAgdHJhbnNpdGlvblF1ZXVlOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gICAqL1xuICBlbGVtZW50czogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2Ugd2l0aCBwYXNzZWQgYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBRdWV1ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgb3Igb3RoZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30sIHtkdXJhdGlvbjogMC40fSlcbiAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFuaW1pdC5UcmFuc2l0aW9ufEZ1bmN0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIHF1ZXVlOiBmdW5jdGlvbih0cmFuc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICBpZiAodHJhbnNpdGlvbiAmJiBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmNzcyA9IHRyYW5zaXRpb247XG4gICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgIGNzczogdHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24uYnVpbGQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0fSBzZWNvbmRzXG4gICAqL1xuICB3YWl0OiBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgPiAwKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwICogc2Vjb25kcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSBlbGVtZW50LnN0eWxlW2VsZW1lbnQuc3R5bGVbaV1dO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgZG9uZSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVzdG9yZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgKi9cbiAgcmVzdG9yZVN0eWxlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiAmJiAhb3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSB1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IG9wdGlvbnMudHJhbnNpdGlvbiB8fCAoJ2FsbCAnICsgb3B0aW9ucy5kdXJhdGlvbiArICdzICcgKyAob3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcicpKTtcblxuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIGNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlclxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgIC8vIHRyYW5zaXRpb24gYW5kIHN0eWxlIHNldHRpbmdzXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmIChjc3NbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHRyYW5zaXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgLy8gQ2xlYXIgdHJhbnNpdGlvbiBhbmltYXRpb24gc2V0dGluZ3MuXG4gICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnbm9uZSc7XG5cbiAgICAgICAgdmFyIGNzcyA9IHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF07XG5cbiAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbmFtZSA9ICcnOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2UuXG4gICAqL1xuICBzdGFydEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9kZXF1ZXVlVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IHRyYW5zaXRpb24gZXhpc3RzLicpO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9jdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZi5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGwodGhpcywgZG9uZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbmltaXR9IGFyZ3VtZW50c1xuICovXG5BbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldLnBsYXkoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9wZXJ0eV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gKi9cbkFuaW1pdC5UcmFuc2l0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgdGhpcy5vcHRpb25zLnRpbWluZyA9IHRoaXMub3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMucHJvcGVydHkgPSB0aGlzLm9wdGlvbnMucHJvcGVydHkgfHwgJ2FsbCc7XG59O1xuXG5BbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBidWlsZDogZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY3NzIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gdXRpbC5idWlsZFRyYW5zaXRpb25WYWx1ZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXRpbC5mb3JjZUxheW91dEF0T25jZShlbGVtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVmaXhlZCA9IHV0aWwudmVuZG9yUHJlZml4ICsgdXRpbC5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgIEFuaW1pdDtcblxuIiwiLypcbiAqIEdlc3R1cmUgZGV0ZWN0b3IgbGlicmFyeSB0aGF0IGZvcmtlZCBmcm9tIGdpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnQsIFV0aWxzLCBEZXRlY3Rpb24sIFBvaW50ZXJFdmVudDtcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5HZXN0dXJlRGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgY2xhc3MgZm9yIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjgq/jg6njgrnjgafjgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICogQHNpZ25hdHVyZSBjb25zdHJ1Y3RvcihlbGVtZW50Wywgb3B0aW9uc10pXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dQ3JlYXRlIGEgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZS5bL2VuXVxuICogIFtqYV1HZXN0dXJlRGV0ZWN0b3Ljga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KLRE9N6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7b25zLkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xudmFyIEdlc3R1cmVEZXRlY3RvciA9IGZ1bmN0aW9uIEdlc3R1cmVEZXRlY3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKiBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGAvZ2VzdHVyZXNgLiBFYWNoIGdlc3R1cmUgY2FuIGJlIGRpc2FibGVkL2VuYWJsZWRcbiAqIGJ5IHNldHRpbmcgaXQncyBuYW1lIChsaWtlIGBzd2lwZWApIHRvIGZhbHNlLlxuICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hBY3Rpb24gPSAncGFuLXknO1xuICogIGRlbGV0ZSBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdDtcbiAqIGBgYGBcbiAqIEBwcm9wZXJ0eSBkZWZhdWx0c1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzID0ge1xuICBiZWhhdmlvcjoge1xuICAgIC8vIHVzZXJTZWxlY3Q6ICdub25lJywgLy8gQWxzbyBkaXNhYmxlcyBzZWxlY3Rpb24gaW4gYGlucHV0YCBjaGlsZHJlblxuICAgIHRvdWNoQWN0aW9uOiAncGFuLXknLFxuICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG4gICAgdXNlckRyYWc6ICdub25lJyxcbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cbn07XG5cbi8qKlxuICogR2VzdHVyZURldGVjdG9yIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMgPSAoR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyAmJiBHZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFKSB8fCBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggR2VzdHVyZURldGVjdG9yIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgPSBHZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyA9IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICBpZihHZXN0dXJlRGV0ZWN0b3IuUkVBRFkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBmaW5kIHdoYXQgZXZlbnR0eXBlcyB3ZSBhZGQgbGlzdGVuZXJzIHRvXG4gIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICBVdGlscy5lYWNoKEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QpO1xuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfRU5ELCBEZXRlY3Rpb24uZGV0ZWN0KTtcblxuICAvLyBHZXN0dXJlRGV0ZWN0b3IgaXMgcmVhZHkuLi4hXG4gIEdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IHRydWU7XG59XG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBzdGF0aWNcbiAqL1xuVXRpbHMgPSBHZXN0dXJlRGV0ZWN0b3IudXRpbHMgPSB7XG4gIC8qKlxuICAgKiBleHRlbmQgbWV0aG9kLCBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGNsb25pbmcgd2hlbiBgZGVzdGAgaXMgYW4gZW1wdHkgb2JqZWN0LlxuICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXSAgZG8gYSBtZXJnZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkgJiYgKGRlc3Rba2V5XSA9PT0gdW5kZWZpbmVkIHx8ICFtZXJnZSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgYWRkRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvckVhY2ggb3ZlciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge2FueX0gaXRlcmF0b3IuaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IuaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgIGluIHRoZSBpdGVyYXRvclxuICAgKi9cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbjtcblxuICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIC8vIGFycmF5c1xuICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gb2JqZWN0c1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IoaSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpICYmXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBpblN0cjogZnVuY3Rpb24gaW5TdHIoc3JjLCBmaW5kKSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cbiAgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQpIHtcbiAgICBpZihzcmMuaW5kZXhPZikge1xuICAgICAgdmFyIGluZGV4ID0gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICByZXR1cm4gKGluZGV4ID09PSAtMSkgPyBmYWxzZSA6IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHBhZ2VYID0gW10sXG4gICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgY2xpZW50WSA9IFtdLFxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cblxuICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBnZXRWZWxvY2l0eTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuICAvKipcbiAgICogZG8gYSBzbWFsbCBjb21wYXJpc29uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICovXG4gIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYKSxcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgaWYoeCA+PSB5KSB7XG4gICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xuICAgKiBAcGFyYW0ge1RvdWNofXRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIGdldERpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC8gdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwcm9wO1xuICAgICAgLy8gcHJlZml4ZXNcbiAgICAgIGlmKHByZWZpeGVzW2ldKSB7XG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXG4gICAgICBpZihwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqL1xuICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgY3NzIHByb3BlcnRpZXNcbiAgICBVdGlscy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZmFsc2VGbiA9IHRvZ2dsZSAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgaWYocHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICogc28gcHJldmVudF9kZWZhdWx0IGJlY29tZXMgcHJldmVudERlZmF1bHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgKi9cbiAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cbi8qKlxuICogQGNsYXNzIEV2ZW50XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50ID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAvKipcbiAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGFydGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAqIHRoaXMgZmluZHMgb3V0IGlmIHdlIHNob3VsZCB0byBkZXRlY3QgZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4gb25Ub3VjaEhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY29yZSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uIG9uVG91Y2hIYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc1BvaW50ZXIgPSBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMsXG4gICAgICAgICAgaXNNb3VzZSA9IFV0aWxzLmluU3RyKHNyY1R5cGUsICdtb3VzZScpLFxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgaW4gYSBtb3VzZWV2ZW50LCBidXQgdGhlcmUgaGFzIGJlZW4gYSB0b3VjaGV2ZW50IHRyaWdnZXJlZCBpbiB0aGlzIHNlc3Npb25cbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXG4gICAgICBpZihpc01vdXNlICYmIHNlbGYucHJldmVudE1vdXNlRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtb3VzZWJ1dHRvbiBtdXN0IGJlIGRvd25cbiAgICAgIH0gZWxzZSBpZihpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XG4gICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICB9IGVsc2UgaWYoIWlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgaWYoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIFBvaW50ZXJFdmVudC5yZXNldCgpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXJldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGRldGVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgcmV0dXJuIG9uVG91Y2hIYW5kbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXG4gICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgR2VzdHVyZURldGVjdG9yLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICovXG4gIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xuICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxuICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgIH1cblxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICB2YXIgZXZEYXRhID0gdGhpcy5jb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIHRyaWdnZXJUeXBlLCB0b3VjaExpc3QsIGV2KTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICBpZihldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICogdGhlIGBvblRvdWNoYCBtZXRob2QgaXMgYmluZCB0byB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICB2YXIgdHlwZXM7XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgIHJldHVybiBldi50b3VjaGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xuICAgICAgdmFyIHRvdWNoTGlzdCA9IFtdO1xuXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgLyoqXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSB0aGlzLnNyY0V2ZW50O1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG5Qb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihldmVudFR5cGUsIHBvaW50ZXJFdmVudCkge1xuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcbiAgICBVdGlscy5leHRlbmQoR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKCk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQG1ldGhvZCBvblxuICAgKiBAc2lnbmF0dXJlIG9uKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1BZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2VzdHVyZS4gQXZhaWxhYmxlIGdlc3R1cmVzIGFyZTogZHJhZywgZHJhZ2xlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93biwgaG9sZCwgcmVsZWFzZSwgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duLCB0YXAsIGRvdWJsZXRhcCwgdG91Y2gsIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0IGFuZCByb3RhdGUuIFsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj44Gr5a++44GZ44KL44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS6L+95Yqg44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44K444Kn44K544OB44Oj5ZCN44Gv44CBZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIGhvbGQgcmVsZWFzZSBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93biB0YXAgZG91YmxldGFwIHRvdWNoIHRyYW5zZm9ybSBwaW5jaCBwaW5jaGluIHBpbmNob3V0IHJvdGF0ZSDjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3mpJznn6XjgZnjgovjgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzZWxmLmV2ZW50SGFuZGxlcnMucHVzaCh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb2ZmXG4gICAqIEBzaWduYXR1cmUgb2ZmKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBpbmRleCA9IFV0aWxzLmluQXJyYXkoeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgaWYoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBzaWduYXR1cmUgdHJpZ2dlcihnZXN0dXJlLCBldmVudERhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmKFV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBlbmFibGVcbiAgICogQHNpZ25hdHVyZSBlbmFibGUoc3RhdGUpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVuYWJsZSBvciBkaXNhYmxlIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj5qSc55+l44KS5pyJ5Yq55YyWL+eEoeWKueWMluOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICogICBbZW5dU3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgZW5hYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd5pyJ5Yq544Gr44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gc3RhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZVxuICAgKiBAc2lnbmF0dXJlIGRpc3Bvc2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW5kIGRlc3Ryb3kgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGluc3RhbmNlLlsvZW5dXG4gICAqICBbamFd44GT44Gu44Kk44Oz44K544K/44Oz44K544Gn44Gu44K444Kn44K544OB44Oj44Gu5qSc55+l44KE44CB44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS5YWo44Gm6Kej6Zmk44GX44Gm5buD5qOE44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIGksIGVoO1xuXG4gICAgLy8gdW5kbyBhbGwgY2hhbmdlcyBtYWRlIGJ5IHN0b3BfYnJvd3Nlcl9iZWhhdmlvclxuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCBmYWxzZSk7XG5cbiAgICAvLyB1bmJpbmQgYWxsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgIGZvcihpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgaWYoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnRGlzdGFuY2VDb3JyZWN0aW9uICYmIGV2LmRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgIGlmKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICApKSB7XG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNTAsXG4gICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICogVXNlZnVsIHRvIGF2b2lkIGEgamVyay1zdGFydGluZyBkcmFnLCB3aGljaCBjYW4gbWFrZSBmaW5lLWFkanVzdG1lbnRzXG4gICAgICAgICAqIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNYXhUb3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggaXQsIGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tIb3Jpem9udGFsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2FtZSBhcyBgZHJhZ0Jsb2NrSG9yaXpvbnRhbGAsIGJ1dCBmb3IgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja1ZlcnRpY2FsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcbiAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrVG9BeGlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcbiAgICAgIH1cbiAgICB9O1xuICB9KSgnZHJhZycpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAgICogb25seSB1c2FibGUgaWYgeW91IGtub3cgd2hhdCB5b3VyIGRvaW5nLi4uXG4gICAqXG4gICAqIEBjbGFzcyBHZXN0dXJlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5HZXN0dXJlID0ge1xuICAgIG5hbWU6ICdnZXN0dXJlJyxcbiAgICBpbmRleDogMTMzNyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAgICpcbiAgICogQGNsYXNzIEhvbGRcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBob2xkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGlmKGV2LmRpc3RhbmNlID4gb3B0aW9ucy5ob2xkVGhyZXNob2xkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuSG9sZCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRpbWVvdXQ6IDUwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGhyZXNob2xkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBob2xkR2VzdHVyZVxuICAgIH07XG4gIH0pKCdob2xkJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgcmVsZWFzZWQgZnJvbSB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgUmVsZWFzZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJlbGVhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuUmVsZWFzZSA9IHtcbiAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgaW5kZXg6IEluZmluaXR5LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gICAqIGBgYGBcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqICB9KTtcbiAgICogYGBgYFxuICAgKlxuICAgKiBAY2xhc3MgU3dpcGVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZih0b3VjaGVzIDwgb3B0aW9ucy5zd2lwZU1pblRvdWNoZXMgfHxcbiAgICAgICAgICB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICAgKlxuICAgKiBAY2xhc3MgVGFwXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBkb3VibGV0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgaWYoIVV0aWxzLmluU3RyKGV2LnNyY0V2ZW50LnR5cGUsICdjYW5jZWwnKSAmJiBldi5kZWx0YVRpbWUgPCBvcHRpb25zLnRhcE1heFRpbWUgJiYgIWhhc01vdmVkKSB7XG4gICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xuICAgICAgICAgIHNpbmNlUHJldiA9IHByZXYgJiYgcHJldi5sYXN0RXZlbnQgJiYgZXYudGltZVN0YW1wIC0gcHJldi5sYXN0RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgIGRpZERvdWJsZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgIGlmKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwMCxcbiAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgfVxuICAgIH07XG4gIH0pKCd0YXAnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBUb3VjaFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRvdWNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudE1vdXNlICYmIGV2LnBvaW50ZXJUeXBlID09IFBPSU5URVJfTU9VU0UpIHtcbiAgICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICpcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJvdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAvLyBhdCBsZWFzdCBtdWx0aXRvdWNoXG4gICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgaWYocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8IDIpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNDUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5Sb3RhdGlvbjogMVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgIH07XG4gIH0pKCd0cmFuc2Zvcm0nKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdHVyZURldGVjdG9yO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmNvbnN0IHJlYWR5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgcmVhZHlNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhlbGVtZW50LCBmbikge1xuICBpZiAoIXF1ZXVlTWFwLmhhcyhlbGVtZW50KSkge1xuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XG4gIH1cbiAgcXVldWVNYXAuZ2V0KGVsZW1lbnQpLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lUXVldWUoZWxlbWVudCkge1xuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xuICBxdWV1ZU1hcC5kZWxldGUoZWxlbWVudCk7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50UmVhZHkoZWxlbWVudCwgZm4gPSAoKSA9PiB7fSkge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIGFsZXJ0IGRpYWxvZ3MuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZyBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgYTjgY/jgaTjgYvjga7nqK7poZ7jga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLkvZzmiJDjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0hlbGxvLCB3b3JsZCEnKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oJ0FyZSB5b3UgcmVhZHk/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYW5zd2VyKSB7XG4gKiAgICAgICBpZiAoYW5zd2VyID09PSAxKSB7XG4gKiAgICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0xldFxcJ3MgZ28hJyk7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICApO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KCdIb3cgb2xkIGFyZSA/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYWdlKSB7XG4gKiAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdZb3UgYXJlICcgKyBhZ2UgKyAnIHllYXJzIG9sZC4nKTtcbiAqICAgICB9XG4gKiAgICk7XG4gKi9cbmNvbnN0IG5vdGlmaWNhdGlvbiA9IHt9O1xuXG5ub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nID0gb3B0aW9ucyA9PiB7XG4gIC8vIFByb21wdCBpbnB1dCBzdHJpbmdcbiAgbGV0IGlucHV0U3RyaW5nID0gJyc7XG4gIGlmIChvcHRpb25zLmlzUHJvbXB0KSB7XG4gICAgaW5wdXRTdHJpbmcgPSBgXG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3M9XCJ0ZXh0LWlucHV0IHRleHQtaW5wdXQtLXVuZGVyYmFyXCJcbiAgICAgICAgdHlwZT1cIiR7b3B0aW9ucy5pbnB1dFR5cGUgfHwgJ3RleHQnfVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiJHtvcHRpb25zLnBsYWNlaG9sZGVyIHx8ICcnfVwiXG4gICAgICAgIHZhbHVlPVwiJHtvcHRpb25zLmRlZmF1bHRWYWx1ZSB8fCAnJ31cIlxuICAgICAgICBzdHlsZT1cIndpZHRoOiAxMDAlOyBtYXJnaW4tdG9wOiAxMHB4O1wiXG4gICAgICAvPlxuICAgIGA7XG4gIH1cblxuICAvLyBCdXR0b25zIHN0cmluZ1xuICBsZXQgYnV0dG9ucyA9ICcnO1xuICBvcHRpb25zLmJ1dHRvbkxhYmVscy5mb3JFYWNoKChsYWJlbCwgaW5kZXgpID0+IHtcbiAgICBidXR0b25zICs9IGBcbiAgICAgIDxidXR0b24gY2xhc3M9XCJcbiAgICAgICAgYWxlcnQtZGlhbG9nLWJ1dHRvblxuICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXInIDogJyd9XG4gICAgICBcIj5cbiAgICAgICAgJHtsYWJlbH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIGA7XG4gIH0pO1xuXG4gIC8vIERpYWxvZyBFbGVtZW50XG4gIGxldCBlbCA9IHt9O1xuICBjb25zdCBfZGVzdHJveURpYWxvZyA9ICgpID0+IHtcbiAgICBpZiAoZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKSB7XG4gICAgICBlbC5kaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZWwpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBlbFtrZXldKTtcbiAgICBlbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBlbC5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gIGVsLmRpYWxvZy5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPlxuICAgICAgICAgICR7b3B0aW9ucy50aXRsZSB8fCAnJ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICAgICAgICAgICR7b3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUx9XG4gICAgICAgICAgJHtpbnB1dFN0cmluZ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJcbiAgICAgICAgICBhbGVydC1kaWFsb2ctZm9vdGVyXG4gICAgICAgICAgJHtvcHRpb25zLmJ1dHRvbkxhYmVscy5sZW5ndGggPD0gMiA/ICcgYWxlcnQtZGlhbG9nLWZvb3Rlci0tcm93Zm9vdGVyJyA6ICcnfVxuICAgICAgICBcIj5cbiAgICAgICAgICAke2J1dHRvbnN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIGNvbnRlbnRSZWFkeShlbC5kaWFsb2cpO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIFsnaWQnLCAnY2xhc3MnLCAnYW5pbWF0aW9uJ11cbiAgICAuZm9yRWFjaChhID0+IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoYSkgJiYgZWwuZGlhbG9nLnNldEF0dHJpYnV0ZShhLCBvcHRpb25zW2FdKSk7XG4gIGlmIChvcHRpb25zLm1vZGlmaWVyKSB7XG4gICAgdXRpbC5hZGRNb2RpZmllcihlbC5kaWFsb2csIG9wdGlvbnMubW9kaWZpZXIpO1xuICB9XG5cbiAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG5cbiAgLy8gUHJvbXB0IGV2ZW50c1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLnN1Ym1pdE9uRW50ZXIpIHtcbiAgICBlbC5pbnB1dCA9IGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yKCcudGV4dC1pbnB1dCcpO1xuICAgIGVsLmlucHV0Lm9ua2V5cHJlc3MgPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBlbC5pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1dHRvbiBldmVudHNcbiAgZWwuZm9vdGVyID0gZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJy5hbGVydC1kaWFsb2ctZm9vdGVyJyk7XG4gIHV0aWwuYXJyYXlGcm9tKGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yQWxsKCcuYWxlcnQtZGlhbG9nLWJ1dHRvbicpKS5mb3JFYWNoKChidXR0b25FbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGJ1dHRvbkVsZW1lbnQub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBvcHRpb25zLmlzUHJvbXB0ID8gZWwuaW5wdXQudmFsdWUgOiBpbmRleDtcbiAgICAgICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWwuZm9vdGVyLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgZXZlbnRzXG4gIGlmIChvcHRpb25zLmNhbmNlbGFibGUpIHtcbiAgICBlbC5kaWFsb2cuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBvcHRpb25zLmlzUHJvbXB0ID8gbnVsbCA6IC0xO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgZGVmZXJyZWQucmVqZWN0KHJlc29sdmVWYWx1ZSk7XG4gICAgfTtcbiAgICBlbC5kaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCwgZmFsc2UpO1xuICB9XG5cbiAgLy8gU2hvdyBkaWFsb2dcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbC5kaWFsb2cpO1xuICBvcHRpb25zLmNvbXBpbGUoZWwuZGlhbG9nKTtcbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBlbC5kaWFsb2cuc2hvdygpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChlbC5pbnB1dCAmJiBvcHRpb25zLmlzUHJvbXB0ICYmIG9wdGlvbnMuYXV0b2ZvY3VzKSB7XG4gICAgICAgICAgZWwuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuY29uc3QgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IChtZXNzYWdlLCBvcHRpb25zID0ge30sIGRlZmF1bHRzID0ge30pID0+IHtcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcbiAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZXJ0IGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVscycpIHx8IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVsJykpIHtcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyA9IG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IG9wdGlvbnMuYnV0dG9uTGFiZWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYnV0dG9uTGFiZWxzKSkge1xuICAgICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBbb3B0aW9ucy5idXR0b25MYWJlbHMgfHwgJyddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgIGNvbXBpbGU6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgY2FsbGJhY2s6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgYnV0dG9uTGFiZWxzOiBbJ09LJ10sXG4gICAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IDAsXG4gICAgICBhbmltYXRpb246ICdkZWZhdWx0JyxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFsZXJ0XG4gKiBAc2lnbmF0dXJlIGFsZXJ0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovmloflrZfliJfjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VIVE1MXVxuICogICBbZW5dQWxlcnQgbWVzc2FnZSBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDBgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMCDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuIElmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzaW5nIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYG5vbmVgIGFuZCBgZmFkZWAuIERlZmF1bHQgaXMgYGZhZGVgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgY2xhc3MuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5jbGFzc+OAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgdGl0bGU6ICdBbGVydCdcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29uZmlybVxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5kZXggb2YgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBbXCJDYW5jZWxcIiwgXCJPS1wiXWAuWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+OBruODqeODmeODq+OBrumFjeWIl+OCkuaMh+WumuOBl+OBvuOBmeOAgltcIkNhbmNlbFwiLCBcIk9LXCJd44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMWAuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAxIOOBp+OBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24uIEV4dGVuZHMgYGFsZXJ0KClgIHBhcmFtZXRlcnMuXG4gKiAgICAgVGhlIGRlZmF1bHQgYnV0dG9uIGxhYmVscyBhcmUgYFwiQ2FuY2VsXCJgIGFuZCBgXCJPS1wiYCBidXQgdGhleSBjYW4gYmUgY3VzdG9taXplZC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0ob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjgavnorroqo3jgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjg4fjgqrjg6vjgajjga7jg5zjgr/jg7Pjg6njg5njg6vjga/jgIFcIkNhbmNlbFwi44GoXCJPS1wi44Gn44GZ44GM44CB44GT44KM44Gv44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gn44Kr44K544K/44Oe44Kk44K644Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uY29uZmlybSA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICBidXR0b25MYWJlbHM6IFsnQ2FuY2VsJywgJ09LJ10sXG4gICAgcHJpbWFyeUJ1dHRvbkluZGV4OiAxLFxuICAgIHRpdGxlOiAnQ29uZmlybSdcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcHJvbXB0XG4gKiBAc2lnbmF0dXJlIHByb21wdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIGAwYC5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDAg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cbiAqICAgW2VuXVBsYWNlaG9sZGVyIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OX44Os44O844K544Ob44Or44OA44Gr6KGo56S644GZ44KL44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXG4gKiAgIFtlbl1EZWZhdWx0IHZhbHVlIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OH44OV44Kp44Or44OI44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnB1dFR5cGVdXG4gKiAgIFtlbl1UeXBlIG9mIHRoZSBpbnB1dCBlbGVtZW50IChgcGFzc3dvcmRgLCBgZGF0ZWAuLi4pLiBEZWZhdWx0IGlzIGB0ZXh0YC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxuICogICBbZW5dQXV0b2ZvY3VzIHRoZSBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxuICogICBbamFdaW5wdXTopoHntKDjgavoh6rli5XnmoTjgavjg5Xjgqnjg7zjgqvjgrnjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXUVudGVy44GM5oq844GV44KM44Gf6Zqb44Gr44Gd44GuZm9ybeOCknN1Ym1pdOOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHdpdGggYSBwcm9tcHQgdG8gYXNrIHRoZSB1c2VyIGEgcXVlc3Rpb24uIEV4dGVuZHMgYGFsZXJ0KClgIHBhcmFtZXRlcnMuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBq+WFpeWKm+OCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnByb21wdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICB0aXRsZTogJ0FsZXJ0JyxcbiAgICBpc1Byb21wdDogdHJ1ZSxcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgc3VibWl0T25FbnRlcjogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdGlmaWNhdGlvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcblxuICAvKipcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICogQGNhdGVnb3J5IHV0aWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBjb25zdCBvYmogPSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzLlsvZW5dXG4gICAgICogICBbamFd44OH44OQ44Kk44K544Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd54++5Zyo44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAc2lnbmF0dXJlIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgZPjga7jgqTjg5njg7Pjg4jjgYznmbrngavjgZXjgozjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvbmNlXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCdzIG9ubHkgdHJpZ2dlcmVkIG9uY2UuWy9lbl1cbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHNpZ25hdHVyZSBvZmYoZXZlbnROYW1lLCBbbGlzdGVuZXJdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgdHlwZSB3aWxsIGJlIHJlbW92ZWQuWy9lbl1cbiAgICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAguOCguOBl+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBquOBi+OBo+OBn+WgtOWQiOOBq+OBr+OAgeOBneOBruOCpOODmeODs+ODiOOBq+e0kOOBpeOBj+WFqOOBpuOBruOCpOODmeODs+ODiOODquOCueODiuODvOOBjOWJiumZpOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd5YmK6Zmk44GZ44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8vIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0byBkZXRlY3QgaWYgd2hldGhlciBjdXJyZW50IHNjcmVlbiBpcyBwb3J0cmFpdCBvciBub3RcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAc2lnbmF0dXJlIGlzUG9ydHJhaXQoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0sXG5cbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHRoaXMuX2lzUG9ydHJhaXQoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIG9mIEFuZHJvaWQgaW5jb25zaXN0ZW5jeS5cbiAgICAgIGxldCBuSXRlciA9IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbkl0ZXIrKztcblxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcbiAgICAgICAgICAgKCFpc1BvcnRyYWl0ICYmIHcgPj0gaCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfVxuICB9O1xuXG4gIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlKCkuX2luaXQoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG5jb25zdCBvblNob3cgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSB0cnVlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcbn07XG5cbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2hpZGUnKTtcbn07XG5cbmNvbnN0IGJpbmRFdmVudHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbm1vc2UvY29yZG92YS1rZXlib2FyZC9ibG9iLzk1ZjNkYTNhMzhkOGY4ZTFmYTQxZmJmNDAxNDUzNTJjMTM1MzVhMDAvUkVBRE1FLm1kXG4gICAgS2V5Ym9hcmQub25zaG93ID0gb25TaG93O1xuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG5vUGx1Z2luRXJyb3IgPSAoKSA9PiB7XG4gIHV0aWwud2Fybignb25zLWtleWJvYXJkOiBDb3Jkb3ZhIEtleWJvYXJkIHBsdWdpbiBpcyBub3QgcHJlc2VudC4nKTtcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICBpZiAoIWJpbmRFdmVudHMoKSkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWFjdGl2ZV0nKSB8fFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgIH1cblxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29mdHdhcmVLZXlib2FyZDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHV0aWwuX29uRE9NQ29udGVudExvYWRlZCgpLCBmYWxzZSk7XG5cbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xuICBfc3RvcmU6IHt9LFxuXG4gIF9nZW5JZDogKCgpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpID0+IGkrKztcbiAgfSkoKSxcblxuICBzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgfVxufTtcblxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLnJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlIGEgJ2JhY2tidXR0b24nIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYmFja2J1dHRvbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2NhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRMaXN0ZW5lcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0sXG5cbiAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCkgPT09IHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpO1xuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChwYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2NhcHR1cmVUcmVlKCkge1xuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJlZShlbGVtZW50KSB7XG4gICAgICBjb25zdCB0cmVlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZihlbGVtZW50LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMoY2hpbGRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMocmVzdWx0LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9KSlcbiAgICAgIH07XG5cbiAgICAgIGlmICghSGFuZGxlclJlcG9zaXRvcnkuaGFzKHRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJUcmVlIG9mIHRyZWUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoSGFuZGxlclJlcG9zaXRvcnkuaGFzKHN1YlRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheU9mKHRhcmdldCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YXJnZXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKSB7XG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xuICAgICAgICBjb25zdCByaWdodFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyaWdodCwgJycpLnpJbmRleCwgMTApO1xuXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXB0dXJpbmcgYmFja2J1dHRvbi1oYW5kbGVyIGlzIGZhaWx1cmUuJyk7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuXG4vLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBnbG9iYWwgUGFnZUxvYWRlci5cbmZ1bmN0aW9uIGxvYWRQYWdlKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbC50cmltKCkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwYWdlRWxlbWVudCk7XG5cbiAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVubG9hZFBhZ2UoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5fZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgZWxlbWVudC5fZGVzdHJveSgpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhZ2VMb2FkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBcImVsZW1lbnRcIiBwcm9wZXJ0eSBhbmQgXCJ1bmxvYWRcIiBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdW5sb2FkZXIpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGxvYWRlciA6IGxvYWRQYWdlO1xuICAgIHRoaXMuX3VubG9hZGVyID0gdW5sb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHVubG9hZGVyIDogdW5sb2FkUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaW50ZXJuYWwgbG9hZGVyIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgc2V0IGludGVybmFsTG9hZGVyKGZuKSB7XG4gICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZXIgPSBmbjtcbiAgfVxuXG4gIGdldCBpbnRlcm5hbExvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zLnBhZ2VcbiAgICogQHBhcmFtIHtFbGVtZW50fSBvcHRpb25zLnBhcmVudCBBIGxvY2F0aW9uIHRvIGxvYWQgcGFnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmFtc10gRXh0cmEgcGFyYW1ldGVycyBmb3Igb25zLXBhZ2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgVGFrZSBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBsb2FkKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIHRoaXMuX2xvYWRlcih7cGFnZSwgcGFyZW50LCBwYXJhbXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICBpZiAoIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUocGFnZUVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgdW5sb2FkKHBhZ2VFbGVtZW50KSB7XG4gICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3BhZ2VFbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl91bmxvYWRlcihwYWdlRWxlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoKTtcblxuZXhwb3J0IGNvbnN0IGluc3RhbnRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoXG4gIGZ1bmN0aW9uKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQocGFnZS50cmltKCkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgIGRvbmUoZWxlbWVudCk7XG4gIH0sXG4gIHVubG9hZFBhZ2Vcbik7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb25zdCBleHRlbmRlZEFuaW1hdG9yID0gdGhpcztcbiAgICBjb25zdCBuZXdBbmltYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgZXh0ZW5kZWRBbmltYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdXRpbC5leHRlbmQodGhpcywgcHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIG5ld0FuaW1hdG9yLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIHJldHVybiBuZXdBbmltYXRvcjtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuL2FuaW1pdCdcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCBub3RpZmljYXRpb24gZnJvbSAnLi9ub3RpZmljYXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4vb3JpZW50YXRpb24nO1xuaW1wb3J0IHNvZnR3YXJlS2V5Ym9hcmQgZnJvbSAnLi9zb2Z0d2FyZS1rZXlib2FyZCc7XG5pbXBvcnQgUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2VyIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi9hdXRvc3R5bGUnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4vZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHtkZWZhdWx0UGFnZUxvYWRlciwgUGFnZUxvYWRlcn0gZnJvbSAnLi9wYWdlLWxvYWRlcic7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4vYmFzZS1hbmltYXRvcic7XG5cbi8qKlxuICogQG9iamVjdCBvbnNcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXU9uc2VuIFVJ44Gn5Yip55So44Gn44GN44KL44Kw44Ot44O844OQ44Or44Gq44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqICAgW2VuXUEgZ2xvYmFsIG9iamVjdCB0aGF0J3MgdXNlZCBpbiBPbnNlbiBVSS4gWy9lbl1cbiAqL1xuY29uc3Qgb25zID0ge307XG5cbm9ucy5fdXRpbCA9IHV0aWw7XG5vbnMuYW5pbWl0ID0gYW5pbWl0O1xub25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyO1xub25zLl9pbnRlcm5hbCA9IGludGVybmFsO1xub25zLkdlc3R1cmVEZXRlY3RvciA9IEdlc3R1cmVEZXRlY3Rvcjtcbm9ucy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xub25zLnNvZnR3YXJlS2V5Ym9hcmQgPSBzb2Z0d2FyZUtleWJvYXJkO1xub25zLnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0gUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb247XG5vbnMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbm9ucy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG5vbnMuX2FuaW1hdGlvbk9wdGlvbnNQYXJzZXIgPSBhbmltYXRpb25PcHRpb25zUGFyc2VyO1xub25zLl9hdXRvU3R5bGUgPSBhdXRvU3R5bGU7XG5vbnMuX0Rvb3JMb2NrID0gRG9vckxvY2s7XG5vbnMuX2NvbnRlbnRSZWFkeSA9IGNvbnRlbnRSZWFkeTtcbm9ucy5kZWZhdWx0UGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xub25zLlBhZ2VMb2FkZXIgPSBQYWdlTG9hZGVyO1xub25zLl9CYXNlQW5pbWF0b3IgPSBCYXNlQW5pbWF0b3I7XG5cbm9ucy5fcmVhZHlMb2NrID0gbmV3IERvb3JMb2NrKCk7XG5cbm9ucy5wbGF0Zm9ybS5zZWxlY3QoKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goL3BsYXRmb3JtPShbXFx3LV0rKS8pIHx8IFtdKVsxXSk7XG5cbndhaXREZXZpY2VSZWFkeSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsIE9uc2VuIFVJIGhhcyBiZWVuIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44GM5oq844GV44KM44Gf5pmC44Gr5a6f6KGM44GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgZ/jgoHjga7jg4fjg5Xjgqnjg6vjg4jjga7jg4/jg7Pjg4njg6njgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgarjgYTjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkueEoeWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZW5hYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhbmltYXRpb25zIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxub25zLl9kaXNhYmxlV2FybmluZ3MgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQgPSB0cnVlO1xufTtcblxub25zLl9lbmFibGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgb25zLl9pbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtIE5ldyBwbGF0Zm9ybSB0byBzdHlsZSB0aGUgZWxlbWVudHMuXG4gKi9cbm9ucy5mb3JjZVBsYXRmb3JtU3R5bGluZyA9IG5ld1BsYXRmb3JtID0+IHtcbiAgb25zLmVuYWJsZUF1dG9TdHlsaW5nKCk7XG4gIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xuXG4gIG9ucy5fdXRpbC5hcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1pZicpIHtcbiAgICAgICAgZWxlbWVudC5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLm1hdGNoKC9eb25zLS9pKSkge1xuICAgICAgICBvbnMuX2F1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLXBvcG92ZXIvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1wb3BvdmVyPiR7aHRtbH08L29ucy1wb3BvdmVyPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBwb3BvdmVyID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wb3BvdmVyJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BvdmVyKTtcblxuICAgIGlmIChvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb3B0aW9ucy5saW5rKHBvcG92ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3BvdmVyO1xuICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVQb3BvdmVyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZVBvcG92ZXIocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmVudFNjb3BlXVxuICogICBbZW5dUGFyZW50IHNjb3BlIG9mIHRoZSBkaWFsb2cuIFVzZWQgdG8gYmluZCBtb2RlbHMgYW5kIGFjY2VzcyBzY29wZSBtZXRob2RzIGZyb20gdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw5YaF44Gn5Yip55So44GZ44KL6Kaq44K544Kz44O844OX44KS5oyH5a6a44GX44G+44GZ44CC44OA44Kk44Ki44Ot44Kw44GL44KJ44Oi44OH44Or44KE44K544Kz44O844OX44Gu44Oh44K944OD44OJ44Gr44Ki44Kv44K744K544GZ44KL44Gu44Gr5L2/44GE44G+44GZ44CC44GT44Gu44OR44Op44Oh44O844K/44GvQW5ndWxhckpT44OQ44Kk44Oz44OH44Kj44Oz44Kw44Gn44Gu44G/5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBwb3BvdmVyIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Od44OD44OX44Kq44O844OQ44O844Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZVBvcG92ZXIgPSBvbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbDtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubGlua11cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbm9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1kaWFsb2c+JHtodG1sfTwvb25zLWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgZGlhbG9nID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1kaWFsb2cnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhkaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVEaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZURpYWxvZyA9IG9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1hbGVydC1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1hbGVydC1kaWFsb2c+JHtodG1sfTwvb25zLWFsZXJ0LWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgYWxlcnREaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWFsZXJ0LWRpYWxvZycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWxlcnREaWFsb2cpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsoYWxlcnREaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGVydERpYWxvZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtYWxlcnQtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFsZXJ0IGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgYWxlcnQgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZUFsZXJ0RGlhbG9nID0gb25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gKi9cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgbGluaykge1xuICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50c1xuICAgICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gZWxlbWVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsO1xuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlbGVtZW50LCBwYWdlLCBsaW5rKSB7XG4gIGxpbmsgPSBsaW5rIHx8IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHsgZG9uZSgpOyB9O1xuICBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50KTtcblxuICAgIGxpbmsoY29udGVudEVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0pO1xuXG4gIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBpZiAob25zLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCB1bmxvY2tEZXZpY2VSZWFkeSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmxvY2tEZXZpY2VSZWFkeSgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufVxuXG53aW5kb3cuX3N1cGVyU2VjcmV0T25zID0gb25zO1xuZXhwb3J0IGRlZmF1bHQgb25zO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudENsYXNzKCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7IC8vIGNhc2Ugb2YgU2FmYXJpXG4gICAgY29uc3QgQmFzZUVsZW1lbnQgPSAoKSA9PiB7fTtcbiAgICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gQmFzZUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VFbGVtZW50IGV4dGVuZHMgZ2V0RWxlbWVudENsYXNzKCkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgaW5pdCgpIHsgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10ZW1wbGF0ZVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuXG4gKlxuICogICAgIFRoZXNlIHRlbXBsYXRlcyBjYW4gYmUgbG9hZGVkIGFzIHBhZ2VzIGluIGA8b25zLW5hdmlnYXRvcj5gLCBgPG9ucy10YWJiYXI+YCBhbmQgYDxvbnMtc3BsaXR0ZXI+YC4gVGhleSBjYW4gYWxzbyBiZSB1c2VkIHRvIGdlbmVyYXRlIGRpYWxvZ3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgajjgZfjgabkvb/nlKjjgZnjgovjgZ/jgoHjga5IVE1M44OV44Op44Kw44Oh44Oz44OI44KS5a6a576p44GX44G+44GZ44CC44GT44Gu6KaB57Sg44GnSFRNTOOCkuWuo+iogOOBmeOCi+OBqOOAgWlk5bGe5oCn44Gr5oyH5a6a44GX44Gf5ZCN5YmN44KScGFnZeOBrlVSTOOBqOOBl+OBpm9ucy1uYXZpZ2F0b3Ljgarjganjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgYvjgonlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIFBhZ2UgY29udGVudFxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+XG4gKiA8L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkgeyAvLyBOb3RlOiB0aGlzLnBhcmVudE5vZGUgaXMgbm90IHNldCBpbiBzb21lIENFMC9DRTEgcG9seWZpbGxzLlxuICAgICAgLy8gU2hvdyB3YXJuaW5nIHdoZW4gdGhlIG9ucy10ZW1wbGF0ZSBpcyBub3QgbG9jYXRlZCBqdXN0IHVuZGVyIGRvY3VtZW50LmJvZHlcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHsgLy8gaWYgdGhlIHBhcmVudCBpcyBub3QgZG9jdW1lbnQuYm9keVxuICAgICAgICB1dGlsLndhcm4oYG9ucy10ZW1wbGF0ZSAoaWQgPSAke3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpfSkgbXVzdCBiZSBsb2NhdGVkIGp1c3QgdW5kZXIgZG9jdW1lbnQuYm9keSR7IHRoaXMucGFyZW50Tm9kZS5vdXRlckhUTUwgPyBgOlxcblxcbiR7dGhpcy5wYXJlbnROb2RlLm91dGVySFRNTH1gIDogJy4nIH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgZXZlbnQudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIGV2ZW50LnRlbXBsYXRlSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGVtcGxhdGUnLCBUZW1wbGF0ZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4uL29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pZlxuICogQGNhdGVnb3J5IGNvbmRpdGlvbmFsXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWZcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29uZGl0aW9uYWxseSBkaXNwbGF5IGNvbnRlbnQgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSwgZGV2aWNlIG9yaWVudGF0aW9uIG9yIGJvdGguXG4gKlxuICogICAgIFNvbWV0aW1lcyBpdCBpcyB1c2VmdWwgdG8gY29uZGl0aW9uYWxseSBoaWRlIG9yIHNob3cgY2VydGFpbiBjb21wb25lbnRzIGJhc2VkIG9uIHBsYXRmb3JtLiBXaGVuIHJ1bm5pbmcgb24gaU9TIHRoZSBgPG9ucy1pZj5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gaGlkZSB0aGUgYDxvbnMtZmFiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1pZiBvcmllbnRhdGlvbj1cImxhbmRzY2FwZVwiPlxuICogICAgIExhbmRzY2FwZSB2aWV3IVxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImFuZHJvaWRcIj5cbiAqICAgICBUaGlzIGlzIEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiaW9zIG90aGVyXCI+XG4gKiAgICAgVGhpcyBpcyBub3QgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwYWNlLXNlcGFyYXRlZCBwbGF0Zm9ybSBuYW1lcy4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJpb3NcImAsIGBcImFuZHJvaWRcImAsIGBcIndpbmRvd3NcImAgYW5kIGBcIm90aGVyXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxuICAgKiAgW2phXXBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GX44G+44GZWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHBsYXRmb3JtLl9yZW5kZXJQbGF0Zm9ybSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ29yaWVudGF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIF9wbGF0Zm9ybVVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBfaXNBbGxvd2VkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgfVxuXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb3JpZW50YXRpb24nKSAmJiB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25hbE9yaWVudGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gKGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbikgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWYnLCBJZkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHtBbGVydERpYWxvZ0FuaW1hdG9yLCBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmFsZXJ0LWRpYWxvZyc6ICdhbGVydC1kaWFsb2ctLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInOiAnYWxlcnQtZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLXRpdGxlJzogJ2FsZXJ0LWRpYWxvZy10aXRsZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnOiAnYWxlcnQtZGlhbG9nLWNvbnRlbnQtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXInOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXInOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tcm93Zm9vdGVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXInOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcm93Zm9vdGVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKicsXG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gUXd3eHlwXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHJvd2Zvb3RlclxuICogICBbZW5dSG9yaXpvbnRhbGx5IGFsaWducyB0aGUgZm9vdGVyIGJ1dHRvbnMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgZGlhbG9nc1xuICogICBbZW5dRGlhbG9nIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdRGlhbG9nIGNvbXBvbmVudHNbL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5db25zLWRpYWxvZyBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5db25zLXBvcG92ZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLm5vdGlmaWNhdGlvblxuICogICBbZW5dVXNpbmcgb25zLm5vdGlmaWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL44Gr44Gv44CBb25zLm5vdGlmaWNhdGlvbuOCquODluOCuOOCp+OCr+ODiOOBruODoeOCveODg+ODieOCkuS9v+OBhuOBk+OBqOOCguOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hbGVydC1kaWFsb2cgaWQ9XCJhbGVydC1kaWFsb2dcIj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPldhcm5pbmchPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgPGJ1dHRvbiBpZD1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj5PSzwvYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGVydC1kaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gc2hvd2luZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gaGlkaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCiOOBhuOBqOOBmeOCi+OBruOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjgafjga9cIm5vbmVcIuOBi1wiZGVmYXVsdFwi44GM5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CC5L6L77yae2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIFwicmdiYSgwLCAwLCAwLCAwLjIpXCIuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcblxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gKCkgPT4gdGhpcy5fY2FuY2VsKCk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9kaWFsb2coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nJyk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF90aXRsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctdGl0bGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuXG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgcmVzdWx0IGFmdGVyIGNvbXBpbGU6XG4gICAgICpcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmICghdGhpcy5fbWFzayAmJiAhdGhpcy5fZGlhbG9nKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGRpYWxvZywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2csICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICB0aGlzLl9kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGNhbmNlbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgYFByb21pc2VgIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlc2hvdycsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcxJztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0c2hvdycsIHthbGVydERpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeUhpZGUoKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlaGlkZSBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZXNob3cnLCAncG9zdHNob3cnLCAncHJlaGlkZScsICdwb3N0aGlkZScsICdkaWFsb2ctY2FuY2VsJ107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWxlcnREaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWxlcnREaWFsb2dBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hbGVydC1kaWFsb2cnLCBBbGVydERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYmFjay1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnYmFjay1idXR0b24tLSonLFxuICAnLmJhY2stYnV0dG9uX19pY29uJzogJ2JhY2stYnV0dG9uLS0qX19pY29uJyxcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYmFjay1idXR0b25cbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJhY2sgYnV0dG9uIGNvbXBvbmVudCBmb3IgYDxvbnMtdG9vbGJhcj5gLiBQdXQgaXQgaW4gdGhlIGxlZnQgcGFydCBvZiB0aGUgYDxvbnMtdG9vbGJhcj5gLlxuICpcbiAqICAgICBJdCB3aWxsIGZpbmQgdGhlIHBhcmVudCBgPG9ucy1uYXZpZ2F0b3I+YCBlbGVtZW50IGFuZCBwb3AgYSBwYWdlIHdoZW4gY2xpY2tlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNwZWNpZnlpbmcgdGhlIGBvbkNsaWNrYCBwcm9wZXJ0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5db25zLW5hdmlnYXRvciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW5hdmlnYXRvcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIFRpdGxlXG4gKiAgIDxkaXY+XG4gKiA8L29ucy10b29sYmFyPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2xhYmVsJyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2ljb24nKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIFwiLWlvc1wiIG9yIFwiLW1kXCJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYmFjay1idXR0b24nLCBCYWNrQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYm90dG9tLWJhcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1ib3R0b20tdG9vbGJhcj5cbiAqICAgQ29udGVudFxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHRvbVRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXBhZ2UnKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJvdHRvbS10b29sYmFyJywgQm90dG9tVG9vbGJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdidXR0b24tLSonfTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdidXR0b24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1idXR0b25cbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQnV0dG9uIHdpdGggb3V0bGluZSBhbmQgdHJhbnNwYXJlbnQgYmFja2dyb3VuZFsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLmjIHjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxpZ2h0XG4gKiAgIFtlbl1CdXR0b24gdGhhdCBkb2Vzbid0IHN0YW5kIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gf44Gq44GE44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBxdWlldFxuICogICBbZW5dQnV0dG9uIHdpdGggbm8gb3V0bGluZSBhbmQgb3IgYmFja2dyb3VuZC4uWy9lbl1cbiAqICAgW2phXeaeoOe3muOChOiDjOaZr+OBjOeEoeOBhOaWh+Wtl+OBoOOBkeOBruODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY3RhXG4gKiAgIFtlbl1CdXR0b24gdGhhdCByZWFsbHkgc3RhbmRzIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gk44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZVxuICogICBbZW5dTGFyZ2UgYnV0dG9uIHRoYXQgY292ZXJzIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgovlpKfjgY3jgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1xdWlldFxuICogICBbZW5dTGFyZ2UgcXVpZXQgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotxdWlldOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLWN0YVxuICogICBbZW5dTGFyZ2UgY2FsbCB0byBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotjdGHjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODnOOCv+ODs1svamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWwtLWZsYXRcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBmbGF0IGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5Xjg6njg4Pjg4jjg5zjgr/jg7NbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCdXR0b24gY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBwbGFjZSBhIGJ1dHRvbiBpbiBhIHRvb2xiYXIsIHVzZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIG9yIGA8b25zLWJhY2stYnV0dG9uPmAgaW5zdGVhZC5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYXMgYSBNYXRlcmlhbCBEZXNpZ24gYnV0dG9uIHdpdGggYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgILjg4Tjg7zjg6vjg5Djg7zjgavjg5zjgr/jg7PjgpLoqK3nva7jgZnjgovloLTlkIjjga/jgIFvbnMtdG9vbGJhci1idXR0b27jgoLjgZfjgY/jga9vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9idXR0b25cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsYXJnZS0tY3RhXCI+XG4gKiAgIFRhcCBNZVxuICogPC9vbnMtYnV0dG9uPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYnV0dG9uJywgQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2Nhcm91c2VsLWl0ZW0tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWwtaXRlbVxuICogQGNhdGVnb3J5IGNhcm91c2VsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENhcm91c2VsIGl0ZW0gY29tcG9uZW50LiBVc2VkIGFzIGEgY2hpbGQgb2YgdGhlIGA8b25zLWNhcm91c2VsPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsXG4gKiAgIFtlbl1gPG9ucy1jYXJvdXNlbD5gIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdPG9ucy1jYXJvdXNlbD7jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2Fyb3VzZWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbC1pdGVtJywgQ2Fyb3VzZWxJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9vbnMvYW5pbWl0JztcblxuY29uc3QgVmVydGljYWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlZO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbihzY3JvbGwpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKDBweCwgJyArIC1zY3JvbGwgKyAncHgsIDBweCknO1xuICB9LFxuXG4gIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZU9mZnNldDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuX2RpbWVuc2lvbnMuaGVpZ2h0IHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ1RvcCwgMTApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLShoZWlnaHQgLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcbiAgICB9XG4gIH0sXG5cbiAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUuaGVpZ2h0ID0gc2l6ZUF0dHI7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gKGkgKiBzaXplSW5mby5udW1iZXIpICsgc2l6ZUluZm8udW5pdDtcbiAgICB9XG4gIH0sXG5cbiAgX3NldHVwOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkRhdGEoKTtcbiAgICB0aGlzLl91cGRhdGVPZmZzZXQoKTtcbiAgICB0aGlzLl9sYXlvdXRDYXJvdXNlbEl0ZW1zKCk7XG4gIH1cbn07XG5cbmNvbnN0IEhvcml6b250YWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlYO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uKHNjcm9sbCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoJyArIC1zY3JvbGwgKyAncHgsIDBweCwgMHB4KSc7XG4gIH0sXG5cbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLl9kaW1lbnNpb25zLndpZHRoIHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLSh3aWR0aCAtIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSkgLyAyO1xuICAgIH1cbiAgfSxcblxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS53aWR0aCA9IHNpemVBdHRyO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcblxuICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gIH1cblxuICBfb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgICBkZWxldGUgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gIH1cblxuICBfb25EaXJlY3Rpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1ggPSAnYXV0byc7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICcnO1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBfc2F2ZUxhc3RTdGF0ZSgpIHtcbiAgICB0aGlzLl9sYXN0U3RhdGUgPSB7XG4gICAgICBlbGVtZW50U2l6ZTogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpLFxuICAgICAgY2Fyb3VzZWxFbGVtZW50Q291bnQ6IHRoaXMuaXRlbUNvdW50LFxuICAgICAgd2lkdGg6IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIHRoaXMuaXRlbUNvdW50XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG5cbiAgICBpZiAoc2l6ZUluZm8udW5pdCA9PT0gJyUnKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzaXplSW5mby5udW1iZXIgLyAxMDAgKiBlbGVtZW50U2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplSW5mby51bml0ID09PSAncHgnKSB7XG4gICAgICByZXR1cm4gc2l6ZUluZm8ubnVtYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldEluaXRpYWxJbmRleCgpIHtcbiAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksIDEwKTtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInICYmICFpc05hTihpbmRleCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKSB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSAnaXRlbS0nICsgKHRoaXMuX2lzVmVydGljYWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyk7XG4gICAgY29uc3QgaXRlbVNpemVBdHRyID0gKCcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKS50cmltKCk7XG5cbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNpemUubWF0Y2goL14oXFxkKykocHh8JSkvKTtcblxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgIHVuaXQ6IG1hdGNoZXNbMl0sXG4gICAgfTtcbiAgfVxuXG4gIF9zZXR1cEluaXRpYWxJbmRleCgpIHtcbiAgICB0aGlzLl9zY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJyk7XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICB7IGR1cmF0aW9uOiAwLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScgfSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cbiAgICApO1xuXG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSk7XG4gICAgY29uc3Qgc2Nyb2xsID0gKHRoaXMuX29mZnNldCB8fCAwKSArIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIGluZGV4O1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgdGhpcy5fc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsLCBvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZUluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOBjOi/lOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBleOCjOOBpuOBhOOCi29ucy1jYXJvdXNlbC1pdGVt6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZUluZGV4KCkge1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtICh0aGlzLl9vZmZzZXQgfHwgMCk7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoc2l6ZSAqIGkgPD0gc2Nyb2xsICYmIHNpemUgKiAoaSArIDEpID4gc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1heCBjYXJvdXNlbCBpbmRleFxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2lzRW5hYmxlZENoYW5nZUV2ZW50KCkge1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICBjb25zdCBjYXJvdXNlbEl0ZW1TaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuYXV0b1Njcm9sbCAmJiBNYXRoLmFicyhlbGVtZW50U2l6ZSAtIGNhcm91c2VsSXRlbVNpemUpIDwgMC41O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgX3ByZXBhcmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdMb2NrVG9BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHRoaXMucmVmcmVzaCgpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVN3aXBlYWJsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZUF1dG9SZWZyZXNoKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuXG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLnN3aXBlYWJsZSkge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93bicsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBdXRvUmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKSkge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKSB7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5nZXRBY3RpdmVJbmRleCgpO1xuXG4gICAgaWYgKHRoaXMuX2xhc3RBY3RpdmVJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICBjb25zdCBsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjdXJyZW50SW5kZXg7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgIGFjdGl2ZUluZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgIGxhc3RBY3RpdmVJbmRleDogbGFzdEFjdGl2ZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfaXNXcm9uZ0RpcmVjdGlvbihkKSB7XG4gICAgLy8gdGhpcy5fbGFzdERyYWdEaXJlY3Rpb24gPSBkO1xuICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsKCkgPyAoZCA9PT0gJ2xlZnQnIHx8IGQgPT09ICdyaWdodCcpIDogKGQgPT09ICd1cCcgfHwgZCA9PT0gJ2Rvd24nKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNXcm9uZ0RpcmVjdGlvbihldmVudC5nZXN0dXJlLmRpcmVjdGlvbikgfHwgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIGV2ZW50LnRhcmdldC50eXBlID09PSAncmFuZ2UnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5fbGFzdERyYWdFdmVudCA9IGV2ZW50O1xuXG4gICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XG4gICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICghdGhpcy5fbGFzdERyYWdFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudFNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuXG4gICAgLy8gaWYgKCF0aGlzLl9pc1dyb25nRGlyZWN0aW9uKHRoaXMuX2xhc3REcmFnRGlyZWN0aW9uKSAmJiB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCkgIT09IDApIHtcbiAgICAvLyAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwodGhpcy5fc2Nyb2xsKSkge1xuICAgICAgbGV0IHdhaXRGb3JBY3Rpb24gPSBmYWxzZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3ZlcnNjcm9sbCcsIHtcbiAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgIGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KCksXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5fZ2V0T3ZlclNjcm9sbERpcmVjdGlvbigpLFxuICAgICAgICB3YWl0VG9SZXR1cm46IChwcm9taXNlKSA9PiB7XG4gICAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXdhaXRGb3JBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGFydE1vbWVudHVtU2Nyb2xsKCk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3REcmFnRXZlbnQgPSBudWxsO1xuXG4gICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFpdFxuICAgKi9cbiAgX21peGluKHRyYWl0KSB7XG4gICAgT2JqZWN0LmtleXModHJhaXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzW2tleV0gPSB0cmFpdFtrZXldO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbCgpIHtcbiAgICBpZiAodGhpcy5fbGFzdERyYWdFdmVudCkge1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRTY3JvbGxWZWxvY2l0eSh0aGlzLl9sYXN0RHJhZ0V2ZW50KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gMC4zO1xuICAgICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBkdXJhdGlvbiAqIDEwMCAqIHZlbG9jaXR5O1xuICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIHRoaXMuX3Njcm9sbCArICh0aGlzLl9nZXRTY3JvbGxEZWx0YSh0aGlzLl9sYXN0RHJhZ0V2ZW50KSA+IDAgPyAtc2Nyb2xsRGVsdGEgOiBzY3JvbGxEZWx0YSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcblxuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSh0aGlzLl9zY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICBpZiAoIXRoaXMuYXV0b1Njcm9sbCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgc2Nyb2xsKSk7XG4gICAgfVxuICAgIGxldCBhcnIgPSBbXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuICAgIGNvbnN0IG5ick9mSXRlbXMgPSB0aGlzLml0ZW1Db3VudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJyT2ZJdGVtczsgaSsrKSB7XG4gICAgICBpZiAoaSAqIHNpemUgKyB0aGlzLl9vZmZzZXQgPCBtYXgpIHtcbiAgICAgICAgYXJyLnB1c2goaSAqIHNpemUgKyB0aGlzLl9vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBhcnIucHVzaChtYXgpO1xuXG4gICAgYXJyLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIGxlZnQgPSBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKTtcbiAgICAgIHJpZ2h0ID0gTWF0aC5hYnMocmlnaHQgLSBzY3JvbGwpO1xuXG4gICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgIH0pO1xuXG4gICAgYXJyID0gYXJyLmZpbHRlcihmdW5jdGlvbihpdGVtLCBwb3MpIHtcbiAgICAgIHJldHVybiAhcG9zIHx8IGl0ZW0gIT0gYXJyW3BvcyAtIDFdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleCAqIHNpemUgKyB0aGlzLl9vZmZzZXQ7XG4gICAgY29uc3Qgc2Nyb2xsUmF0aW8gPSBNYXRoLmFicyhzY3JvbGwgLSBsYXN0U2Nyb2xsKSAvIHNpemU7XG4gICAgbGV0IHJlc3VsdCA9IGFyclswXTtcblxuICAgIGlmIChzY3JvbGxSYXRpbyA8PSB0aGlzLmF1dG9TY3JvbGxSYXRpbykge1xuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICB9IGVsc2UgaWYgKHNjcm9sbFJhdGlvIDwgMS4wKSB7XG4gICAgICBpZiAoYXJyWzBdID09PSBsYXN0U2Nyb2xsICYmIGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJlc3VsdCA9IGFyclsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCByZXN1bHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbilcbiAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWNhcm91c2VsLWl0ZW0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRcbiAgICovXG4gIF9zY3JvbGxUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGlzT3ZlcnNjcm9sbGFibGUgPSB0aGlzLm92ZXJzY3JvbGxhYmxlO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplU2Nyb2xsID0gKHNjcm9sbCkgPT4ge1xuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xuXG4gICAgICBpZiAoc2Nyb2xsIDwgMCkge1xuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IE1hdGgucm91bmQoc2Nyb2xsICogcmF0aW8pIDogMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG4gICAgICBpZiAobWF4U2Nyb2xsIDwgc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpc092ZXJzY3JvbGxhYmxlID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcm9sbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSlcbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb24gICE9PSAnbm9uZScgPyBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgOiB7fSlcbiAgICAgICAgLnBsYXkoKCkgPT4ge1xuICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVNYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgLSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2lzT3ZlclNjcm9sbChzY3JvbGwpIHtcbiAgICBpZiAoc2Nyb2xsIDwgMCB8fCBzY3JvbGwgPiB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwgPD0gMCA/ICd1cCcgOiAnZG93bic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwgPD0gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICB9XG5cbiAgX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSAwLjQ7XG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsIDwgMCkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSgwKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgaWYgKG1heFNjcm9sbCA8IHRoaXMuX3Njcm9sbCkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShtYXhTY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNCwgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICAgIHRoaXMuX3Njcm9sbCA9IG1heFNjcm9sbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAc2lnbmF0dXJlIHJlZnJlc2goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhlIGNhcm91c2VsLiBVc2VkIHdoZW4gYWRkaW5nIGA8b25zLWNhcm91c2VsLWl0ZW1zPmAgZHluYW1pY2FsbHkgb3IgdG8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIHNpemUuWy9lbl1cbiAgICogICBbamFd44Os44Kk44Ki44Km44OI44KE5YaF6YOo44Gu54q25oWL44KS5pyA5paw44Gu44KC44Gu44Gr5pu05paw44GX44G+44GZ44CCb25zLWNhcm91c2VsLWl0ZW3jgpLli5XnmoTjgavlopfjgoTjgZfjgZ/jgorjgIFvbnMtY2Fyb3VzZWzjga7lpKfjgY3jgZXjgpLli5XnmoTjgavlpInjgYjjgovpmpvjgavliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICAvLyBCdWcgZml4XG4gICAgaWYgKHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gICAgdGhpcy5fc2V0dXAoKTtcblxuICAgIGlmICh0aGlzLl9sYXN0U3RhdGUgJiYgdGhpcy5fbGFzdFN0YXRlLndpZHRoID4gMCkge1xuICAgICAgbGV0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbDsvLyAtIHRoaXMuX29mZnNldDtcblxuICAgICAgaWYgKHRoaXMuX2lzT3ZlclNjcm9sbChzY3JvbGwpKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbihzY3JvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zYXZlTGFzdFN0YXRlKCk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3JlZnJlc2gnLCB7Y2Fyb3VzZWw6IHRoaXN9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoXG4gICAgICBNYXRoLm1heCh0aGlzLml0ZW1Db3VudCAtIDEsIDApLCBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3ByZXBhcmVFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5fc2V0dXAoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnc3dpcGVhYmxlJywgJ2F1dG8tcmVmcmVzaCcsICdkaXJlY3Rpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVTd2lwZWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl91cGRhdGVBdXRvUmVmcmVzaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgIHRoaXMuX29uRGlyZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby4gWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGxSYXRpbygpIHtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJyk7XG5cbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHJldHVybiAwLjU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsUmF0aW8gPSBwYXJzZUZsb2F0KGF0dHIpO1xuICAgIGlmIChzY3JvbGxSYXRpbyA8IDAuMCB8fCBzY3JvbGxSYXRpbyA+IDEuMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhdGlvLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpc05hTihzY3JvbGxSYXRpbykgPyAwLjUgOiBzY3JvbGxSYXRpbztcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsUmF0aW8ocmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPCAwLjAgfHwgcmF0aW8gPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nLCByYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgYXV0byBzY3JvbGwgaXMgZW5hYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0by1zY3JvbGwnKTtcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIG92ZXJzY3JvbGxhYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1vdmVyc2Nyb2xs44Gn44GN44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3ZlcnNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdvdmVyc2Nyb2xsYWJsZScpO1xuICB9XG5cbiAgc2V0IG92ZXJzY3JvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdvdmVyc2Nyb2xsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2VudGVyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjZW50ZXJlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdY2VudGVyZWTnirbmhYvjgavjgarjgaPjgabjgYTjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjZW50ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NlbnRlcmVkJyk7XG4gIH1cblxuICBzZXQgY2VudGVyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NlbnRlcmVkJywgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncG9zdGNoYW5nZScsICdyZWZyZXNoJywgJ292ZXJzY3JvbGwnXTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbCcsIENhcm91c2VsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNvbFxuICogQGNhdGVnb3J5IGdyaWRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGNvbHVtbiBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIGA8b25zLXJvdz5gIHRvIGxheW91dCBjb21wb25lbnRzLlsvZW5dXG4gKiAgIFtqYV3jgrDjg6rjg4Pjg4njgrfjgrnjg4bjg6DjgavjgabliJfjgpLlrprnvqnjgZfjgb7jgZnjgIJvbnMtcm9344Go44Go44KC44Gr5L2/55So44GX44CB44Kz44Oz44Od44O844ON44Oz44OI44Gu44Os44Kk44Ki44Km44OI44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBub3RlXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2x1bW4sIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSBhbGlnbm1lbnQuWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29sdW1u44KS57WE44G/5ZCI44KP44Gb44Gf5aC05ZCI44Gr5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICogQGd1aWRlIGxheW91dGluZyBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1bamFd44Os44Kk44Ki44Km44OI5qmf6IO9Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yb3dcbiAqICAgW2VuXVRoZSBgPG9ucy1yb3c+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBvZiBgPG9ucy1jb2w+YC5bL2VuXVxuICogICBbamFdb25zLXJvd+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yb3c+XG4gKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICogPC9vbnMtcm93PlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgXCJ0b3BcIiwgXCJjZW50ZXJcIiwgYW5kIFwiYm90dG9tXCIuWy9lbl1cbiAqICAgW2phXee4puOBrumFjee9ruOCkuaMh+WumuOBmeOCi+OAglwidG9wXCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB3aWR0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgY3NzIHdpZHRoIHZhbHVlcyAoXCIxMCVcIiwgXCI1MHB4XCIpLlsvZW5dXG4gKiAgIFtqYV3jgqvjg6njg6Djga7mqKrluYXjgpLmjIflrprjgZnjgovjgILjg5Hjg7zjgrvjg7Pjg4jjgoLjgZfjgY/jga/jg5Tjgq/jgrvjg6vjgafmjIflrprjgZfjgb7jgZnvvIgxMCXjgoQ1MHB477yJ44CCWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3aWR0aCA9ICgnJyArIHdpZHRoKS50cmltKCk7XG4gICAgICB3aWR0aCA9IHdpZHRoLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHRoaXMuc3R5bGUud2Via2l0Qm94RmxleCA9ICcwJztcbiAgICAgIHRoaXMuc3R5bGUud2Via2l0RmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tb3pCb3hGbGV4ID0gJzAnO1xuICAgICAgdGhpcy5zdHlsZS5tb3pGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1zRmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5mbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1heFdpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNvbCcsIENvbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBjbGFzcyBEaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0RpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge0RpYWxvZ0FuaW1hdG9yLCBJT1NEaWFsb2dBbmltYXRvciwgQW5kcm9pZERpYWxvZ0FuaW1hdG9yLCBTbGlkZURpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uLy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuZGlhbG9nJzogJ2RpYWxvZy0tKicsXG4gICcuZGlhbG9nLWNvbnRhaW5lcic6ICdkaWFsb2ctY29udGFpbmVyLS0qJyxcbiAgJy5kaWFsb2ctbWFzayc6ICdkaWFsb2ctbWFzay0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgOiBJT1NEaWFsb2dBbmltYXRvcixcbiAgJ3NsaWRlJzogU2xpZGVEaWFsb2dBbmltYXRvcixcbiAgJ25vbmUnOiBEaWFsb2dBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZGlhbG9nXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpYWxvZyB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgY3VycmVudCBzY3JlZW4uIEFzIG9wcG9zZWQgdG8gdGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQsIHRoaXMgY29tcG9uZW50IGNhbiBjb250YWluIGFueSBraW5kIG9mIGNvbnRlbnQuXG4gKlxuICogICAgIFRvIHVzZSB0aGUgZWxlbWVudCBpdCBjYW4gZWl0aGVyIGJlIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBgPGJvZHk+YCBlbGVtZW50IG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZURpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqXG4gKiAgICAgVGhlIGRpYWxvZyBpcyB1c2VmdWwgZm9yIGRpc3BsYXlpbmcgbWVudXMsIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgdG8gYXNrIHRoZSB1c2VyIHRvIG1ha2UgYSBkZWNpc2lvbi5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB6eHhhR2FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYWxlcnQtZGlhbG9nXG4gKiAgIFtlbl1gPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1kaWFsb2cgaWQ9XCJkaWFsb2dcIj5cbiAqICAgPHA+VGhpcyBpcyBhIGRpYWxvZyE8L3A+XG4gKiA8L29ucy1kaWFsb2c+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6Z2e6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9ICgpID0+IHRoaXMuX2NhbmNlbCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XG4gICAgICBkaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBEaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNEaWFsb2dFbGVtZW50LkRpYWxvZ0FuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBEaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gRGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZGlhbG9nJywgRGlhbG9nRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnZmFiJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2ZhYi0tKicsXG4gICcuZmFiX19pY29uJzogJ2ZhYi0tKl9faWNvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWZhYlxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gaXMgYSBjaXJjdWxhciBidXR0b24gZGVmaW5lZCBpbiB0aGUgW01hdGVyaWFsIERlc2lnbiBzcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvYnV0dG9ucy1mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmh0bWwpLiBUaGV5IGFyZSBvZnRlbiB1c2VkIHRvIHByb21vdGUgdGhlIHByaW1hcnkgYWN0aW9uIG9mIHRoZSBhcHAuXG4gKlxuICogICAgIEl0IGNhbiBiZSBkaXNwbGF5ZWQgZWl0aGVyIGFzIGFuIGlubGluZSBlbGVtZW50IG9yIGluIG9uZSBvZiB0aGUgY29ybmVycy4gTm9ybWFsbHkgaXQgd2lsbCBiZSBwb3NpdGlvbmVkIGluIHRoZSBsb3dlciByaWdodCBjb3JuZXIgb2YgdGhlIHNjcmVlbi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZmFiXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50IGlzIGEgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiB0aGF0IGRpc3BsYXlzIGEgbWVudSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uLiBTaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBgXCJib3R0b20gcmlnaHRcImAgb3IgYFwidG9wIGxlZnRcImAuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBjYW4gYmUgZXhlY3V0ZWQgYmVmb3JlIGNvbnRlbnRSZWFkeVxuICAgIC8vIHNpbmNlIHRoZXNlIGRvIG5vdCBhY2Nlc3MgdGhlIGNoaWxkcmVuXG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmZhYl9faWNvbicpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcblxuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnNob3coKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAncG9zaXRpb24nLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaGlkZSgpKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZS50cmFuc2Zvcm0gPT09ICdzY2FsZSgxKScgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWZhYicsIEZhYkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWdlc3R1cmUtZGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBGb2xsb3dpbmcgZ2VzdHVyZXMgYXJlIHN1cHBvcnRlZDpcbiAqICAgICAtIERyYWcgZ2VzdHVyZXM6IGBkcmFnYCwgYGRyYWdsZWZ0YCwgYGRyYWdyaWdodGAsIGBkcmFndXBgLCBgZHJhZ2Rvd25gXG4gKiAgICAgLSBIb2xkIGdlc3R1cmVzOiBgaG9sZGAsIGByZWxlYXNlYFxuICogICAgIC0gU3dpcGUgZ2VzdHVyZXM6IGBzd2lwZWAsIGBzd2lwZWxlZnRgLCBgc3dpcGVyaWdodGAsIGBzd2lwZXVwYCwgYHN3aXBlZG93bmBcbiAqICAgICAtIFRhcCBnZXN0dXJlczogYHRhcGAsIGBkb3VibGV0YXBgXG4gKiAgICAgLSBQaW5jaCBnZXN0dXJlczogYHBpbmNoYCwgYHBpbmNoaW5gLCBgcGluY2hvdXRgXG4gKiAgICAgLSBPdGhlciBnZXN0dXJlczogYHRvdWNoYCwgYHRyYW5zZm9ybWAsIGByb3RhdGVgXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3opoHntKDlhoXjga7jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjgpLmpJznn6XjgZfjgb7jgZnjgILoqbPjgZfjgY/jga/jgqzjgqTjg4njgpLlj4LnhafjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICogQGd1aWRlIGdlc3R1cmUtZGV0ZWN0b3JcbiAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44O85pON5L2c44Gu5qSc55+lWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKiAgIDxkaXYgaWQ9XCJkZXRlY3QtYXJlYVwiIHN0eWxlPVwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDEwMHB4O1wiPlxuICogICAgIFN3aXBlIEhlcmVcbiAqICAgPC9kaXY+XG4gKiA8L29ucy1nZXN0dXJlLWRldGVjdG9yPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXBlbGVmdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgaWYgKGV2ZW50LnRhcmdldC5tYXRjaGVzKCcjZGV0ZWN0LWFyZWEnKSkge1xuICogICAgICAgY29uc29sZS5sb2coJ1N3aXBlIGxlZnQgaXMgZGV0ZWN0ZWQuJyk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICBpbml0KCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWNvblxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5cyBhbiBpY29uLiBUaGUgZm9sbG93aW5nIGljb24gc3VpdGVzIGFyZSBhdmFpbGFibGU6XG4gKlxuICogICAgICogW0ZvbnQgQXdlc29tZV0oaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lLylcbiAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbS8pXG4gKiAgICAgKiBbTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250XShodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LylcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4QWh2Z1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ljb25cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pY29uXG4gKiAgIGljb249XCJtZC1jYXJcIlxuICogICBzaXplPVwiMjBweFwiXG4gKiAgIHN0eWxlPVwiY29sb3I6IHJlZFwiPlxuICogPC9vbnMtaWNvbj5cbiAqXG4gKiA8b25zLWJ1dHRvbj5cbiAqICAgPG9ucy1pY29uIGljb249XCJtZC1jYXJcIj48L29ucy1pY29uPlxuICogICBDYXJcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lLiBgXCJtZC1cImAgcHJlZml4IGZvciBNYXRlcmlhbCBJY29ucywgYFwiZmEtXCJgIGZvciBGb250IEF3ZXNvbWUgYW5kIGBcImlvbi1cImAgcHJlZml4IGZvciBJb25pY29ucy5cbiAgICpcbiAgICogICAgIFNlZSBhbGwgYXZhaWxhYmxlIGljb25zIG9uIHRoZWlyIHJlc3BlY3RpdmUgc2l0ZXM6XG4gICAqXG4gICAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gICAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbSlcbiAgICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gICAqXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlOlxuICAgKlxuICAgKiAgICAgYGBgXG4gICAqICAgICA8b25zLWljb25cbiAgICogICAgICAgaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIGRpc3BsYXkgYFwibWQtZWRpdFwiYCBmb3IgTWF0ZXJpYWwgRGVzaWduIGFuZCBgXCJpb24tZWRpdFwiYCBhcyB0aGUgZGVmYXVsdCBpY29uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdFwiXG4gICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHNwaW5uaW5nLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChbJ2ljb24nLCAnc2l6ZScsICdtb2RpZmllciddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fdXBkYXRlKCkpOyAvLyBGaXggZm9yIGJpbmRpbmdzXG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fZ2V0QXR0cmlidXRlKCdpY29uJyksIHRoaXMuX2dldEF0dHJpYnV0ZSgnc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX2dldEF0dHJpYnV0ZShhdHRyKSB7XG4gICAgY29uc3QgcGFydHMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgJycpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcbiAgICBsZXQgbWQgPSBwYXJ0c1sxXTtcbiAgICBtZCA9IChtZCB8fCAnJykuc3BsaXQoL1xccyo6XFxzKi8pO1xuICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgKi9cbiAgX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKSB7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiAvXihmYSR8ZmEtfGlvbi18em1kaS0pLy50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd6bWRpJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvbnMtaWNvbi0taW9uJyk7XG4gIH1cblxuICBfYnVpbGRDbGFzc0FuZFN0eWxlKGljb25OYW1lLCBzaXplKSB7XG4gICAgY29uc3QgY2xhc3NMaXN0ID0gWydvbnMtaWNvbiddO1xuICAgIGNvbnN0IHN0eWxlID0ge307XG5cbiAgICAvLyBJY29uXG4gICAgaWYgKGljb25OYW1lLmluZGV4T2YoJ2lvbi0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS1pb24nKTtcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lLmluZGV4T2YoJ2ZhLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEnKTtcbiAgICB9IGVsc2UgaWYoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC9cXC0oLispPy8pWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEtJyArIGljb25OYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWNvbicsIEljb25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQge0xhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyfSBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1sYXp5LXJlcGVhdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXNpbmcgdGhpcyBjb21wb25lbnQgYSBsaXN0IHdpdGggbWlsbGlvbnMgb2YgaXRlbXMgY2FuIGJlIHJlbmRlcmVkIHdpdGhvdXQgYSBkcm9wIGluIHBlcmZvcm1hbmNlLlxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcbiAqICAgICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBET00gd2hlbiB0aGV5IGFyZSBub3QgdmlzaWJsZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOWGheOBp+aPj+eUu+OBleOCjOOCi+OCouOCpOODhuODoOOBrkRPTeimgee0oOOBruiqreOBv+i+vOOBv+OBr+OAgeeUu+mdouOBq+imi+OBiOOBneOBhuOBq+OBquOBo+OBn+aZguOBvuOBp+iHquWLleeahOOBq+mBheW7tuOBleOCjOOAgVxuICogICAgIOeUu+mdouOBi+OCieimi+OBiOOBquOBj+OBquOBo+OBn+WgtOWQiOOBq+OBr+OBneOBruimgee0oOOBr+WLleeahOOBq+OCouODs+ODreODvOODieOBleOCjOOBvuOBmeOAglxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXdyR0JtXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGF6eS1yZXBlYXRcbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGVsZW1lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBsaXN0LlsvZW5dXG4gKiAgIFtqYV1gPG9ucy1saXN0PmDopoHntKDjga/jg6rjgrnjg4jjgpLmj4/nlLvjgZnjgovjga7jgavkvb/jgo/jgozjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHVzZWQgdG8gc2V0IHRoZSBkZWxlZ2F0ZSBvYmplY3QuJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxhenktcmVwZWF0JywgTGF6eVJlcGVhdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaGVhZGVyJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtaGVhZGVyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaGVhZGVyXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1IZWFkZXIgZWxlbWVudCBmb3IgbGlzdCBpdGVtcy4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jopoHntKDjgavkvb/nlKjjgZnjgovjg5jjg4Pjg4Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLWxpc3QtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBsaXN0cyBbZW5dVXNpbmcgbGlzdHNbL2VuXVtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBoZWFkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiA8L29ucy1saXN0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SGVhZGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaGVhZGVyLlsvZW5dXG4gICAqICAgW2phXeODmOODg+ODgOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWhlYWRlcicsIExpc3RIZWFkZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaXRlbSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcubGlzdC1pdGVtJzogJ2xpc3QtaXRlbS0tKicsXG4gICcubGlzdC1pdGVtX19sZWZ0JzogJ2xpc3QtaXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdC1pdGVtX19jZW50ZXInOiAnbGlzdC1pdGVtLS0qX19jZW50ZXInLFxuICAnLmxpc3QtaXRlbV9fcmlnaHQnOiAnbGlzdC1pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdC1pdGVtX19sYWJlbCc6ICdsaXN0LWl0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0LWl0ZW1fX3RpdGxlJzogJ2xpc3QtaXRlbS0tKl9fdGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fc3VidGl0bGUnOiAnbGlzdC1pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdC1pdGVtX190aHVtYm5haWwnOiAnbGlzdC1pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3QtaXRlbV9faWNvbic6ICdsaXN0LWl0ZW0tLSpfX2ljb24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWl0ZW1cbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgdGFwcGFibGVcbiAqICAgW2VuXU1ha2UgdGhlIGxpc3QgaXRlbSBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIGl0J3MgdGFwcGVkLiBPbiBpT1MgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgXCJ0YXBwYWJsZVwiIGFuZCBcInRhcC1iYWNrZ3JvdW5kLWNvbG9yXCIgYXR0cmlidXRlIGZvciBiZXR0ZXIgYmVoYXZpb3Igd2hlbiBzY3JvbGxpbmcuWy9lbl1cbiAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBl+OBn+aZguOBq+WKueaenOOBjOihqOekuuOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY2hldnJvblxuICogICBbZW5dRGlzcGxheSBhIGNoZXZyb24gYXQgdGhlIHJpZ2h0IGVuZCBvZiB0aGUgbGlzdCBpdGVtIGFuZCBtYWtlIGl0IGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gdGFwcGVkLiBUaGUgY2hldnJvbiBpcyBub3QgZGlzcGxheWVkIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBsb25nZGl2aWRlclxuICogICBbZW5dRGlzcGxheXMgYSBsb25nIGhvcml6b250YWwgZGl2aWRlciBiZXR3ZWVuIGl0ZW1zLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vZGl2aWRlclxuICogICBbZW5dUmVtb3ZlcyB0aGUgZGl2aWRlciBiZXR3ZWVuIGxpc3QgaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBpdGVtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGVhY2ggaXRlbSBpbiB0aGUgbGlzdC4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlxuICpcbiAqICAgICBUaGUgbGlzdCBpdGVtIGlzIGNvbXBvc2VkIG9mIHRocmVlIHBhcnRzIHRoYXQgYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIGBsZWZ0YCwgYGNlbnRlcmAgYW5kIGByaWdodGAgY2xhc3Nlcy4gVGhlc2UgY2xhc3NlcyBjYW4gYmUgdXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgY29udGVudCBvZiB0aGUgbGlzdCBpdGVtcyBpcyBwcm9wZXJseSBhbGlnbmVkLlxuICpcbiAqICAgICBgYGBcbiAqICAgICA8b25zLWxpc3QtaXRlbT5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+TGVmdDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPkNlbnRlcjwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+UmlnaHQ8L2Rpdj5cbiAqICAgICA8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgYGBgXG4gKlxuICogICAgIFRoZXJlIGlzIGFsc28gYSBudW1iZXIgb2YgY2xhc3NlcyAocHJlZml4ZWQgd2l0aCBgbGlzdC1pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgbGlzdHNcbiAqICAgW2VuXVVzaW5nIGxpc3RzWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3QtaXRlbT5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cIm1kLWZhY2VcIiBjbGFzcz1cImxpc3QtaXRlbV9faWNvblwiPjwvb25zLWljb24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3QtaXRlbV9fdGl0bGVcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1saXN0LWl0ZW0+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3lkITopoHntKDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YXAtYmFja2dyb3VuZC1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl0gQ2hhbmdlcyB0aGUgYmFja2dyb3VuZCBjb2xvciB3aGVuIHRhcHBlZC4gRm9yIHRoaXMgdG8gd29yaywgdGhlIGF0dHJpYnV0ZSBcInRhcHBhYmxlXCIgbmVlZHMgdG8gYmUgc2V0LiBUaGUgZGVmYXVsdCBjb2xvciBpcyBcIiNkOWQ5ZDlcIi4gSXQgd2lsbCBkaXNwbGF5IGFzIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGxldCBsZWZ0LCBjZW50ZXIsIHJpZ2h0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2xlZnQnKTtcbiAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICBjZW50ZXIgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX3JpZ2h0Jyk7XG4gICAgICAgIHJpZ2h0ID0gZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgIGNlbnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgICBjZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGlmIChlbCAhPT0gbGVmdCAmJiBlbCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICAgIGNlbnRlci5pbnNlcnRCZWZvcmUoZWwsIGNlbnRlci5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY2VudGVyLCByaWdodCB8fCBudWxsKTtcbiAgICB9XG5cbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fY2VudGVyJyk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIGdldCBfdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnO1xuICB9XG5cbiAgZ2V0IF90YXBwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gIH1cblxuICBnZXQgX3RhcEJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhcC1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgJyNkOWQ5ZDknO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBnZXN0dXJlID0gZXZlbnQuZ2VzdHVyZTtcbiAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxuICAgIGlmICh0aGlzLl9zaG91bGRMb2NrT25EcmFnKCkgJiYgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihnZXN0dXJlLmRpcmVjdGlvbikgPiAtMSkge1xuICAgICAgZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoKCkge1xuICAgIGlmICh0aGlzLnRhcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFwcGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcbiAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuXG4gICAgaWYgKHRoaXMuX3RhcHBhYmxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl90YXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dGhpcy5fdGFwQmFja2dyb3VuZENvbG9yfWA7XG4gICAgfVxuICB9XG5cbiAgX29uUmVsZWFzZSgpIHtcbiAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gJyc7XG5cbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHRoaXMuc3R5bGUuYm94U2hhZG93ID0gJyc7XG4gIH1cblxuICBfc2hvdWxkTG9ja09uRHJhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaXRlbScsIExpc3RJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbGlzdCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3RcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgaW5zZXRcbiAqICAgW2VuXUluc2V0IGxpc3QgdGhhdCBkb2Vzbid0IGNvdmVyIHRoZSB3aG9sZSB3aWR0aCBvZiB0aGUgcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3opqropoHntKDjga7nlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgonjgarjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgIFtlbl1BIGxpc3Qgd2l0aCBubyBib3JkZXJzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ29tcG9uZW50IHRvIGRlZmluZSBhIGxpc3QsIGFuZCB0aGUgY29udGFpbmVyIGZvciBvbnMtbGlzdC1pdGVtKHMpLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLooajnj77jgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdC1pdGVt44Gu44Kz44Oz44OG44OK44Go44GX44Gm5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXW9ucy1saXN0LWl0ZW0gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGF6eS1yZXBlYXRcbiAqICAgW2VuXW9ucy1sYXp5LXJlcGVhdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxhenktcmVwZWF044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBsaXN0c1xuICogICBbZW5dVXNpbmcgbGlzdHNbL2VuXVxuICogICBbamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSBpbmZpbml0ZS1zY3JvbGxcbiAqICAgW2VuXUxvYWRpbmcgbW9yZSBpdGVtcyBvbiBpbmZpbml0ZSBzY3JvbGxbL2VuXVxuICogICBbamFdTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZSArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdCcsIExpc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENoZWNrYm94Q2xhc3MgPSAnY2hlY2tib3gnO1xuY29uc3QgZGVmYXVsdFJhZGlvQnV0dG9uQ2xhc3MgPSAncmFkaW8tYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRleHQtaW5wdXQnOiAndGV4dC1pbnB1dC0tKicsXG4gICcudGV4dC1pbnB1dF9fbGFiZWwnOiAndGV4dC1pbnB1dC0tKl9fbGFiZWwnLFxuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnLFxuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21heGxlbmd0aCcsXG4gICdtaW4nLFxuICAnbWlubGVuZ3RoJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndHlwZScsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pbnB1dFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHVuZGVyYmFyXG4gKiAgW2VuXURpc3BsYXlzIGEgaG9yaXpvbnRhbCBsaW5lIHVuZGVybmVhdGggYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICBbZW5dRGlzcGxheXMgYSB0cmFuc3BhcmVudCBpbnB1dC4gV29ya3MgZm9yIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQW4gaW5wdXQgZWxlbWVudC4gVGhlIGB0eXBlYCBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbnB1dCB0eXBlLiBBbGwgdGV4dCBpbnB1dCB0eXBlcyBhcyB3ZWxsIGFzIGBjaGVja2JveGAgYW5kIGByYWRpb2AgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIG9qUXhMalxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lucHV0XG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIGFkZGluZy1wYWdlLWNvbnRlbnRcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaW5wdXQgcGxhY2Vob2xkZXI9XCJVc2VybmFtZVwiIGZsb2F0Pjwvb25zLWlucHV0PlxuICogPG9ucy1pbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPjwvb25zLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBsYWNlaG9sZGVyIHRleHQuIEluIE1hdGVyaWFsIERlc2lnbiwgdGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGEgZmxvYXRpbmcgbGFiZWwuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZmxvYXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdHlwZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBIb3dldmVyLCBmb3IgXCJyYW5nZVwiIHlvdSBzaG91bGQgaW5zdGVhZCB1c2UgPG9ucy1yYW5nZT4gZWxlbWVudC5cbiAgICpcbiAgICogICAgUGxlYXNlIHRha2UgYSBsb29rIGF0IFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLXR5cGUpIGZvciBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzLiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIGFuZCBicm93c2VyIHZlcnNpb24gc29tZSBvZiB0aGVzZSBtaWdodCBub3Qgd29yay5cbiAgICogIFsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2NoZWNrZWQnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNpbiA9IHRoaXMuX29uRm9jdXNpbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGhlbHBlci5jbGFzc0xpc3QuYWRkKCdfaGVscGVyJyk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcblxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2lucHV0LWxhYmVsJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KSk7XG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENoZWNrYm94Q2xhc3MpO1xuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCdjaGVja2JveF9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19jaGVja21hcmsnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0UmFkaW9CdXR0b25DbGFzcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9fY2hlY2ttYXJrJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fbGFiZWwnKTtcbiAgICAgICAgdGhpcy5faW5wdXQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19jb250YWluZXInKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcbiAgICAgIHRoaXMuX2lucHV0LmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lucHV0LWlkJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncGxhY2Vob2xkZXInLCAnaW5wdXQtaWQnLCAnY2hlY2tlZCcsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwbGFjZWhvbGRlcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVMYWJlbCgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dC1pZCc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5pZCA9IGN1cnJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2hlY2tib3hDbGFzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2hlY2tib3hDbGFzcyArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRSYWRpb0J1dHRvbkNsYXNzKSkge1xuICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRSYWRpb0J1dHRvbkNsYXNzICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lucHV0LnR5cGUgIT09ICdjaGVja2JveCcgJiYgdGhpcy5faW5wdXQudHlwZSAhPT0gJ3JhZGlvJykge1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX3NldExhYmVsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsKCkge1xuICAgIHRoaXMuX3NldExhYmVsKHRoaXMuaGFzQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgOiAnJyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoWydjaGVja2JveCcsICdyYWRpbyddLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkgPT09IC0xKXtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWxlZ2F0ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICBfb25JbnB1dChldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgfVxuXG4gIF9vbkZvY3VzaW4oZXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuX2hlbHBlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0ID09PSBudWxsXG4gICAgICA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICA6IHRoaXMuX2lucHV0LnZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGNoZWNrZWQgb3Igbm90LiBPbmx5IHdvcmtzIGZvciBgcmFkaW9gIGFuZCBgY2hlY2tib3hgIHR5cGUgaW5wdXRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBnZXQgX2lzVGV4dElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09ICdyYWRpbycgJiYgdGhpcy50eXBlICE9PSAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydjaGFuZ2UnLCAnaW5wdXQnLCAnZm9jdXMnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdibHVyJ107XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaW5wdXQnLCBJbnB1dEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZU1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBNb2RhbEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ21vZGFsLS0qJyxcbiAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xufTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdtb2RhbCc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBNb2RhbCBjb21wb25lbnQgdGhhdCBtYXNrcyBjdXJyZW50IHNjcmVlbi4gVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAqICAgWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5U2hvdygpKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIG1vZGFsIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44Gu6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc01vZGFsRWxlbWVudC5Nb2RhbEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBNb2RhbEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBNb2RhbEFuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW1vZGFsJywgTW9kYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgZHVyYXRpb246ICcwLjQnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGJsb2NrKHBhZ2UpIHtcbiAgICBjb25zdCBibG9ja2VyID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyB6LWluZGV4OiAxMDAwMDBcIj48L2Rpdj5cbiAgICBgKTtcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYmxvY2tlcik7XG4gICAgcmV0dXJuICgpID0+IGJsb2NrZXIucmVtb3ZlKCk7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgb3BhY2l0eTogMDsgei1pbmRleDogMlwiPjwvZGl2PlxuICAgIGApO1xuXG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFyID0gcGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gdG9vbGJhci5fZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKTtcbiAgICBjb25zdCByaWdodCA9IHRvb2xiYXIuX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpO1xuXG4gICAgY29uc3QgZXhjbHVkZUJhY2tCdXR0b24gPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b24obGVmdC5jaGlsZHJlbikpXG4gICAgICAuY29uY2F0KHJpZ2h0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHJpZ2h0IDogZXhjbHVkZUJhY2tCdXR0b24ocmlnaHQuY2hpbGRyZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyQ2VudGVyOiB0b29sYmFyLl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uSWNvbjogdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpLFxuICAgICAgYmFja0J1dHRvbkxhYmVsOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpLFxuICAgICAgb3RoZXI6IG90aGVyLFxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgIGJhY2tncm91bmQ6IHBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCksXG4gICAgICB0b29sYmFyOiB0b29sYmFyLFxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgIH07XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICBjb25zdCBib3RoUGFnZUhhc1Rvb2xiYXIgPVxuICAgICAgZW50ZXJQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpICYmIGxlYXZlUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKTtcblxuICAgIHZhciBub01hdGVyaWFsVG9vbGJhciA9XG4gICAgICAhZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygndG9vbGJhci0tbWF0ZXJpYWwnKSAmJlxuICAgICAgIWxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ3Rvb2xiYXItLW1hdGVyaWFsJyk7XG5cbiAgICByZXR1cm4gYm90aFBhZ2VIYXNUb29sYmFyICYmIG5vTWF0ZXJpYWxUb29sYmFyO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURlbHRhKGVsZW1lbnQsIGRlY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdGl0bGUsIGxhYmVsO1xuXG4gICAgY29uc3QgcGFnZVJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2JhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbFJlY3QgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZCgocGFnZVJlY3Qud2lkdGggLyAyKSAtIChsYWJlbFJlY3Qud2lkdGggLyAyKSAtIGxhYmVsUmVjdC5sZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKChwYWdlUmVjdC53aWR0aCAvIDIpICogMC42KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uSWNvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2JhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICAgIGxhYmVsID0gZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uSWNvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0aXRsZSwgbGFiZWx9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnRlbnRSZWFkeShlbnRlclBhZ2UsICgpID0+IHtcbiAgICAgIGNvbnN0IGVudGVyUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlO1xuICAgICAgY29uc3QgbGVhdmVQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UobGVhdmVQYWdlKSB8fCBsZWF2ZVBhZ2U7XG4gICAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZVRhcmdldCk7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uKTtcblxuICAgICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMC4wNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZVRhcmdldCwgbGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGZpeFxuICAgICAgICBjb25zdCBlbnRlclBhZ2VUb29sYmFySGVpZ2h0ID0gZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2suc3R5bGUudG9wID0gZW50ZXJQYWdlVG9vbGJhckhlaWdodDtcblxuICAgICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRvcDogZW50ZXJQYWdlVG9vbGJhckhlaWdodFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMjUlLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDF9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS50aXRsZSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEubGFiZWwgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG5cbiAgICAgICAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IGVudGVyUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlO1xuICAgIGNvbnN0IGxlYXZlUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlO1xuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlVGFyZ2V0KTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMC4xLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2VUYXJnZXQsIGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGNvbnN0IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQgPSBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2suc3R5bGUudG9wID0gZW50ZXJQYWdlVG9vbGJhckhlaWdodDtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS50aXRsZSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEubGFiZWwgKyAncHgsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDF9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRvcDogZW50ZXJQYWdlVG9vbGJhckhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQoMClcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMjUlLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YS50aXRsZSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogRmFkZS1pbiBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoW2VudGVyUGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgZW50ZXJQYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpXSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoW2xlYXZlUGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbGVhdmVQYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpXSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgei1pbmRleDogMjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+XG4gICAgYCk7XG4gICAgdGhpcy5ibGFja01hc2tPcGFjaXR5ID0gMC40O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHksXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAuMDUsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBGYWRlLWluICsgTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2Utb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMjV9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgNDJweCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjE1KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMzhweCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4wNClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1zbGlkZS1hbmltYXRvcic7XG5pbXBvcnQgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL25vbmUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlciwgaW5zdGFudFBhZ2VMb2FkZXJ9IGZyb20gJy4uLy4uL29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUtbWQnOiBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdC1pb3MnOiBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUtbWQnOiBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdub25lJzogTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShuYXZpZ2F0b3JFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW5hdmlnYXRvclxuICogQGNhdGVnb3J5IG5hdmlnYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQSBjb21wb25lbnQgdGhhdCBwcm92aWRlcyBwYWdlIHN0YWNrIG1hbmFnZW1lbnQgYW5kIG5hdmlnYXRpb24uIFN0YWNrIG5hdmlnYXRpb24gaXMgdGhlIG1vc3QgY29tbW9uIG5hdmlnYXRpb24gcGF0dGVybiBmb3IgbW9iaWxlIGFwcHMuXG4gKlxuICogICAgIFdoZW4gYSBwYWdlIGlzIHB1c2hlZCBvbiB0b3Agb2YgdGhlIHN0YWNrIGl0IGlzIGRpc3BsYXllZCB3aXRoIGEgdHJhbnNpdGlvbiBhbmltYXRpb24uIFdoZW4gdGhlIHVzZXIgcmV0dXJucyB0byB0aGUgcHJldmlvdXMgcGFnZSB0aGUgdG9wIHBhZ2Ugd2lsbCBiZSBwb3BwZWQgZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayBhbmQgaGlkZGVuIHdpdGggYW4gb3Bwb3NpdGUgdHJhbnNpdGlvbiBhbmltYXRpb24uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geXJodHZcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICAgW2VuXUd1aWRlIGZvciBwYWdlIG5hdmlnYXRpb25bL2VuXVxuICogICBbamFd44Oa44O844K444OK44OT44Ky44O844K344On44Oz44Gu5qaC6KaBWy9qYV1cbiAqIEBndWlkZSB0ZW1wbGF0ZXNcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBndWlkZSBjcmVhdGluZy1hLXBhZ2VcbiAqICAgW2VuXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2VuXVxuICogICBbamFdU2V0dGluZyB1cCBhIHBhZ2UgaW4gaXRzIGBpbml0YCBldmVudFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdG9vbGJhciBvbiB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGxldHMgdGhlIHVzZXIgcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbmF2aWdhdG9yIGlkPVwibmF2aWdhdG9yXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIFRpdGxlXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L29ucy10b29sYmFyPlxuICogICAgIDxwPlxuICogICAgICAgPG9ucy1idXR0b25cbiAqICAgICAgICAgb25jbGljaz1cImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXZpZ2F0b3InKS5wdXNoUGFnZSgncGFnZS5odG1sJylcIj5cbiAqICAgICAgICAgUHVzaCBwYWdlXG4gKiAgICAgICA8L29ucy1idXR0b24+XG4gKiAgICAgPC9wPlxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtbmF2aWdhdG9yPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJzdCBwYWdlIHRvIHNob3cgd2hlbiBuYXZpZ2F0b3IgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAgICogICBbamFd44OK44OT44Ky44O844K/44O844GM5Yid5pyf5YyW44GV44KM44Gf5pmC44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0uXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXB1c2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwdXNoLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXB1c2jlh6bnkIbjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXBvcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcG9wLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXBhZ2Xjga5wb3DjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLkuobjgZfjgabjgYvjgonnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wdXNo44GV44KM44GfcGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3Rwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC44KP44Gj44Gf5b6M44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm6KGo56S644GV44KM44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm5raI44GI44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IGFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3JGYWN0b3J5O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9wYWdlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtQYWdlTG9hZGVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdUGFnZUxvYWRlcuOCpOODs+OCueOCv+ODs+OCueOCkuagvOe0jeOBl+OBpuOBhOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKHBhZ2VMb2FkZXIpIHtcbiAgICBpZiAoIShwYWdlTG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgfVxuXG4gIF9nZXRQYWdlVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VcbiAgICogQHR5cGUgeyp9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV3liJ3mnJ/ljJbmmYLjgavoqq3jgb/ovrzjgoDjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJgcGFnZWDlsZ7mgKfjgafmjIflrprjgZfjgZ/lgKTjgojjgorjgoJgcGFnZWDjg5fjg63jg5Hjg4bjgqPjgavmjIflrprjgZfjgZ/lgKTjgpLlhKrlhYjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSwge2FuaW1hdGlvbjogJ25vbmUnfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlc1tpXS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2hpbGRyZW4gb2YgPG9ucy1uYXZpZ2F0b3I+IG5lZWQgdG8gYmUgb2YgdHlwZSA8b25zLXBhZ2U+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLnRvcFBhZ2UsICgpID0+XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50b3BQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCB7YW5pbWF0aW9uOiAnbm9uZSd9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwb3BQYWdlXG4gICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWZyZXNoXVxuICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKG51bGwsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHBvcFVwZGF0ZSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlQW5kUmVmcmVzaChvcHRpb25zLCBwb3BVcGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIF9wb3BQYWdlQW5kUmVmcmVzaChvcHRpb25zLCBwb3BVcGRhdGUpIHtcbiAgICB1dGlsLndhcm4oJ1xcJ3JlZnJlc2hcXCcgb3B0aW9uIGZvciBwdXNoUGFnZSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgcmVsZWFzZS4nKTtcblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAyO1xuICAgIGNvbnN0IG9sZFBhZ2UgPSB0aGlzLnBhZ2VzW2luZGV4XTtcblxuICAgIGlmICghdGhpcy5fcGFnZU1hcC5oYXMob2xkUGFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBwYWdlcyBkaXJlY3RseSBpbnNpZGUgdGhlIE5hdmlnYXRvci4gVXNlIG9ucy10ZW1wbGF0ZSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9wYWdlTWFwLmdldChvbGRQYWdlKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgcGFyYW1zOiBvbGRQYWdlLnB1c2hlZE9wdGlvbnMgPyBvbGRQYWdlLnB1c2hlZE9wdGlvbnMuZGF0YSA6IHt9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQob3B0aW9ucywgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG5cbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIGRhdGE6IG9sZFBhZ2UuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvbGRQYWdlLnB1c2hlZE9wdGlvbnMgfHwge31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUocGFnZUVsZW1lbnQsIG9sZFBhZ2UgPyBvbGRQYWdlIDogbnVsbCk7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKG9sZFBhZ2UpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcblxuICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpKTtcblxuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGxlbmd0aCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAyXTtcblxuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiB8fCAobGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMgPyBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb24gOiB1bmRlZmluZWQpO1xuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucyA/IGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgOiB7fSxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgICApO1xuXG4gICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gICAgICBhbmltYXRvci5wb3AodGhpcy5wYWdlc1tsZW5ndGggLSAyXSwgdGhpcy5wYWdlc1tsZW5ndGggLSAxXSwgY2FsbGJhY2spO1xuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuX2lzUnVubmluZyA9IGZhbHNlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gT25seSBuZWNlc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBudWxsIG9yIHVuZGVmaW5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAqICAgW2VuXUhUTUwgY29kZSB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYXMgYSBuZXcgcGFnZS4gT3ZlcndyaXRlcyBgcGFnZWAgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd6L+95Yqg44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBjb25zdCBwcmVwYXJlID0gcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgdGhpcy5fcGFnZU1hcC5zZXQocGFnZUVsZW1lbnQsIHBhZ2UpO1xuICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH0pO1xuICAgICAgcGFnZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBpbnN0YW50UGFnZUxvYWRlci5sb2FkKHtwYWdlOiBvcHRpb25zLnBhZ2VIVE1MLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBwcmVwYXJlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgX3B1c2hQYWdlKG9wdGlvbnMgPSB7fSwgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKTtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwge2FuaW1hdGlvbk9wdGlvbnN9LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgcGFnZUxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBlbnRlclBhZ2UgID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSBvcHRpb25zLmxlYXZlUGFnZSB8fCB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAyXTtcblxuICAgICAgaWYgKGVudGVyUGFnZS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZWxlbWVudHMgb2YgdHlwZSA8b25zLXBhZ2U+IGNhbiBiZSBwdXNoZWQgdG8gdGhlIG5hdmlnYXRvcicpO1xuICAgICAgfVxuXG4gICAgICBlbnRlclBhZ2UudXBkYXRlQmFja0J1dHRvbihwYWdlTGVuZ3RoIC0gMSk7XG5cbiAgICAgIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLnVubG9hZCA9IGVudGVyUGFnZS51bmxvYWQgfHwgb3B0aW9ucy51bmxvYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBlbnRlclBhZ2UuX3Nob3coKSk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVwbGFjZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZXBsYWNlUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVwbGFjZXMgdGhlIGN1cnJlbnQgdG9wIHBhZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjgpLmjIflrprjgZfjgZ/jg5rjg7zjgrjjgavnva7jgY3mj5vjgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVwbGFjZVBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVkVmFsdWUpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnNlcnRQYWdlXG4gICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBpbnNlcnRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5zZXJ0IHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjayB3aXRoIGF0IGEgcG9zaXRpb24gZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS44Oa44O844K444K544K/44OD44Kv44GuaW5kZXjjgafmjIflrprjgZfjgZ/kvY3nva7jgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG4gICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHBhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLnBhZ2VIVE1MIDogcGFnZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBpbnN0YW50UGFnZUxvYWRlciA6IHRoaXMuX3BhZ2VMb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuc2V0KHBhZ2VFbGVtZW50LCBwYWdlKTtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBhZ2VFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVzZXRUb1BhZ2VcbiAgICogQHNpZ25hdHVyZSByZXNldFRvUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsZWFycyBwYWdlIHN0YWNrIGFuZCBhZGRzIHRoZSBzcGVjaWZpZWQgcGFnZSB0byB0aGUgc3RhY2suIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444K544K/44OD44Kv44KS44Oq44K744OD44OI44GX44CB5oyH5a6a44GX44Gf44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlc2V0VG9QYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICh7cGFnZSwgb3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuXG4gICAgaWYgKCFvcHRpb25zLmFuaW1hdG9yICYmICFvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgb3B0aW9ucy5jYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdoaWxlICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFnZXNbMF0udXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMucGFnZSAmJiAhb3B0aW9ucy5wYWdlSFRNTCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBicmluZ1BhZ2VUb3BcbiAgICogQHNpZ25hdHVyZSBicmluZ1BhZ2VUb3AoaXRlbSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1cbiAgICogICBbZW5dUGFnZSBVUkwgb3IgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZSBpbiBuYXZpZ2F0b3IncyBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjga5VUkzjgYvjgoLjgZfjgY/jga9vbnMtbmF2aWdhdG9y44Gu44Oa44O844K444K544K/44OD44Kv44Gu44Kk44Oz44OH44OD44Kv44K55YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQnJpbmdzIHRoZSBnaXZlbiBwYWdlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc3RhY2sgaWYgaXQgYWxyZWFkeSBleGlzdHMgb3IgcHVzaGVzIGl0IGludG8gdGhlIHN0YWNrIGlmIGRvZXNuJ3QuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44Gu5LiA55Wq5LiK44Gr56e75YuV44GX44G+44GZ44CC44KC44GX5oyH5a6a44GX44Gf44Oa44O844K444GM54Sh44GL44Gj44Gf5aC05ZCI5paw44GX44GPcHVzaOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBicmluZ1BhZ2VUb3AoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YodHlwZW9mIGl0ZW0pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcGFnZSBuYW1lIG9yIHRoZSBpbmRleCBvZiBhbiBleGlzdGluZyBwYWdlLiBZb3Ugc3VwcGxpZWQgJyArIGl0ZW0pO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IHRoaXMuX25vcm1hbGl6ZUluZGV4KGl0ZW0pIDogdGhpcy5fbGFzdEluZGV4T2ZQYWdlKGl0ZW0pO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VzW2luZGV4XTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5wYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhZ2UpO1xuICAgIH1cbiAgICBpZiAoIXBhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgaXRlbSAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgcGFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgcGFnZS5zZXRBdHRyaWJ1dGUoJ19za2lwaW5pdCcsICcnKTtcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoKHBhZ2UgPT09IG51bGwgfHwgcGFnZSA9PT0gdW5kZWZpbmVkKSAmJiBvcHRpb25zLnBhZ2UpIHtcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2U7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHtwYWdlfSk7XG5cbiAgICByZXR1cm4ge3BhZ2UsIG9wdGlvbnN9O1xuICB9XG5cbiAgX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5wYWdlc1tpbmRleF0udXBkYXRlQmFja0J1dHRvbihpbmRleCA+IDApO1xuICAgIH1cbiAgfVxuXG4gIF9ub3JtYWxpemVJbmRleChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiBNYXRoLmFicyh0aGlzLnBhZ2VzLmxlbmd0aCArIGluZGV4KSAlIHRoaXMucGFnZXMubGVuZ3RoO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucG9wUGFnZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIH1cbiAgfVxuXG4gIF9sYXN0SW5kZXhPZlBhZ2UocGFnZU5hbWUpIHtcbiAgICBsZXQgaW5kZXg7XG4gICAgZm9yIChpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgaWYgKCF0aGlzLl9wYWdlTWFwLmhhcyh0aGlzLnBhZ2VzW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RoaXMgaXMgYnVnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZU5hbWUgPT09IHRoaXMuX3BhZ2VNYXAuZ2V0KHRoaXMucGFnZXNbaW5kZXhdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgX2VtaXRQcmVFdmVudChuYW1lLCBkYXRhID0ge30pIHtcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgbmFtZSwgdXRpbC5leHRlbmQoe1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9LCBkYXRhKSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3B1c2gnKTtcbiAgfVxuXG4gIF9lbWl0UHJlUG9wRXZlbnQoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3BvcCcsIHtcbiAgICAgIGxlYXZlUGFnZTogdGhpcy5wYWdlc1tsIC0gMV0sXG4gICAgICBlbnRlclBhZ2U6IHRoaXMucGFnZXNbbCAtIDJdXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiDmm7jjgY3nm7TjgZlcbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuICAgIHRoaXMuX3ZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICByZXR1cm4gcGFnZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBfdmVyaWZ5UGFnZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIFwib25zLXBhZ2VcIiBlbGVtZW50IHRvIFwib25zLW5hdmlnYXRvclwiLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VzXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db3B5IG9mIHRoZSBuYXZpZ2F0b3IncyBwYWdlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudC50YWdOYW1lID09PSAnT05TLVBBR0UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVmYXVsdCAgZmFsc2VcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBgcG9wUGFnZSgpYCBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIHNldCBfaXNSdW5uaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuICBnZXQgX2lzUnVubmluZygpIHtcbiAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBOYXZpZ2F0b3JFbGVtZW50Lk5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicpO1xuICAgIH1cblxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZXB1c2gnLCAncG9zdHB1c2gnLCAncHJlcG9wJywgJ3Bvc3Rwb3AnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b29sYmFyJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3Rvb2xiYXItLSonLFxuICAnLnRvb2xiYXJfX2xlZnQnOiAndG9vbGJhci0tKl9fbGVmdCcsXG4gICcudG9vbGJhcl9fY2VudGVyJzogJ3Rvb2xiYXItLSpfX2NlbnRlcicsXG4gICcudG9vbGJhcl9fcmlnaHQnOiAndG9vbGJhci0tKl9fcmlnaHQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dVHJhbnNwYXJlbnQgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vc2hhZG93XG4gKiAgIFtlbl1Ub29sYmFyIHdpdGhvdXQgc2hhZG93Wy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBq+W9seOCkuS7mOOBkeOBmuOBq+ihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGFkZGluZy1hLXRvb2xiYXIgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLWJvdHRvbS10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgIFRpdGxlXG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKiA8L29ucy1wYWdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgdGhlIHRvb2xiYXIgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9faWNvbicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXJfX3RpdGxlJyk7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIXRoaXMuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdsZWZ0Jyk7XG4gICAgICBjb25zdCByaWdodCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdyaWdodCcpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlblswXSAhPT0gbGVmdCB8fCB0aGlzLmNoaWxkcmVuWzFdICE9PSBjZW50ZXIgfHwgdGhpcy5jaGlsZHJlblsyXSAhPT0gcmlnaHQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjZW50ZXIpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckVsZW1lbnQobmFtZSkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRvb2xiYXJfXycgKyBuYW1lKSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudG9vbGJhcl9fJyArIG5hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuJyArIG5hbWUpIHx8IHV0aWwuY3JlYXRlKCcuJyArIG5hbWUpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndG9vbGJhcl9fJyArIG5hbWUpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhcicsIFRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uL29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuaW1wb3J0ICcuL29ucy10b29sYmFyJzsgLy8gZW5zdXJlcyB0aGF0ICdvbnMtdG9vbGJhcicgZWxlbWVudCBpcyByZWdpc3RlcmVkXG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncGFnZSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAncGFnZS0tKicsXG4gICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcbiAgJy5wYWdlX19iYWNrZ3JvdW5kJzogJ3BhZ2UtLSpfX2JhY2tncm91bmQnXG59O1xuXG5jb25zdCBudWxsVG9vbGJhckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtdG9vbGJhcicpOyAvLyByZXF1aXJlcyB0aGF0ICdvbnMtdG9vbGJhcicgZWxlbWVudCBpcyByZWdpc3RlcmVkXG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXBhZ2VcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IG9mIGVhY2ggcGFnZS4gSWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2UgaXQgd2lsbCBiZWNvbWUgc2Nyb2xsYWJsZS5cbiAqXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjlrprnvqnjga7jgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7lhoXlrrnjga/jgrnjgq/jg63jg7zjg6vjgYzoqLHlj6/jgZXjgozjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBjcmVhdGluZy1hLXBhZ2VcbiAqICAgW2VuXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2VuXVxuICogICBbamFdU2V0dGluZyB1cCBhIHBhZ2UgaW4gaXRzIGBpbml0YCBldmVudFsvamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICBteUFwcC5oYW5kbGVyID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqICAgfVxuICogPC9zY3JpcHQ+XG4gKlxuICogPG9ucy1wYWdlIG9uLWluZmluaXRlLXNjcm9sbD1cIm15QXBwLmhhbmRsZXJcIj5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5MaXN0PC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8b25zLWxpc3Q+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzE8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzI8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzM8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLWxpc3Q+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGluaXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGF0dGFjaGVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOOCouOCv+ODg+ODgeOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6KGo56S644GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBkZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgaXMgZGVzdHJveWVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOegtOajhOOBleOCjOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IG1vZGlmaWVyIG5hbWUgdG8gc3BlY2lmeSBjdXN0b20gc3R5bGVzLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+OCpOODq+Wumue+qeOCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+OBn+OCgeOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9uLWluZmluaXRlLXNjcm9sbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGF0aCBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gaW5maW5pdGUgc2Nyb2xsaW5nLiBFeGFtcGxlOiBgYXBwLmxvYWREYXRhYC4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcblxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQgPSB0aGlzLl9nZXRDb250ZW50RWxlbWVudCgpO1xuICAgICAgdGhpcy5faXNNdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfbXV0ZWQnKTtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICBpZiAodGhpcy5fc2tpcEluaXQpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaW5pdCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQodGhpcykpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0JhcigpO1xuXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdvbi1pbmZpbml0ZS1zY3JvbGwnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQmFja0J1dHRvbihzaG93KSB7XG4gICAgaWYgKHRoaXMuYmFja0J1dHRvbikge1xuICAgICAgc2hvdyA/IHRoaXMuYmFja0J1dHRvbi5zaG93KCkgOiB0aGlzLmJhY2tCdXR0b24uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldCBuYW1lKHN0cikge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJywgc3RyKTtcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICB9XG5cbiAgZ2V0IGJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uJyk7XG4gIH1cblxuICBfdHJ5VG9GaWxsU3RhdHVzQmFyKCl7XG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCAhZmlsbGVkICYmICh0aGlzLl9jYW5BbmltYXRlVG9vbGJhcigpIHx8ICF0aGlzLl9oYXNBUGFnZUNvbnRyb2xDaGlsZCgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBfaGFzQVBhZ2VDb250cm9sQ2hpbGQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlID0+IGUubm9kZU5hbWUubWF0Y2goL29ucy0oc3BsaXR0ZXJ8c2xpZGluZy1tZW51fG5hdmlnYXRvcnx0YWJiYXIpL2kpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25JbmZpbml0ZVNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1GdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHNjcm9sbGluZyB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIGFzIGFuIGFyZ3VtZW50IHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBvbkluZmluaXRlU2Nyb2xsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkluZmluaXRlU2Nyb2xsIG11c3QgYmUgYSBmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fb25JbmZpbml0ZVNjcm9sbCkge1xuICAgICAgdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdCA9IDAuOTtcbiAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2NvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpKTtcbiAgICB9XG4gICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG9uSW5maW5pdGVTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uSW5maW5pdGVTY3JvbGw7XG4gIH1cblxuICBfb25TY3JvbGwoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgb3ZlckxpbWl0ID0gKGMuc2Nyb2xsVG9wICsgYy5jbGllbnRIZWlnaHQpIC8gYy5zY3JvbGxIZWlnaHQgPj0gdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdDtcblxuICAgIGlmICh0aGlzLl9vbkluZmluaXRlU2Nyb2xsICYmICF0aGlzLl9sb2FkaW5nQ29udGVudCAmJiBvdmVyTGltaXQpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwoKCkgPT4gdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSBmYWxzZSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRDb250ZW50RWxlbWVudCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignZmFpbCB0byBnZXQgXCIucGFnZV9fY29udGVudFwiIGVsZW1lbnQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9jYW5BbmltYXRlVG9vbGJhcigpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gISF1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZWwgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZWwsICdvbnMtdG9vbGJhcicpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldEJhY2tncm91bmRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1ib3R0b20tdG9vbGJhcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IG51bGxUb29sYmFyRWxlbWVudDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ19tdXRlZCcsICdfc2tpcGluaXQnLCAnb24taW5maW5pdGUtc2Nyb2xsJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnX211dGVkJzpcbiAgICAgICAgdGhpcy5faXNNdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfbXV0ZWQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdfc2tpcGluaXQnOlxuICAgICAgICB0aGlzLl9za2lwSW5pdCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvbi1pbmZpbml0ZS1zY3JvbGwnOlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gKGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IGY7XG4gICAgICAgICAgICBmKGRvbmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5jb250ZW50JykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2JhY2tncm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgdGhpcy5fZWxlbWVudFNob3VsZEJlTW92ZWQobm9kZSkpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcHJldk5vZGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKSB8fCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY29udGVudCwgcHJldk5vZGUgJiYgcHJldk5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZWxlbWVudFNob3VsZEJlTW92ZWQoZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29ucy1mYWInKSB7XG4gICAgICByZXR1cm4gIWVsLmhhc0F0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZml4ZWRFbGVtZW50cyA9IFsnb25zLXRvb2xiYXInLCAnb25zLWJvdHRvbS10b29sYmFyJywgJ29ucy1tb2RhbCcsICdvbnMtc3BlZWQtZGlhbCcsICdvbnMtZGlhbG9nJywgJ29ucy1hbGVydC1kaWFsb2cnLCAnb25zLXBvcG92ZXInXTtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSB8fCBmaXhlZEVsZW1lbnRzLmluZGV4T2YodGFnTmFtZSkgPT09IC0xO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaGlkZScpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9uRGV2aWNlQmFja0J1dHRvbikge1xuICAgICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2luaXQnLCAnc2hvdycsICdoaWRlJywgJ2Rlc3Ryb3knXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcGFnZScsIFBhZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX2FuaW1hdGUoZWxlbWVudCwge2Zyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaywgcmVzdG9yZSA9IGZhbHNlLCBhbmltYXRpb259KSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xuICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uID0gYW5pbWl0KGVsZW1lbnQpO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgIGNzczogdG8sXG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICB9KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIF9hbmltYXRlQWxsKGVsZW1lbnQsIGFuaW1hdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCkpO1xuICB9XG5cbn1cblxuY29uc3QgZmFkZSA9IHtcbiAgb3V0OiB7XG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXG4gICAgdG86IHtvcGFjaXR5OiAwfVxuICB9LFxuICBpbjoge1xuICAgIGZyb206IHtvcGFjaXR5OiAwfSxcbiAgICB0bzoge29wYWNpdHk6IDEuMH1cbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE1ERmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIFBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUuaW4sIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUub3V0LFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUub3V0LCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSU9TRmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIE1ERmFkZVBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMCwgMS4wLCAgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmU6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHtQb3BvdmVyQW5pbWF0b3IsIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIE1ERmFkZVBvcG92ZXJBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnBvcG92ZXInOiAncG9wb3Zlci0tKicsXG4gICcucG9wb3Zlci1tYXNrJzogJ3BvcG92ZXItbWFzay0tKicsXG4gICcucG9wb3Zlcl9fY29udGVudCc6ICdwb3BvdmVyLS0qX19jb250ZW50JyxcbiAgJy5wb3BvdmVyX19hcnJvdyc6ICdwb3BvdmVyLS0qX19hcnJvdydcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVQb3BvdmVyQW5pbWF0b3IgOiBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLFxuICAnbm9uZSc6IFBvcG92ZXJBbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ2ZhZGUtbWQnOiBNREZhZGVQb3BvdmVyQW5pbWF0b3Jcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXG4gIDxkaXYgY2xhc3M9XCJwb3BvdmVyLW1hc2tcIj48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInBvcG92ZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGVudFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19hcnJvd1wiPjwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIGRpYWxvZ3NcbiAqICBbZW5dRGlhbG9nIGNvbXBvbmVudHNbL2VuXVxuICogIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfcG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyJyk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF9hcnJvdygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19hcnJvdycpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9ICgpID0+IHRoaXMuX2NhbmNlbCgpO1xuICB9XG5cbiAgX2luaXRBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgY29uc3QgZmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBQb3BvdmVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnUG9wb3ZlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSB8fCAnZGVmYXVsdCdcbiAgICB9KTtcbiAgICB0aGlzLl9hbmltYXRvciA9IChvcHRpb25zKSA9PiBmYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuICB9XG5cbiAgX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICBjb25zdCB7X3JhZGl1czogcmFkaXVzLCBfY29udGVudDogY29udGVudEVsZW1lbnQsIF9tYXJnaW46IG1hcmdpbn0gPSB0aGlzO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNNRCA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJyk7XG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcblxuICAgIGNvbnN0IHRhcmdldERpc3RhbmNlID0ge1xuICAgICAgdG9wOiB0YXJnZXRSZWN0LnRvcCAtIG1hcmdpbixcbiAgICAgIGxlZnQ6IHRhcmdldFJlY3QubGVmdCAtIG1hcmdpbixcbiAgICAgIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCAtIHRhcmdldFJlY3QucmlnaHQgLSBtYXJnaW4sXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCAtIHRhcmdldFJlY3QuYm90dG9tIC0gbWFyZ2luXG4gICAgfTtcblxuICAgIGNvbnN0IHRhcmdldENlbnRlckRpc3RhbmNlRnJvbSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3QuaGVpZ2h0IC8gMiksXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCAtIHRhcmdldFJlY3QuYm90dG9tICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0ICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LndpZHRoIC8gMiksXG4gICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGggLSB0YXJnZXRSZWN0LnJpZ2h0ICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LndpZHRoIC8gMilcbiAgICB9O1xuXG4gICAgY29uc3Qge3ZlcnRpY2FsLCBwcmltYXJ5OiBwcmltYXJ5RGlyZWN0aW9uLCBzZWNvbmRhcnl9ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyh0YXJnZXREaXN0YW5jZSk7XG4gICAgTW9kaWZpZXJVdGlsLmFkZE1vZGlmaWVyKHRoaXMsIHByaW1hcnlEaXJlY3Rpb24pO1xuXG4gICAgY29uc3Qgc2l6ZU5hbWUgPSB2ZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAvLyBHZXQgLnBvcG92ZXJfX2NvbnRlbnQgc2l6ZVxuICAgIGNvbnN0IGNvbnRlbnRTaXplID0gKHN0eWxlID0+ICh7XG4gICAgICB3aWR0aDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSwgMTApXG4gICAgfSkpKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnRFbGVtZW50KSk7XG5cbiAgICAvLyBTZXR0aW5nIC5wb3BvdmVyIHBvc2l0aW9uLlxuICAgIGNvbnN0IG9mZnNldCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgdGhpcy5fcG9wb3Zlci5zdHlsZVtwcmltYXJ5RGlyZWN0aW9uXSA9IE1hdGgubWF4KG1hcmdpbiwgdGFyZ2V0RGlzdGFuY2VbcHJpbWFyeURpcmVjdGlvbl0gKyBvZmZzZXQgKyBtYXJnaW4pICsgJ3B4JztcbiAgICBjb25zdCBzZWNvbmRhcnlPZmZzZXQgPSBNYXRoLm1heChtYXJnaW4sIG1hcmdpbiArIHRhcmdldERpc3RhbmNlW3NlY29uZGFyeV0gLSAoY29udGVudFNpemVbc2l6ZU5hbWVdIC0gdGFyZ2V0UmVjdFtzaXplTmFtZV0pIC8gMik7XG4gICAgdGhpcy5fcG9wb3Zlci5zdHlsZVtzZWNvbmRhcnldID0gc2Vjb25kYXJ5T2Zmc2V0ICsgJ3B4JztcblxuICAgIC8vIFNldHRpbmcgLnBvcG92ZXJfX2Fycm93IHBvc2l0aW9uLlxuICAgIHRoaXMuX2Fycm93LnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heChyYWRpdXMsICh0YXJnZXRDZW50ZXJEaXN0YW5jZUZyb21bc2Vjb25kYXJ5XSAtIHNlY29uZGFyeU9mZnNldCkpICsgJ3B4JztcbiAgfVxuXG4gIF9jYWxjdWxhdGVEaXJlY3Rpb25zKGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykgfHwgJ3VwIGRvd24gbGVmdCByaWdodCcpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gcG9zaXRpb25zW2VdKTtcbiAgICBjb25zdCBwcmltYXJ5ID0gb3B0aW9ucy5zb3J0KChhLCBiKSA9PiBkaXN0YW5jZVthXSAtIGRpc3RhbmNlW2JdKVswXTtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9ICd0b3AnID09IHByaW1hcnkgfHwgJ2JvdHRvbScgPT0gcHJpbWFyeTtcbiAgICBsZXQgc2Vjb25kYXJ5O1xuXG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS5sZWZ0IDwgZGlzdGFuY2UucmlnaHQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS50b3AgPCBkaXN0YW5jZS5ib3R0b20gPyAndG9wJyA6ICdib3R0b20nO1xuICAgIH1cblxuICAgIHJldHVybiB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX07XG4gIH1cblxuICBfY2xlYXJTdHlsZXMoKSB7XG4gICAgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5fYXJyb3cuc3R5bGVbZV0gPSB0aGlzLl9jb250ZW50LnN0eWxlW2VdID0gdGhpcy5fcG9wb3Zlci5zdHlsZVtlXSA9ICcnO1xuICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGhpcy5fY3VycmVudFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9wb3BvdmVyICYmIHRoaXMuX21hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNEZWZhdWx0Q29udGFpbmVyID0gdGhpcy5fcG9wb3ZlciAmJiB0aGlzLl9jb250ZW50O1xuXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLW1hc2snKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9hcnJvdykge1xuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyX19hcnJvdycpO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSFcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgIShvcHRpb25zLmFuaW1hdGlvbiBpbiBfYW5pbWF0b3JEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRvciAke29wdGlvbnMuYW5pbWF0aW9ufSBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgKTtcbiAgfVxuXG4gIF9leGVjdXRlQWN0aW9uKGFjdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB7YWN0aW9uLCBiZWZvcmUsIGFmdGVyfSA9IGFjdGlvbnM7XG5cbiAgICB0aGlzLl9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBzeW5jaHJvbm91c1xuICAgICAgcG9wb3ZlcjogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG5cbiAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0b3Iob3B0aW9ucylbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhZnRlciAmJiBhZnRlcigpO1xuXG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwb3N0JHthY3Rpb259YCwge3BvcG92ZXI6IHRoaXN9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyh0YXJnZXQsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR8SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC4gQ2FuIGJlIGVpdGhlciBhIENTUyBzZWxlY3RvciwgYW4gZXZlbnQgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuIEl0IGNhbiBiZSBhbHNvIHByb3ZpZGVkIGFzICdvcHRpb25zLnRhcmdldCcgaW5zdGVhZC4gWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44K/44O844Ky44OD44OI44Go44Gq44KL6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCQ1NT44K744Os44Kv44K/44GLZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgYtET03opoHntKDjga7jgYTjgZrjgozjgYvjgpLmuKHjgZvjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gdGhlIHBvcG92ZXIgYW5kIHBvaW50IGl0IGF0IGEgdGFyZ2V0LiBUaGUgdGFyZ2V0IGNhbiBiZSBlaXRoZXIgYW4gZXZlbnQsIGEgQ1NTIHNlbGVjdG9yIG9yIGEgRE9NIGVsZW1lbnQuLlsvZW5dXG4gICAqICAgW2phXeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAgnRhcmdldOW8leaVsOOBq+OBr+OAgSRldmVudOOCquODluOCuOOCp+OCr+ODiOOChERPTeOCqOODrOODoeODs+ODiOOChENTU+OCu+ODrOOCr+OCv+OCkua4oeOBmeOBk+OBqOOBjOWHuuadpeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gQWNjZXB0cyBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRhcmdldCBhcmd1bWVudCBtdXN0IGJlIGRlZmluZWQgZm9yIHRoZSBwb3BvdmVyLicpO1xuICAgIH1cblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xuICAgICAgYWN0aW9uOiAnc2hvdycsXG4gICAgICBiZWZvcmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdoaWRlJyxcbiAgICAgIGFmdGVyOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fY2xlYXJTdHlsZXMoKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLl9wb3BvdmVyLCBjYWxsYmFjayk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJ3RvcCcpKTtcblxuICAgICAgLy8gRml4IGZvciBpZnJhbWVzXG4gICAgICBpZiAoIXRoaXMuX21hcmdpbikge1xuICAgICAgICB0aGlzLl9tYXJnaW4gPSA2O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yYWRpdXMgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9jb250ZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLWxlZnQtcmFkaXVzJykpO1xuXG4gICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcblxuICAgICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdkaXJlY3Rpb24nLCAnYW5pbWF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2RpYWxvZy1jYW5jZWwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9wb3ZlckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IFBvcG92ZXJBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgUG9wb3ZlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBQb3BvdmVyQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcG9wb3ZlcicsIFBvcG92ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyLS0qX19wcmltYXJ5JyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXItLSpfX3NlY29uZGFyeSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgbGluZWFyIHByb2dyZXNzIGJhci4gSXQgY2FuIGVpdGhlciBkaXNwbGF5IGEgcHJvZ3Jlc3MgYmFyIHRoYXQgc2hvd3MgdGhlIHVzZXIgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZC4gSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHBlcmNlbnRhZ2UgaXMgbm90IGtub3duIGl0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgYW4gYW5pbWF0ZWQgcHJvZ3Jlc3MgYmFyIHNvIHRoZSB1c2VyIGNhbiBzZWUgdGhhdCBhbiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4genZRYkdqXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3NcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWNpcmN1bGFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoYmFyRWxlbWVudCwgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAndmFsdWUnLCAnc2Vjb25kYXJ5LXZhbHVlJywgJ2luZGV0ZXJtaW5hdGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZS53aWR0aCA9ICh0aGlzLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUud2lkdGggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHJvZ3Jlc3MtYmFyJywgUHJvZ3Jlc3NCYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcic6ICdwcm9ncmVzcy1jaXJjdWxhci0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3ByaW1hcnknLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3NlY29uZGFyeSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPHN2ZyBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyXCI+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiAvPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeVwiIC8+XG4gIDwvc3ZnPlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLiBJdCBjYW4gZWl0aGVyIGJlIHVzZWQgdG8gc2hvdyBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkIG9yIHRvIHNob3cgYSBsb29waW5nIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBFVnpNalJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWJhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCAnaW5kZXRlcm1pbmF0ZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIE1vZGlmaWVyVXRpbC5hZGRNb2RpZmllcih0aGlzLCAnaW5kZXRlcm1pbmF0ZScpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdpbmRldGVybWluYXRlJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXIgPSBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9ICBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCgpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeScpO1xuXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfaXNDb21waWxlZCgpIHtcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN2ZyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuY29uc3QgcmVtb3ZlVHJhbnNmb3JtID0gKGVsKSA9PiB7XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICBlbC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSAnJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICBlbC5zdHlsZS5XZWJraXRUcmFuc2l0aW9uID0gJyc7XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wdWxsLWhvb2tcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IGFkZHMgKipQdWxsIHRvIHJlZnJlc2gqKiBmdW5jdGlvbmFsaXR5IHRvIGFuIGA8b25zLXBhZ2U+YCBlbGVtZW50LlxuICpcbiAqICAgICBJdCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgdGFzayB3aGVuIHRoZSB1c2VyIHB1bGxzIGRvd24gYXQgdGhlIHRvcCBvZiB0aGUgcGFnZS4gQSBjb21tb24gdXNhZ2UgaXMgdG8gcmVmcmVzaCB0aGUgZGF0YSBkaXNwbGF5ZWQgaW4gYSBwYWdlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFdiSm9nTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3B1bGwtaG9va1xuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1wdWxsLWhvb2s+XG4gKiAgICAgUmVsZWFzZSB0byByZWZyZXNoXG4gKiAgIDwvb25zLXB1bGwtaG9vaz5cbiAqIDwvb25zLXBhZ2U+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignb25zLXB1bGwtaG9vaycpLm9uQWN0aW9uID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVsbEhvb2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlc3RhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWQuIFRoZSBzdGF0ZSBjYW4gYmUgZWl0aGVyIFwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiIG9yIFwiYWN0aW9uXCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu54q25oWL44GM5aSJ44KP44Gj44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CC54q25oWL44Gv44CBXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIsIFwiYWN0aW9uXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wdWxsSG9va1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5zdGF0ZVxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrueKtuaFi+WQjeOCkuWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIFwicHVsbC10by1yZWZyZXNoXCIgZnVuY3Rpb25hbGl0eSBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOCouOCr+OCt+ODp+ODs+OBjOWun+ihjOOBleOCjOOBquOBj+OBquOCiuOBvuOBmVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQuIFdoZW4gcHVsbGVkIGRvd24gZnVydGhlciB0aGFuIHRoaXMgdmFsdWUgaXQgd2lsbCBzd2l0Y2ggdG8gdGhlIFwicHJlYWN0aW9uXCIgc3RhdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiNjRweFwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBrumrmOOBleS7peS4iuOBq3B1bGwgZG93buOBmeOCi+OBqFwicHJlYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga7lgKTjga9cIjY0cHhcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRocmVzaG9sZC1oZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHRocmVzaG9sZCBoZWlnaHQuIFRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byB0aGUgXCJhY3Rpb25cIiBzdGF0ZSB3aGVuIHB1bGxlZCBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI5NnB4XCIuIEEgbmVnYXRpdmUgdmFsdWUgb3IgYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIGhlaWdodCB3aWxsIGRpc2FibGUgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV3plr7lgKTjgajjgarjgovpq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lgKTjgafmjIflrprjgZfjgZ/pq5jjgZXjgojjgorjgoJwdWxsIGRvd27jgZnjgovjgajjgIHjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/oh6rli5XnmoTjgatcImFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtY29udGVudFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBwYWdlIHdpbGwgbm90IG1vdmUgd2hlbiBwdWxsaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBpuOBhOOCi+aZguOBq+OCguOCs+ODs+ODhuODs+ODhOOBr+WLleOBjeOBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCwgdHJ1ZSk7XG4gICAgdGhpcy5faGlkZSgpOyAvLyBGaXggZm9yIHRyYW5zcGFyZW50IHRvb2xiYXIgdHJhbnNpdGlvbnNcbiAgfVxuXG4gIF9zZXRTdHlsZSgpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICB0aGlzLnN0eWxlLmxpbmVIZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgIHRoaXMuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xuICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IGAtJHtoZWlnaHR9cHhgO1xuICB9XG5cbiAgX29uU2Nyb2xsKGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wIDwgMCkge1xuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCAke3Njcm9sbH1weCwgMHB4KWA7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYWNrIHRvIG1ha2UgaXQgd29yayBvbiBBbmRyb2lkIDQuNCBXZWJWaWV3LiBTY3JvbGxzIG1hbnVhbGx5IG5lYXIgdGhlIHRvcCBvZiB0aGUgcGFnZSBzb1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcbiAgICAvLyBraWxsIGFsbCAndG91Y2htb3ZlJyBldmVudHMuXG4gICAgaWYgKHBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuX3N0YXJ0U2Nyb2xsIC0gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG4gICAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT09IDAgJiYgdGhpcy5fZ2V0Q3VycmVudFNjcm9sbCgpID09PSAwKSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCA9IGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XG5cbiAgICBpZiAodGhpcy5fdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpICYmIHNjcm9sbCA+PSB0aGlzLnRocmVzaG9sZEhlaWdodCkge1xuICAgICAgZXZlbnQuZ2VzdHVyZS5zdG9wRGV0ZWN0KCk7XG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9maW5pc2goKSk7XG4gICAgfSBlbHNlIGlmIChzY3JvbGwgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX1BSRUFDVElPTik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgIH1cblxuICAgIC8vIEJ5IHN0b3BwaW5nIHByb3BhZ2F0aW9uIG9ubHkgb2YgYGRyYWd1cGAgYW5kIGBkcmFnZG93bmAsXG4gICAgLy8gYWxsb3dpbmcgYW5jZXN0b3IgZWxlbWVudHMgdG8gZGV0ZWN0IGBkcmFnbGVmdGAgYW5kIGBkcmFncmlnaHRgLlxuICAgIC8vIElmIHdlIGNvbW1lbnQgb3V0IHRoZSBmb2xsb3dpbmcgYGlmYCBibG9jaywgYG9ucy1zcGxpdHRlcmAgd2l0aCBgb25zLXB1bGwtaG9va2Agd2lsbCBiZSBicm9rZW4uXG4gICAgaWYgKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAndXAnIHx8IGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHNjcm9sbCk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fZ2V0Q3VycmVudFNjcm9sbCgpO1xuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA+IDApIHtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcblxuICAgICAgaWYgKHNjcm9sbCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uQWN0aW9uXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGBhY3Rpb25gIHN0YXRlIGlmIGl0IGV4aXN0cy4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgZ2l2ZW4gYSBgZG9uZWAgY2FsbGJhY2sgYXMgaXQncyBmaXJzdCBhcmd1bWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG9uQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkFjdGlvbjtcbiAgfVxuXG4gIHNldCBvbkFjdGlvbih2YWx1ZSkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uQWN0aW9uIG11c3QgYmUgYSBmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuICAgIHRoaXMuX29uQWN0aW9uID0gdmFsdWU7XG4gIH1cblxuICBfZmluaXNoKCkge1xuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8odGhpcy5oZWlnaHQsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xuICAgIGFjdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDY0cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGhlaWdodCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnNjQnLCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRocmVzaG9sZCBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IHRocmVzaG9sZEhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnKSB8fCAnOTYnLCAxMCk7XG4gIH1cblxuICBfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpIHtcbiAgICBjb25zdCB0aCA9IHRoaXMudGhyZXNob2xkSGVpZ2h0O1xuICAgIHJldHVybiB0aCA+IDAgJiYgdGggPj0gdGhpcy5oZWlnaHQ7XG4gIH1cblxuICBfc2V0U3RhdGUoc3RhdGUsIG5vRXZlbnQpIHtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLl9nZXRTdGF0ZSgpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgc3RhdGUpO1xuXG4gICAgaWYgKCFub0V2ZW50ICYmIGxhc3RTdGF0ZSAhPT0gdGhpcy5fZ2V0U3RhdGUoKSkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2VzdGF0ZScsIHtcbiAgICAgICAgcHVsbEhvb2s6IHRoaXMsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgbGFzdFN0YXRlOiBsYXN0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN0YXRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICB9XG5cbiAgX2dldEN1cnJlbnRTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcHVsbERpc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBpeGVscyB0aGUgcHVsbCBob29rIGhhcyBtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgZ/ot53pm6LjgpLjg5Tjgq/jgrvjg6vmlbDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHB1bGxEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9pc0NvbnRlbnRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZpeGVkLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF9nZXRTY3JvbGxhYmxlRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5faXNDb250ZW50Rml4ZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqL1xuICBfdHJhbnNsYXRlVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09IDAgJiYgc2Nyb2xsID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCk7XG4gICAgICAgIHJlbW92ZVRyYW5zZm9ybShlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gc2Nyb2xsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucGxheShkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbClcbiAgICAgICAgfSlcbiAgICAgICAgLnBsYXkoZG9uZSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVEcmFnTG9jaygpIHsgLy8gZTJlIHRlc3RzIG5lZWQgaXRcbiAgICB0aGlzLl9kcmFnTG9ja0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgZHJhZ0xvY2tUb0F4aXM6ICF0aGlzLl9kcmFnTG9ja0Rpc2FibGVkXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xuICAgIC8vXG4gICAgLy8gTm90ZTpcbiAgICAvLyBJZiB3ZSBzd2lwZSB1cC9kb3duIGEgc2NyZWVuIHRvbyBmYXN0LFxuICAgIC8vIHRoZSBnZXN0dXJlIGRldGVjdG9yIG9jY2FzaW9uYWxseSBkaXNwYXRjaGVzIGEgYGRyYWdsZWZ0YCBvciBgZHJhZ3JpZ2h0YCxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGhhdmUgdGhlIHB1bGwgaG9vayBsaXN0ZW4gdG8gYGRyYWdsZWZ0YCBhbmQgYGRyYWdyaWdodGAgYXMgd2VsbCBhcyBgZHJhZ3VwYCBhbmQgYGRyYWdkb3duYC5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWd1cCBkcmFnZG93biBkcmFnbGVmdCBkcmFncmlnaHQnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWd1cCBkcmFnZG93biBkcmFnbGVmdCBkcmFncmlnaHQnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcblxuICAgIHRoaXMuX2Rlc3Ryb3lFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaGVpZ2h0J107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnaGVpZ2h0Jykge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNUQVRFX0lOSVRJQUwoKSB7XG4gICAgcmV0dXJuIFNUQVRFX0lOSVRJQUw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNUQVRFX1BSRUFDVElPTigpIHtcbiAgICByZXR1cm4gU1RBVEVfUFJFQUNUSU9OO1xuICB9XG5cbiAgc3RhdGljIGdldCBTVEFURV9BQ1RJT04oKSB7XG4gICAgcmV0dXJuIFNUQVRFX0FDVElPTjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2NoYW5nZXN0YXRlJ11cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wdWxsLWhvb2snLCBQdWxsSG9va0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTYgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5cbi8qKlxuICogQGNsYXNzIEFuaW1hdG9yQ1NTIC0gaW1wbGVtZW50YXRpb24gb2YgQW5pbWF0b3IgY2xhc3MgdXNpbmcgY3NzIHRyYW5zaXRpb25zXG4gKi9cbmNsYXNzIEFuaW1hdG9yQ1NTIHtcblxuICAvKipcbiAgICogQG1ldGhvZCBhbmltYXRlXG4gICAqIEBkZXNjIG1haW4gYW5pbWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZmluYWxDU1NcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdIC0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQudGhlbihjYWxsYmFjaykgLSBzZXRzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnN0b3Aob3B0aW9ucykgLSBzdG9wcyB0aGUgYW5pbWF0aW9uOyBpZiBvcHRpb25zLnN0b3BOZXh0IGlzIHRydWUgdGhlbiBpdCBkb2Vzbid0IGNhbGwgdGhlIGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuZmluaXNoKG1zKSAtIGZpbmlzaGVzIHRoZSBhbmltYXRpb24gaW4gdGhlIHNwZWNpZmllZCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnNwZWVkKG1zKSAtIHNldHMgdGhlIGFuaW1hdGlvbiBzcGVlZCBzbyB0aGF0IGl0IGZpbmlzaGVzIGFzIGlmIHRoZSBvcmlnaW5hbCBkdXJhdGlvbiB3YXMgdGhlIG9uZSBzcGVjaWZpZWQgaGVyZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBgXG4gICAqICB2YXIgcmVzdWx0ID0gYW5pbWF0b3IuYW5pbWF0ZShlbCwge29wYWNpdHk6IDAuNX0sIDEwMDApO1xuICAgKlxuICAgKiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICogICAgcmVzdWx0LnNwZWVkKDIwMCkudGhlbihmdW5jdGlvbigpe1xuICAgKiAgICAgIGNvbnNvbGUubG9nKCdkb25lJyk7XG4gICAqICAgIH0pO1xuICAgKiAgfSwgMzAwKTtcbiAgICogYGBgYFxuICAgKi9cbiAgYW5pbWF0ZShlbCwgZmluYWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgdmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgaW5pdGlhbCA9IHt9LFxuICAgICAgICBzdG9wcGVkID0gZmFsc2UsXG4gICAgICAgIG5leHQgPSBmYWxzZSxcbiAgICAgICAgdGltZW91dCA9IGZhbHNlLFxuICAgICAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoZmluYWwpO1xuXG4gICAgdmFyIHVwZGF0ZVN0eWxlcyA9ICgpID0+IHtcbiAgICAgIGxldCBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHMuZ2V0UHJvcGVydHlWYWx1ZS5iaW5kKHMpKTtcbiAgICAgIHMgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzdG9wOiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB2YXIgayA9IE1hdGgubWluKDEsICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb24pO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOZXh0KSB7XG4gICAgICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0aGVuOiAoY2IpID0+IHtcbiAgICAgICAgbmV4dCA9IGNiO1xuICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgc3BlZWQ6IChuZXdEdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgICAgIG5ld0R1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICAgIGNvbnN0IHBhc3NlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcbiAgICAgICAgICBjb25zdCAgayA9IHBhc3NlZCAvIGR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IG5ld0R1cmF0aW9uICogKDEgLSBrKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdXBkYXRlU3R5bGVzKCk7XG5cbiAgICAgICAgICBzdGFydCA9IGVsLnNwZWVkVXBUaW1lO1xuICAgICAgICAgIGR1cmF0aW9uID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogKG1pbGxpc2Vjb25kcyA9IDUwKSA9PiB7XG4gICAgICAgIHZhciBrID0gKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcblxuICAgICAgICByZXN1bHQuc3BlZWQobWlsbGlzZWNvbmRzIC8gKDEgLSBrKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgc3RvcHBlZCB8fCBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICBjb25zdCB2ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGUpKTtcbiAgICAgIGluaXRpYWxbZV0gPSBpc05hTih2KSA/IDAgOiB2O1xuICAgIH0pO1xuXG5cbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHByb3BlcnRpZXMuam9pbignLCcpO1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW2VdID0gZmluYWxbZV0gKyAoZSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9vblN0b3BBbmltYXRpb25zKGVsLCByZXN1bHQuc3RvcCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gIH1cblxuICBfb25TdG9wQW5pbWF0aW9ucyhlbCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB2YXIgaSA9IHRoaXMuX2luZGV4Kys7XG4gICAgcXVldWVbZWxdID0gcXVldWVbZWxdIHx8IFtdO1xuICAgIHF1ZXVlW2VsXVtpXSA9IChvcHRpb25zKSA9PiB7XG4gICAgICBkZWxldGUgcXVldWVbZWxdW2ldO1xuICAgICAgaWYgKHF1ZXVlW2VsXSAmJiBxdWV1ZVtlbF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgZGVsZXRlIHF1ZXVlW2VsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcihvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQW5pbWF0aW9uc1xuICAqIEBkZXNjIHN0b3BzIGFjdGl2ZSBhbmltYXRpb25zIG9uIGEgc3BlY2lmaWVkIGVsZW1lbnRcbiAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsZW1lbnQgLSBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICByZXR1cm4gZWwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKHRoaXMuX3F1ZXVlW2VsXSB8fCBbXSkuZm9yRWFjaChlID0+IHsgZShvcHRpb25zIHx8IHt9KTsgfSk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbGxcbiAgKiBAZGVzYyBzdG9wcyBhbGwgYWN0aXZlIGFuaW1hdGlvbnNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbGwob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhPYmplY3Qua2V5cyh0aGlzLl9xdWV1ZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBmYWRlXG4gICogQGRlc2MgZmFkZXMgdGhlIGVsZW1lbnQgKHNob3J0IHZlcnNpb24gZm9yIGFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSkpXG4gICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdXG4gICovXG4gIGZhZGUoZWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9LCBkdXJhdGlvbik7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRvckNTUztcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci1jc3MnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncmlwcGxlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmlwcGxlXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFkZHMgYSBNYXRlcmlhbCBEZXNpZ24gXCJyaXBwbGVcIiBlZmZlY3QgdG8gYW4gZWxlbWVudC4gVGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBzcHJlYWQgZnJvbSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHVzZXIgdGFwcy5cbiAqXG4gKiAgICAgU29tZSBlbGVtZW50cyBzdWNoIGFzIGA8b25zLWJ1dHRvbj5gIGFuZCBgPG9ucy1mYWI+YCAgc3VwcG9ydCBhIGByaXBwbGVgIGF0dHJpYnV0ZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODquODg+ODl+ODq+WKueaenOOCkkRPTeimgee0oOOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB3S1FXZFpcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yaXBwbGVcbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nXG4gKiAgW2VuXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVxuICogIFtqYV1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8ZGl2IGNsYXNzPVwibXktZGl2XCI+XG4gKiAgPG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPlxuICogPC9kaXY+XG4gKlxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIHJpcHBsZT5DbGljayBtZSE8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJpcHBsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLlsvZW5dXG4gICAqICAgW2phXeiDjOaZr+OBruiJsuOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbiAgICBbJ2NvbG9yJywgJ2NlbnRlcicsICdzdGFydC1yYWRpdXMnLCAnYmFja2dyb3VuZCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl93YXZlID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX3dhdmUnKVswXTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX2JhY2tncm91bmQnKVswXTtcblxuICAgIGlmICghKHRoaXMuX2JhY2tncm91bmQgJiYgdGhpcy5fd2F2ZSkpIHtcbiAgICAgIHRoaXMuX3dhdmUgPSB1dGlsLmNyZWF0ZSgnLnJpcHBsZV9fd2F2ZScpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX19iYWNrZ3JvdW5kJyk7XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fd2F2ZSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX2JhY2tncm91bmQpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIHZhciB4LCB5LCBoLCB3LCByO1xuICAgIHZhciBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5fY2VudGVyKSB7XG4gICAgICB4ID0gYi53aWR0aCAvIDI7XG4gICAgICB5ID0gYi5oZWlnaHQgLyAyO1xuICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChlLmNsaWVudFggfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSAtIGIubGVmdDtcbiAgICAgIHkgPSAoZS5jbGllbnRZIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgfVxuICAgIHJldHVybiB7eCwgeSwgcn07XG4gIH1cblxuICBfcmlwcGxlQW5pbWF0aW9uKGUsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgdmFyXG4gICAgICB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXMsXG4gICAgICB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcblxuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RhcnQtcmFkaXVzJzpcbiAgICAgICAgdGhpcy5fbWluUiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoY3VycmVudCkgfHwgMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dhdmUuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgIGlmIChjdXJyZW50IHx8IGxhc3QpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgbGF5b3V0aW5nXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJvdycsIFJvd0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWxlY3QtKicsXG4gICcuc2VsZWN0LWlucHV0JzogJ3NlbGVjdC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VsZWN0JztcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdmb3JtJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncmVxdWlyZWQnLFxuICAnc2l6ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlbGVjdFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3QgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlbGVjdCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgc2VsZWN0IHdpdGggYW4gSUQgb2YgYG15LWlkYCBvbiBhIHBhZ2UsIHVzZSBgPG9ucy1zZWxlY3Qgc2VsZWN0LWlkPVwibXktaWRcIj5gLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlbGVjdCBvbiBBbmRyb2lkLlxuICpcbiAqICAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxzZWxlY3Q+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJgc2VsZWN0YCDopoHntKDjgavkvb/nlKjjgafjgY3jgovlsZ7mgKfjga7lpJrjgY/jgYwgYG9ucy1zZWxlY3RgIOimgee0oOOBp+OCguWIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlbGVjdFxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNlbGVjdD5cbiAqICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj4xPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mm5kPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIzXCI+M3JkIG9wdGlvbjwvb3B0aW9uPlxuICogPC9vbnMtc2VsZWN0PlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0b2ZvY3VzXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbGVtZW50IGF1dG9tYXRpY2FsbHkgZ2FpbnMgZm9jdXMgb24gcGFnZSBsb2FkLlsvZW5dXG4gICAqICBbamFd44Oa44O844K444Ot44O844OJ5pmC44Gr44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr44OV44Kp44O844Kr44K544GM56e744KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIHNlbGVjdCBpbnB1dCBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZm9ybVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQXNzb2NpYXRlIGEgc2VsZWN0IGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgZm9ybSBvbiB0aGUgcGFnZSwgZXZlbiBpZiBub3QgbmVzdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkuOAgeaMh+WumuOBl+OBnyBgZm9ybWAg6KaB57Sg44Gr57SQ5LuY44GR44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544KSIGBmb3JtYCDopoHntKDjga7lpJblgbTjgavphY3nva7jgZnjgovpmpvjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtdWx0aXBsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgbXVsdGlwbGUgb3B0aW9ucyBjYW4gYmUgc2VsZWN0ZWQgYXQgb25jZS5bL2VuXVxuICAgKiAgW2phXemBuOaKnuiCouOBruikh+aVsOmBuOaKnuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hbWUgdGhlIHNlbGVjdCBlbGVtZW50LCB1c2VmdWwgZm9yIGluc3RhbmNlIGlmIGl0IGlzIHBhcnQgb2YgYSBmb3JtLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAgumAmuW4uCBgZm9ybWAg6KaB57Sg44Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIHRoZSBzZWxlY3QgaW5wdXQgcmVxdWlyZWQgZm9yIHN1Ym1pdHRpbmcgdGhlIGZvcm0gaXQgaXMgcGFydCBvZi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLlhaXlipvlv4XpoIjjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlbGVjdC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSUQgZ2l2ZW4gdG8gdGhlIGlubmVyIHNlbGVjdCwgdXNlZnVsIGZvciBkeW5hbWljIG1hbmlwdWxhdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgYzlhoXpg6jjgavmjIHjgaQgc2VsZWN0IOimgee0oOOBq+S4juOBiOOCiyBJRCDjgpLmjIflrprjgZfjgb7jgZnjgILjgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lhoXlrrnjgpLli5XnmoTjgavlpInmm7TjgZnjgovlv4XopoHjgYzjgYLjgovloLTlkIjjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvdyBtYW55IG9wdGlvbnMgYXJlIGRpc3BsYXllZDsgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aGUgc2l6ZSB0aGVuIGEgc2Nyb2xsIGFwcGVhcnMgdG8gbmF2aWdhdGUgdGhlbS5bL2VuXVxuICAgKiAgIFtqYV3kuIDluqbjgavooajnpLrjgZnjgovpgbjmip7ogqLjga7lgIvmlbDjgpLmjIflrprjgZfjgb7jgZnjgILpgbjmip7ogqLjgYzjgZPjga7lsZ7mgKfjgafmjIflrprjgZfjgZ/lgIvmlbDjgojjgorjgoLlpJrjgYTloLTlkIjjgIHjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZSArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9zZWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydjaGFuZ2UnXTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1OdW1iZXIgb2Ygb3B0aW9ucyBpbiB0aGUgc2VsZWN0IGJveC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgavlkKvjgb7jgozjgovpgbjmip7ogqLjga7lgIvmlbDjgpLov5TjgZfjgb7jgZnjgIIgYHNlbGVjdGAg6KaB57SgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXZlcmFsIG9wdGlvbnMgZm9yIGhhbmRsaW5nIHRoZSBzZWxlY3QgRE9NIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgavlkKvjgb7jgozjgosgYG9wdGlvbmAg6KaB57Sg44Gu6YWN5YiX44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWxlY3RlZEluZGV4XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjpgbjmip7jgZXjgozjgabjgYTjgovpgbjmip7ogqLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1WYWx1ZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjpgbjmip7jgZXjgozjgabjgYTjgovpgbjmip7ogqLjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2VsID0gdGhpcy5fc2VsZWN0IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGlmICghc2VsLmlkICYmIHRoaXMuaGFzQXR0cmlidXRlKCdzZWxlY3QtaWQnKSkge1xuICAgICAgc2VsLmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlbGVjdC1pZCcpO1xuICAgIH1cbiAgICBzZWwuY2xhc3NMaXN0LmFkZCgnc2VsZWN0LWlucHV0Jyk7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3QpIHtcbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHNlbC5hcHBlbmRDaGlsZChlbGVtZW50KSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHNlbCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydkaXNhYmxlZCcsICdsZW5ndGgnLCAnbXVsdGlwbGUnLCAnbmFtZScsICdvcHRpb25zJywgJ3NlbGVjdGVkSW5kZXgnLCAnc2l6ZScsICd2YWx1ZSddKSB7XG4gICAgICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oa2V5LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2RlZmluZVNldHRlcl9fKGtleSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuX3NlbGVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdmb3JtJywgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdFsnZm9ybSddO1xuICAgIH0pO1xuICAgIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygndHlwZScsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RbJ3R5cGUnXTtcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkID0gKG9wdGlvbiwgaW5kZXggPSBudWxsKSA9PiB7XG4gICAgICB0aGlzLl9zZWxlY3QuYWRkKG9wdGlvbiwgaW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0LnJlbW92ZShpbmRleCk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNlbGVjdCcsIFNlbGVjdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdmYWIgZmFiLS1taW5pIHNwZWVkLWRpYWxfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbF9faXRlbS0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIHRoZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgTWF0ZXJpYWwgRGVzaWduIFNwZWVkIGRpYWwgY29tcG9uZW50LlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAgTWF0ZXJpYWwgRGVzaWdu44GuU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOePvuOBmeOCi+imgee0oOOBp+OBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gZFlRWUxnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BlZWQtZGlhbFxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZmFiXG4gKiAgIFtlbl1vbnMtZmFiIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZmFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZERpYWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZShjdXJyZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVDbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCFkZWZhdWx0Q2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZXZlcnkodG9rZW4gPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKHRva2VuKTtcbiAgICB9KSkge1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgZGVmYXVsdENsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKHRva2VuKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwtaXRlbScsIFNwZWVkRGlhbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuLyoqXG4gKiBNaW5pbWFsIHV0aWxpdHkgbGlicmFyeSBmb3IgbWFuaXB1bGF0aW5nIGVsZW1lbnQncyBzdHlsZS5cbiAqL1xuY29uc3Qgc3R5bGVyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlci5jc3MuYXBwbHkoc3R5bGVyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBTZXQgZWxlbWVudCdzIHN0eWxlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuc3R5bGVyLmNzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoc3R5bGVyLl9wcmVmaXgoa2V5KSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3N0eWxlci5fcHJlZml4KGtleSldID0gc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwud2FybignTm8gc3VjaCBzdHlsZSBwcm9wZXJ0eTogJyArIGtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFkZCB2ZW5kb3IgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnN0eWxlci5fcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gIHZhciBwcmVmaXggPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgLmNhbGwoc3R5bGVzKVxuICAgIC5qb2luKCcnKVxuICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXG4gIClbMV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuc3R5bGVyLmNsZWFyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBzdHlsZXIuX2NsZWFyKGVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuc3R5bGVyLl9jbGVhciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGxlbiA9IGVsZW1lbnQuc3R5bGUubGVuZ3RoO1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAga2V5cy5wdXNoKHN0eWxlW2ldKTtcbiAgfVxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBzdHlsZVtrZXldID0gJyc7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVyO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9saWIvc3R5bGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzcGVlZC1kaWFsJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEVsZW1lbnQgdGhhdCBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBEaWFsb2cgY29tcG9uZW50LiBJdCBpcyB1c2VmdWwgd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGFjdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBwYWdlLlxuICpcbiAqICAgICBUaGUgU3BlZWQgZGlhbCBsb29rcyBsaWtlIGEgYDxvbnMtZmFiPmAgZWxlbWVudCBidXQgd2lsbCBleHBhbmQgYSBtZW51IHdoZW4gdGFwcGVkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogICAgIEkuZS4gdG8gZGlzcGxheSBpdCBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBzcGVjaWZ5IFwicmlnaHQgdG9wXCIuXG4gICAqICAgICBDaG9vc2UgZnJvbSBcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiIGFuZCBcImJvdHRvbVwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6KaB57Sg44KS6KGo56S644GZ44KL5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXG4gICAqICAgICDkvovjgYjjgbDjgIHlj7PkuIrjgavooajnpLrjgZnjgovloLTlkIjjgavjga9cInJpZ2h0IHRvcFwi44KS5oyH5a6a44GX44G+44GZ44CCXG4gICAqICAgICDlt6blj7PjgajkuIrkuIvjga7kvY3nva7jga7mjIflrprjgavjga/jgIFyaWdodOOBqGxlZnTjgIF0b3Djgahib3R0b23jgYzjgZ3jgozjgZ7jgozmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGRpcmVjdGlvbiB0aGUgaXRlbXMgYXJlIGRpc3BsYXllZC4gUG9zc2libGUgdmFsdWVzIGFyZSBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBhbmQgXCJyaWdodFwiLlsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg6KaB57Sg44GM6KGo56S644GZ44KL5pa55ZCR44KS5oyH5a6a44GX44G+44GZ44CCdXAsIGRvd24sIGxlZnQsIHJpZ2h044GM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncmlwcGxlJywgJ2RpcmVjdGlvbicsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZSArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xuICB9XG5cbiAgZ2V0IF9mYWIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkudGhlbihyZXNvbHZlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgaWYgKHRoaXMuX2ZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gdGhpcy5fZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogdGhpcy5fZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHQuJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2gocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuX2ZhYi5zaG93KCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZUl0ZW1zKCkudGhlbigoKT0+IHRoaXMuX2ZhYi5oaWRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93SXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICBsZXQgdG90YWxEZWxheSA9IDA7XG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIGk7XG4gICAgICAgIHRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5ICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsRGVsYXkgKz0gNTA7XG5cbiAgICAgIHRoaXMuX2l0ZW1TaG93biA9IHRydWU7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ29wZW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICBzZXRUaW1lb3V0KGRlZmVycmVkLnJlc29sdmUsIHRvdGFsRGVsYXkpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgaGlkZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlSXRlbXMoKSB7XG4gICAgbGV0IHRvdGFsRGVsYXkgPSAwO1xuICAgIGlmICh0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKTtcbiAgICAgICAgdG90YWxEZWxheSArPSBkZWxheTtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxEZWxheSArPSA1MDtcblxuICAgICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgc2V0VGltZW91dChkZWZlcnJlZC5yZXNvbHZlLCB0b3RhbERlbGF5KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIH1cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdXRpbC5tYXRjaChlLCAnLmZhYicpICYmIHV0aWwudG9nZ2xlQXR0cmlidXRlKGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmxpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbmxpbmUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCpOODs+ODqeOCpOODs+imgee0oOOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhYi52aXNpYmxlICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVuXG4gICAqIEBzaWduYXR1cmUgaXNPcGVuKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgbWVudSBpcyBvcGVuIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtU2hvd247XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBpdGVtIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGVJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4oKSA/IHRoaXMuaGlkZUl0ZW1zKCkgOiB0aGlzLnNob3dJdGVtcygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnb3BlbicsICdjbG9zZSddO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwnLCBTcGVlZERpYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgZWxlbWVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJDb250ZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSB1cmwgb2YgdGhlIGNvbnRlbnQgcGFnZS4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdXNlZCB0aGUgY29udGVudCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgYDxvbnMtdGVtcGxhdGU+YCB0YWcgb3IgYSByZW1vdGUgZmlsZS5cbiAgICpcbiAgICogICAgIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcHV0IGA8b25zLXBhZ2U+YCBlbGVtZW50IGFzIGEgY2hpbGQgb2YgdGhlIGVsZW1lbnQuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuXG4gICAgICBpZiAocGFnZSkge1xuICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIG11c3QgaGF2ZSBcIm9ucy1zcGxpdHRlclwiIGFzIHBhcmVudE5vZGUuYCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRvIGxvYWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gcGFnZVxuICAgKi9cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXWA8b25zLXBhZ2U+YOimgee0oOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1jb250ZW50JywgU3BsaXR0ZXJDb250ZW50RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJNYXNrRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZXZlcnkoc2lkZSA9PiBzaWRlLm1vZGUgPT09ICdzcGxpdCcpKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lICFpbXBvcnRhbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub25DbGljayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9IGVsc2UgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHNpZGUuY2xvc2UoJ2xlZnQnKS5jYXRjaCgoKSA9PiB7fSkpO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLW1hc2snLCBTcGxpdHRlck1hc2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGR1cmF0aW9uID0gMC4zLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZHVyYXRpb24sIGRlbGF5IH0pO1xuICB9XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLCB7XG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nLCBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgZGVsYXk6IHRoaXMuZGVsYXlcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNpZGVFbGVtZW50XG4gICAqL1xuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2lkZSA9IHNpZGVFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGVudCA9IHNwbGl0dGVyLmNvbnRlbnQ7XG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcbiAgICB9KTtcbiAgfVxuXG4gIGluYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IHRoaXMuX3NpZGUgPSB0aGlzLl9tYXNrID0gbnVsbDtcbiAgfVxuXG4gIGdldCBtaW51cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5fc2lkZSA9PT0gJ3JpZ2h0JyA/ICctJyA6ICcnO1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwcHgsIDBweClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2lkZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICBkZWZhdWx0OiBTcGxpdHRlckFuaW1hdG9yLFxuICBvdmVybGF5OiBTcGxpdHRlckFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuXG4gKlxuICogICAgSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBleHBhbmQgaW50byBhIGNvbHVtbiBsYXlvdXQgb24gbGFyZ2Ugc2NyZWVucyBhbmQgY29sbGFwc2UgdGhlIG1lbnUgb24gc21hbGxlciBzY3JlZW5zLiBXaGVuIHRoZSBtZW51IGlzIGNvbGxhcHNlZCB0aGUgdXNlciBjYW4gb3BlbiBpdCBieSBzd2lwaW5nLlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyIGlkPVwic3BsaXR0ZXJcIj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZSBzd2lwZWFibGU+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc3BsaXR0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXR0ZXInKTtcbiAqICAgc3BsaXR0ZXIubGVmdC5vcGVuKCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF9nZXRTaWRlKHNpZGUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSBzaWRlO1xuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZWZ0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgnbGVmdCcpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcmlnaHRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJpZ2h0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNpZGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcnN0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IHJlZ2FyZGxlc3MgdGhlIGFjdHVhbCBzaWRlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1zaWRlJyk7XG4gIH1cblxuICBnZXQgX3NpZGVzKCkge1xuICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0XS5maWx0ZXIoZSA9PiBlKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5fY29udGVudDtcbiAgfVxuXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIHRoaXMuX3NpZGVzLnNvbWUocyA9PiBzLmlzT3BlbiA/IHMuY2xvc2UoKSA6IGZhbHNlKSB8fCBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICB9XG5cbiAgX29uTW9kZUNoYW5nZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2xheW91dCgpIHtcbiAgICB0aGlzLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3NpZGUuc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLl93aWR0aCA6IDA7XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlID0gdGhpcy5fb25Nb2RlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMubWFzaykge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFNwbGl0dGVyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlcicsIFNwbGl0dGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IFdBVENIRURfQVRUUklCVVRFUyA9IFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ3NpZGUnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ3N3aXBlLXRhcmdldC13aWR0aCcsICdhbmltYXRpb24tb3B0aW9ucycsICdvcGVuLXRocmVzaG9sZCddO1xuXG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGFyZ2V0ICYmIHRoaXMuY2hhbmdlVGFyZ2V0KHRhcmdldCk7XG4gIH1cblxuICBjaGFuZ2VUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXS5pbmRleE9mKHRhcmdldCkgIT09IC0xO1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9tYXRjaCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldCA9PT0gKHZhbHVlLmlzUG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubWF0Y2hlcztcbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUodGhpcy5fbWF0Y2godmFsdWUpID8gQ09MTEFQU0VfTU9ERSA6IFNQTElUX01PREUpO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh7aXNQb3J0cmFpdDogb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gd2luZG93Lm1hdGNoTWVkaWEodGhpcy5fdGFyZ2V0KTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fcXVlcnlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcXVlcnlSZXN1bHQpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKHBhcmVudC5vZmZzZXRXaWR0aCAqIHZhbHVlIC8gMTAwKTtcbn07XG5cbmNsYXNzIENvbGxhcHNlTW9kZSB7XG4gIGdldCBfYW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuX2FuaW1hdG9yO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2xvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICBoYW5kbGVHZXN0dXJlKGUpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9sb2NrLmlzTG9ja2VkKCkgfHwgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vbkRyYWdTdGFydChlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBlLnR5cGUgPT09ICdkcmFnZW5kJyA/IHRoaXMuX29uRHJhZ0VuZChlKSA6IHRoaXMuX29uRHJhZyhlKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBzY3JvbGxpbmcgPSAhL2xlZnR8cmlnaHQvLnRlc3QoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24pO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZWxlbWVudC5fc2lkZSA9PT0gJ2xlZnQnID8gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WCA6IHdpbmRvdy5pbm5lcldpZHRoIC0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fZWxlbWVudC5fc3dpcGVUYXJnZXRXaWR0aDtcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3BlbigpO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBzY3JvbGxpbmcgfHwgKGFyZWEgJiYgZGlzdGFuY2UgPiBhcmVhICYmICFpc09wZW4pO1xuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFRvUHgodGhpcy5fZWxlbWVudC5fd2lkdGgsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gaXNPcGVuID8gdGhpcy5fd2lkdGggOiAwO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSk7XG4gICAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qge19kaXN0YW5jZTogZGlzdGFuY2UsIF93aWR0aDogd2lkdGgsIF9lbGVtZW50OiBlbH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcbiAgICBjb25zdCBzaG91bGRPcGVuID0gZWwuX3NpZGUgIT09IGRpcmVjdGlvbiAmJiBkaXN0YW5jZSA+IHdpZHRoICogZWwuX3RocmVzaG9sZDtcbiAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScpO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnRlciBjb2xsYXBzZSBtb2RlXG4gIGVudGVyTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhpdCBjb2xsYXBzZSBtb2RlXG4gIGV4aXRNb2RlKCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgX2lzT3Blbk90aGVyU2lkZU1lbnUoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbikuc29tZShlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUgIT09IHRoaXMuX2VsZW1lbnQgJiYgZS5pc09wZW47XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSAnb3Blbicgb3IgJ2Nsb3NlJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRBbmltYXRpb25dXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVcbiAgICovXG4gIGV4ZWN1dGVBY3Rpb24obmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgRklOQUxfU1RBVEUgPSBuYW1lID09PSAnb3BlbicgPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gRklOQUxfU1RBVEUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sb2NrLmlzTG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BsaXR0ZXIgc2lkZSBpcyBsb2NrZWQuJyk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnb3BlbicgJiYgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgbWVudSBpcyBhbHJlYWR5IG9wZW4uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHByZSR7bmFtZX1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke25hbWV9IGV2ZW50LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9sb2NrLmxvY2soKTtcbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUgPSBGSU5BTF9TVEFURTtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuX2VtaXRFdmVudChgcG9zdCR7bmFtZX1gKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLndpdGhvdXRBbmltYXRpb24pIHtcbiAgICAgIGRvbmUoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fYW5pbWF0b3JbbmFtZV0oKCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1zaWRlXG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIGA8b25zLXNwbGl0dGVyPmAuXG4gKlxuICogICAgSXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlxuICpcbiAqICAgIEl0IHN1cHBvcnRzIHR3byBtb2RlczogY29sbGFwc2VkIGFuZCBzcGxpdC4gV2hlbiBpdCdzIGluIGNvbGxhcHNlZCBtb2RlIGl0IHdpbGwgYmUgaGlkZGVuIGZyb20gdmlldyBhbmQgY2FuIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHN3aXBlcyB0aGUgc2NyZWVuIG9yIHRhcHMgYSBidXR0b24uIEluIHNwbGl0IG1vZGUgdGhlIGVsZW1lbnQgaXMgYWx3YXlzIHNob3duLiBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCBiZXR3ZWVuIHRoZSB0d28gbW9kZXMgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gc2l6ZS5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgaXMgdGhlIHBhcmVudCBjb21wb25lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJTaWRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IG1vZGVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIG1vZGUgY2hhbmdlcy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7jg6Ljg7zjg4njgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50Lm1vZGVcbiAgICogICBbZW5dUmV0dXJucyB0aGUgY3VycmVudCBtb2RlLiBDYW4gYmUgZWl0aGVyIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nIG1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZy1tZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgIGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uLiBVc2Ugb25lIG9mIGBcIm92ZXJsYXlcImAsIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCXCJvdmVybGF5XCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9wZW4tdGhyZXNob2xkXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0ICAwLjNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgbWVudSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIG9wZW5pbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sbGFwc2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgY29sbGFwc2UgYmVoYXZpb3IuIFZhbGlkIHZhbHVlcyBhcmUgYFwicG9ydHJhaXRcImAsIGBcImxhbmRzY2FwZVwiYCBvciBhIG1lZGlhIHF1ZXJ5LlxuICAgKiAgICAgVGhlIHN0cmluZ3MgYFwicG9ydHJhaXRcImAgYW5kIGBcImxhbmRzY2FwZVwiYCBtZWFucyB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBvciBwb3J0cmFpdCBvcmllbnRhdGlvbi5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBhIG1lZGlhIHF1ZXJ5LCB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IHJlc29sdmVzIHRvIGB0cnVlYC5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZpZXcgYWx3YXlzIGJlIGluIGBcImNvbGxhcHNlXCJgIG1vZGUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDlt6blgbTjga7jg5rjg7zjgrjjgpLpnZ7ooajnpLrjgavjgZnjgovmnaHku7bjgpLmjIflrprjgZfjgb7jgZnjgIJwb3J0cmFpdCwgbGFuZHNjYXBl44CBd2lkdGggI3B444KC44GX44GP44Gv44Oh44OH44Kj44Ki44Kv44Ko44Oq44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCXG4gICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Oh44OH44Kj44Ki44Kv44Ko44Oq44KS5oyH5a6a44GZ44KL44Go44CB5oyH5a6a44GX44Gf44Kv44Ko44Oq44Gr6YGp5ZCI44GX44Gm44GE44KL5aC05ZCI44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDlgKTjgavkvZXjgoLmjIflrprjgZfjgarjgYTloLTlkIjjgavjga/jgIHluLjjgatjb2xsYXBzZeODouODvOODieOBq+OBquOCiuOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB3aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2FuIGJlIHNwZWNpZmllZCBpbiBlaXRoZXIgcGl4ZWxzIG9yIGFzIGEgcGVyY2VudGFnZSwgZS5nLiBgOTAlYCBvciBgMjAwcHhgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruaoquW5heOCkuaMh+WumuOBl+OBvuOBmeOAgnB444GoJeOBp+OBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAgmVnLiA5MCUsIDIwMHB4Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2lkZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBsZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgbG9jYXRlZC4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgYzlt6bjgYvlj7PjgYvjgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovlgKTjga9cImxlZnRcIuOBi1wicmlnaHRcIuOBruOBv+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVhZCBvbmx5LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOBjOioreWumuOBleOCjOOBvuOBmeOAglwiY29sbGFwc2VcIuOCguOBl+OBj+OBr1wic3BsaXRcIuOBjOaMh+WumuOBleOCjOOBvuOBmeOAguOBk+OBruWxnuaAp+OBr+iqreOBv+i+vOOBv+WwgueUqOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgVVJMIG9mIHRoZSBtZW51IHBhZ2UuWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRvIGVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbiBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ5pmC44Gr44K544Ov44Kk44OX5pON5L2c44KS5pyJ5Yq544Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fY29sbGFwc2VNb2RlID0gbmV3IENvbGxhcHNlTW9kZSh0aGlzKTtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBTcGxpdHRlckVsZW1lbnQuYW5pbWF0b3JzLFxuICAgICAgYmFzZUNsYXNzOiBTcGxpdHRlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1NwbGl0dGVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gICAgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlID0gKGUpID0+IHRoaXMuX2NvbGxhcHNlTW9kZS5oYW5kbGVHZXN0dXJlKGUpO1xuICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzID0gV0FUQ0hFRF9BVFRSSUJVVEVTO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBtdXN0IGJlIGFuIG9ucy1zcGxpdHRlciBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5wYXJlbnRFbGVtZW50LCB7ZHJhZ01pbkRpc3RhbmNlOiAxfSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fd2F0Y2hlZEF0dHJpYnV0ZXMuZm9yRWFjaChlID0+IHRoaXMuX3VwZGF0ZShlKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdzaWRlJykpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzaWRlJywgJ2xlZnQnKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgZ2V0IHNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBXQVRDSEVEX0FUVFJJQlVURVM7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZShuYW1lLCBjdXJyZW50KTtcbiAgfVxuXG4gIF91cGRhdGUobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gJ191cGRhdGUnICsgbmFtZS5zcGxpdCgnLScpLm1hcChlID0+IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSkpLmpvaW4oJycpO1xuICAgIHJldHVybiB0aGlzW25hbWVdKHZhbHVlKTtcbiAgfVxuXG4gIF9lbWl0RXZlbnQobmFtZSkge1xuICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpICE9PSAncHJlJykge1xuICAgICAgcmV0dXJuIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7c2lkZTogdGhpc30pO1xuICAgIH1cbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtcbiAgICAgIHNpZGU6IHRoaXMsXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF91cGRhdGVDb2xsYXBzZSh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xsYXBzZScpKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnc3BsaXQnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShTUExJVF9NT0RFKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoQ09MTEFQU0VfTU9ERSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uY2hhbmdlVGFyZ2V0KHZhbHVlKTtcbiAgfVxuXG4gIC8vIHJlYWRvbmx5IGF0dHJpYnV0ZSBmb3IgdGhlIHVzZXJzXG4gIF91cGRhdGVNb2RlKG1vZGUpIHtcbiAgICBpZiAobW9kZSAhPT0gdGhpcy5fbW9kZSkge1xuICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLl9jb2xsYXBzZU1vZGVbbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSA/ICdlbnRlck1vZGUnIDogJ2V4aXRNb2RlJ10oKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgbW9kZSk7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnbW9kZWNoYW5nZScsIHtzaWRlOiB0aGlzLCBtb2RlOiBtb2RlfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZU9wZW5UaHJlc2hvbGQodGhyZXNob2xkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29wZW4tdGhyZXNob2xkJykpIHtcbiAgICB0aGlzLl90aHJlc2hvbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMC4zKSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKHN3aXBlYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA9PT0gbnVsbCA/ICdvZmYnIDogJ29uJztcblxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWdlbmQnLCB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVTd2lwZVRhcmdldFdpZHRoKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpKSB7XG4gICAgdGhpcy5fc3dpcGVUYXJnZXRXaWR0aCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIF91cGRhdGVXaWR0aCgpIHtcbiAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIH1cblxuICBnZXQgX3dpZHRoKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgcmV0dXJuIC9eXFxkKyhweHwlKSQvLnRlc3Qod2lkdGgpID8gd2lkdGggOiAnODAlJztcbiAgfVxuXG4gIHNldCBfd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB2YWx1ZSk7XG4gIH1cblxuICBfdXBkYXRlU2lkZShzaWRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgIHRoaXMuX3NpZGUgPSBzaWRlID09PSAncmlnaHQnID8gc2lkZSA6ICdsZWZ0JztcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb24oYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xuICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBsb2NhdGlvbiB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmlzT3BlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb3BlblxuICAgKiBAc2lnbmF0dXJlIG9wZW4oW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBvcGVuKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGUuZXhlY3V0ZUFjdGlvbignb3BlbicsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvc2VcbiAgICogQHNpZ25hdHVyZSBjbG9zZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBjbG9zZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ2Nsb3NlJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4gPyB0aGlzLmNsb3NlKG9wdGlvbnMpIDogdGhpcy5vcGVuKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBwYWdlVXJsIGluIHRoZSByaWdodCBzZWN0aW9uWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVvcGVuJywgJ3Bvc3RvcGVuJywgJ3ByZWNsb3NlJywgJ3Bvc3RjbG9zZScsICdtb2RlY2hhbmdlJ107XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1zaWRlJywgU3BsaXR0ZXJTaWRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3N3aXRjaCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzd2l0Y2gtLSonLFxuICAnLnN3aXRjaF9faW5wdXQnOiAnc3dpdGNoLS0qX19pbnB1dCcsXG4gICcuc3dpdGNoX19oYW5kbGUnOiAnc3dpdGNoLS0qX19oYW5kbGUnLFxuICAnLnN3aXRjaF9fdG9nZ2xlJzogJ3N3aXRjaC0tKl9fdG9nZ2xlJ1xufTtcblxuY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwic3dpdGNoX19pbnB1dFwiPlxuICA8ZGl2IGNsYXNzPVwic3dpdGNoX190b2dnbGVcIj5cbiAgICA8ZGl2IGNsYXNzPVwic3dpdGNoX19oYW5kbGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvdWNoXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbmNvbnN0IGxvY2F0aW9ucyA9IHtcbiAgaW9zOiBbMSwgMjFdLFxuICBtYXRlcmlhbDogWzAsIDE2XVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3dpdGNoXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBTd2l0Y2ggY29tcG9uZW50LiBUaGUgc3dpdGNoIGNhbiBiZSB0b2dnbGVkIGJvdGggYnkgZHJhZ2dpbmcgYW5kIHRhcHBpbmcuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzd2l0Y2ggb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44K544Kk44OD44OB44KS6KGo56S644GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN3aXRjaFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gTHBYWlFRXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3dpdGNoXG4gKiBAZ3VpZGUgYWRkaW5nLXBhZ2UtY29udGVudFxuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBkaXNhYmxlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBtb2RpZmllcj1cIm1hdGVyaWFsXCI+PC9vbnMtc3dpdGNoPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXRjaEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN3aXRjaCBpcyB0b2dnbGVkLlsvZW5dXG4gICAqICAgW2phXU9OL09GRuOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgKiAgIFtlbl1Td2l0Y2ggb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn1N3aXRjaOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICogICBbZW5dVHJ1ZSBpZiB0aGUgY2hhbmdlIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgarjganjga7jg6bjg7zjgrbjga7mk43kvZzjgavjgojjgaPjgablpInjgo/jgaPjgZ/loLTlkIjjgavjga90cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44KS54Sh5Yq544Gu54q25oWL44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbHVlKSB7XG4gICAgdGhpcy5fY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NoZWNrZWQnLCB0aGlzLl9jaGVja2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9ICEhdmFsdWU7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB0aGlzLl9kaXNhYmxlZCk7XG4gICAgICB0aGlzLl9jaGVja2JveC5kaXNhYmxlZCA9IHRoaXMuX2Rpc2FibGVkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2JveFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHVuZGVybHlpbmcgY2hlY2tib3ggZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXpg6jjga5jaGVja2JveOimgee0oOOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdtb2RpZmllcicsICduYW1lJywgJ3ZhbHVlJywgJ2lucHV0LWlkJ10uZm9yRWFjaChlID0+IHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX19pbnB1dCcpICYmIHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX190b2dnbGUnKSkpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl9jaGVja2JveCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faW5wdXQnKTtcbiAgICB0aGlzLl9oYW5kbGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hfX2hhbmRsZScpO1xuXG4gICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQ7XG4gICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7ZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxfSk7XG4gICAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuY2xpY2soKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3N3aXRjaF9fdG91Y2gnKSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBjbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZScsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuY2hlY2tlZCxcbiAgICAgICAgc3dpdGNoOiB0aGlzLFxuICAgICAgICBpc0ludGVyYWN0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgTW9kaWZpZXJVdGlsLmFkZE1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmFkZE1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9sb2NhdGlvbnNbdGhpcy5jaGVja2VkID8gMSA6IDBdOy8vIC0gZS5nZXN0dXJlLmRlbHRhWDtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWcoZSkge1xuICAgIGUuZ2VzdHVyZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5fZ2V0UG9zaXRpb24oZSkgKyAncHgnO1xuICB9XG5cbiAgX29uUmVsZWFzZShlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKGUpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmNoZWNrZWQ7XG5cbiAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlJywge1xuICAgICAgICB2YWx1ZTogdGhpcy5jaGVja2VkLFxuICAgICAgICBzd2l0Y2g6IHRoaXMsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2lucHV0LWlkJywgJ2NoZWNrZWQnLCAndmFsdWUnLCAnZGlzYWJsZWQnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2NoYW5nZSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmhhc093blByb3BlcnR5KCdfY2hlY2tib3gnKVxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgOiB0aGlzLl9jaGVja2JveC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY2hlY2tib3gudmFsdWUgPSB2YWw7XG4gICAgfSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICAgIHRoaXMuX2lzTWF0ZXJpYWwgPSAoY3VycmVudCB8fCAnJykuaW5kZXhPZignbWF0ZXJpYWwnKSAhPT0gLTE7XG4gICAgICAgICAgdGhpcy5fbG9jYXRpb25zID0gbG9jYXRpb25zW3RoaXMuX2lzTWF0ZXJpYWwgPyAnbWF0ZXJpYWwnIDogJ2lvcyddO1xuICAgICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgICB0aGlzLl9jaGVja2JveC5pZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2JveC5zZXRBdHRyaWJ1dGUobmFtZSwgY3VycmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3dpdGNoJywgU3dpdGNoRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBjbGFzcyBUYWJiYXJBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkdXJhdGlvbiA9IDAuNCwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGR1cmF0aW9uLCBkZWxheSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbGVhdmVQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVudGVyUGFnZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmJhck5vbmVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVySW5kZXgsIGxlYXZlSW5kZXgsIGRvbmUpIHtcbiAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgLyA2MCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhckZhZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVyUGFnZUluZGV4LCBsZWF2ZVBhZ2VJbmRleCwgZG9uZSkge1xuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhclNsaWRlQW5pbWF0b3IgZXh0ZW5kcyBUYWJiYXJBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbicsIGR1cmF0aW9uID0gMC4xNSwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGR1cmF0aW9uLCBkZWxheSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7anFMaXRlfSBsZWF2ZVBhZ2VcbiAgICovXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgY29uc3Qgc2duID0gZW50ZXJJbmRleCA+IGxlYXZlSW5kZXg7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoJyArIChzZ24gPyAnJyA6ICctJykgKyAnMTAwJSwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJy0nIDogJycpICsgJzEwMCUsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1RhYmJhckFuaW1hdG9yLCBUYWJiYXJGYWRlQW5pbWF0b3IsIFRhYmJhck5vbmVBbmltYXRvciwgVGFiYmFyU2xpZGVBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgVGFiRWxlbWVudCBmcm9tICcuLi9vbnMtdGFiJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGFiYmFyX19jb250ZW50JzogJ3RhYmJhci0tKl9fY29udGVudCcsXG4gICcudGFiYmFyJzogJ3RhYmJhci0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogVGFiYmFyTm9uZUFuaW1hdG9yLFxuICAnZmFkZSc6IFRhYmJhckZhZGVBbmltYXRvcixcbiAgJ3NsaWRlJzogVGFiYmFyU2xpZGVBbmltYXRvcixcbiAgJ25vbmUnOiBUYWJiYXJOb25lQW5pbWF0b3Jcbn07XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeSh0YWJiYXJFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoKCkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiAoKSA9PiAnb25zLXRhYmJhci1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiYmFyXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUEgY29tcG9uZW50IHRvIGRpc3BsYXkgYSB0YWIgYmFyIG9uIHRoZSBib3R0b20gb2YgYSBwYWdlLiBVc2VkIHdpdGggYDxvbnMtdGFiPmAgdG8gbWFuYWdlIHBhZ2VzIHVzaW5nIHRhYnMuWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuODmuODvOOCuOS4i+mDqOOBq+ihqOekuuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy10YWLjgajntYTjgb/lkIjjgo/jgZvjgabkvb/jgYbjgZPjgajjgafjgIHjg5rjg7zjgrjjgpLnrqHnkIbjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYlxuICogICBbZW5dVGhlIGA8b25zLXRhYj5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5dVGhlIGA8b25zLXBhZ2U+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBiZWZvcmUgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIGNoYW5nZSBldmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjga7lpInmm7TjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYWZ0ZXIgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OBo+OBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCByZWFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMgaWYgdGhlIGFscmVhZHkgb3BlbiB0YWIgaXMgdGFwcGVkIGFnYWluLlsvZW5dXG4gICAqICAgW2phXeOBmeOBp+OBq+OCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBjOOCguOBhuS4gOW6puOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBleOCjOOBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgdmFsdWVzIGFyZSBgXCJub25lXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwiZmFkZVwiYC4gRGVmYXVsdCBpcyBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOiqreOBv+i+vOOBv+aZguOBruOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44CBXCJmYWRlXCLjgIFcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cIm5vbmVcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgYm90dG9tXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGlPUyBib3R0b20sIEFuZHJvaWQgdG9wKS5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcImJvdHRvbVwi44KC44GX44GP44GvXCJ0b3BcIuOCkumBuOaKnuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wiYm90dG9tXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcblxuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnRlbnQuY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fdGFiYmFyRWxlbWVudDtcbiAgICAgIGlmIChhY3RpdmVJbmRleCAmJiB0YWJiYXIuY2hpbGRyZW4ubGVuZ3RoID4gYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgdGFiYmFyLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgICBiYXNlQ2xhc3M6IFRhYmJhckFuaW1hdG9yLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lOiAnVGFiYmFyQW5pbWF0b3InLFxuICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfdGFiYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXInKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50RWxlbWVudCAmJiB0aGlzLl90YWJiYXJFbGVtZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgICAgIGNvbnN0IGJhciA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyJyk7XG5cbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fY29udGVudCcpO1xuICAgICAgYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXJfX2Zvb3RlcicpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmNyZWF0ZSgnLm9ucy10YWJiYXJfX2NvbnRlbnQudGFiYmFyX19jb250ZW50Jyk7XG4gICAgICBjb25zdCB0YWJiYXIgPSB1dGlsLmNyZWF0ZSgnLnRhYmJhci5vbnMtdGFiYmFyX19mb290ZXInKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YWJiYXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFiYmFyKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuX3RvcCA9IHBvc2l0aW9uID09PSAndG9wJyB8fCAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSk7XG4gICAgY29uc3QgYWN0aW9uID0gdG9wID8gdXRpbC5hZGRNb2RpZmllciA6IHV0aWwucmVtb3ZlTW9kaWZpZXI7XG5cbiAgICBhY3Rpb24odGhpcywgJ3RvcCcpO1xuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgY29udGVudFJlYWR5KHBhZ2UsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpIDogJyc7XG5cbiAgICAgICAgaWYgKHV0aWwubWF0Y2gocGFnZS5maXJzdENoaWxkLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgICAgIGFjdGlvbihwYWdlLmZpcnN0Q2hpbGQsICdub3NoYWRvdycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCgoKSA9PiB7XG4gICAgICBjb25zdCBmaWxsZWQgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgZSA9PiBlLmhhc0F0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJykpO1xuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsIHRvcCAmJiAhZmlsbGVkKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRUYWJiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldFRhYmJhcklkKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJiYXJJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50L251bGx9XG4gICAqL1xuICBfZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCkge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgbGV0IHBhZ2UgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWdlc1tpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFnZSAmJiBwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogcGFnZSBlbGVtZW50IG11c3QgYmUgYSBcIm9ucy1wYWdlXCIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZTtcbiAgfVxuXG4gIGdldCB0b3BQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJldmlvdXNUYWJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5cbiAgICovXG4gIF9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvbGRQYWdlRWxlbWVudCA9IHRoaXMuX29sZFBhZ2VFbGVtZW50IHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgIHRoaXMuX29sZFBhZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmIChvbGRQYWdlRWxlbWVudCAhPT0gaW50ZXJuYWwubnVsbEVsZW1lbnQpIHtcbiAgICAgICAgb2xkUGFnZUVsZW1lbnQuX2hpZGUoKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0b3IuYXBwbHkoZWxlbWVudCwgb2xkUGFnZUVsZW1lbnQsIG9wdGlvbnMuc2VsZWN0ZWRUYWJJbmRleCwgb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4LCAoKSA9PiB7XG4gICAgICAgIGlmIChvbGRQYWdlRWxlbWVudCAhPT0gaW50ZXJuYWwubnVsbEVsZW1lbnQpIHtcbiAgICAgICAgICBvbGRQYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgZWxlbWVudC5fc2hvdygpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVUYWJcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVUYWIoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRhYiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5rZWVwUGFnZV1cbiAgICogICBbZW5dSWYgdHJ1ZSB0aGUgcGFnZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBjOePvuWcqOihqOekuuOBl+OBpuOBhOOCi3BhZ2XjgpLlpInjgYjjgarjgYTloLTlkIjjgavjga90cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJgXCJmYWRlXCJg44CBYFwic2xpZGVcImDjgIFgXCJub25lXCJg44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgb3RoZXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBruOCv+ODluOCkuihqOekuuOBl+OBvuOBmeOAguOCouODi+ODoeODvOOCt+ODp+ODs+OBquOBqeOBruOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVUYWIoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlvdXNUYWIgPSB0aGlzLl9nZXRBY3RpdmVUYWJFbGVtZW50KCksXG4gICAgICBzZWxlY3RlZFRhYiA9IHRoaXMuX2dldFRhYkVsZW1lbnQoaW5kZXgpLFxuICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXggPSBpbmRleCxcbiAgICAgIHByZXZpb3VzUGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcblxuICAgIGlmICghc2VsZWN0ZWRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkVGFiSW5kZXggPT09IHByZXZpb3VzVGFiSW5kZXgpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XG4gICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJldmlvdXNQYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWNoYW5nZScsIHtcbiAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICAgIHByZXZpb3VzVGFiLnNldEFjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRUYWIuc2V0QWN0aXZlKCk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcHJldmlvdXNUYWJJbmRleDogcHJldmlvdXNUYWJJbmRleCxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXg6IHNlbGVjdGVkVGFiSW5kZXhcbiAgICB9O1xuXG4gICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICBwcmV2aW91c1RhYi5zZXRJbmFjdGl2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHNlbGVjdGVkVGFiLl9sb2FkUGFnZUVsZW1lbnQodGhpcy5fY29udGVudEVsZW1lbnQsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcGFnZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgIHRoaXMuX3N3aXRjaFBhZ2UocGFnZUVsZW1lbnQsIHBhcmFtcylcbiAgICAgICAgICAudGhlbihwYWdlID0+IHtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXG4gICAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocGFnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFRhYmJhclZpc2liaWxpdHlcbiAgICogQHNpZ25hdHVyZSBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBoaWRlIG9yIHNob3cgdGhlIHRhYiBiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eSh0cnVlKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSB0YWJiYXIgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0QWN0aXZlVGFiSW5kZXhcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVUYWJJbmRleCgpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICBbZW5dVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB0YWIgaW5kZXggb24gY3VycmVudCBhY3RpdmUgdGFiLiBJZiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgILnj77lnKjjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzjgarjgYTloLTlkIjjgavjga8tMeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXRBY3RpdmVUYWJJbmRleCgpIHtcbiAgICBjb25zdCB0YWJzID0gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFic1tpXSBpbnN0YW5jZW9mIFRhYkVsZW1lbnQgJiYgdGFic1tpXS5pc0FjdGl2ZSAmJiB0YWJzW2ldLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2hlbiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5cbiAgICovXG4gIF9nZXRBY3RpdmVUYWJFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUYWJFbGVtZW50KHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIF9nZXRUYWJFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbltpbmRleF07XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHsgfVxuXG4gIF9zaG93KCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHRhYnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhYnNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBUYWJiYXJBbmltYXRvcigpIHtcbiAgICByZXR1cm4gVGFiYmFyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVjaGFuZ2UnLCAncG9zdGNoYW5nZScsICdyZWFjdGl2ZSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFRhYmJhckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IFRhYmJhckVsZW1lbnQuVGFiYmFyQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiYmFyJywgVGFiYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBUYWJiYXJFbGVtZW50IGZyb20gJy4vb25zLXRhYmJhcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyIH0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0YWJiYXJfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndGFiYmFyLS0qX19pdGVtJyxcbiAgJy50YWJiYXJfX2J1dHRvbic6ICd0YWJiYXItLSpfX2J1dHRvbidcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdj5cbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cInRhYmJhcl9fYnV0dG9uXCI+PC9idXR0b24+XG4gIDwvZGl2PlxuYCk7XG5cbmNvbnN0IGRlZmF1bHRJbm5lclRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGFiYmFyX19pY29uXCI+XG4gICAgICA8b25zLWljb24gaWNvbj1cImlvbi1jbG91ZFwiPjwvb25zLWljb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYmJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0YWJiYXJfX2JhZGdlIG5vdGlmaWNhdGlvblwiPjE8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYiBiYXIuIEVhY2ggYDxvbnMtdGFiPmAgcmVwcmVzZW50cyBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCv+ODluODkOODvOOBq+mFjee9ruOBleOCjOOCi+WQhOOCouOCpOODhuODoOOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBneOCjOOBnuOCjOOBrm9ucy10YWLjga/jg5rjg7zjgrjjgpLooajjgZfjgb7jgZnjgIJcbiAqICAgICBvbnMtdGFi6KaB57Sg44Gu5Lit44Gr44Gv44CB44K/44OW44Gr6KGo56S644GV44KM44KL44Kz44Oz44OG44Oz44OE44KS55u05o6l6KiY6L+w44GZ44KL44GT44Go44GM5Ye65p2l44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICAgW2phXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9qYV1dXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1vbnMtdGFiYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdGFiYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1vbnMtcGFnZSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXW9ucy1pY29uIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtaWNvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdGhhdCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFiIGlzIHRhcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1vbnMtdGFi44GM5Y+C54Wn44GZ44KL44Oa44O844K444G444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lIGZvciB0aGUgdGFiLiBDYW4gc3BlY2lmeSB0aGUgc2FtZSBpY29uIG5hbWUgYXMgYDxvbnMtaWNvbj5gLlxuICAgKiAgICAgSWYgeW91IG5lZWQgdG8gdXNlIHlvdXIgb3duIGljb24sIGNyZWF0ZSBhIENTUyBjbGFzcyB3aXRoIGBiYWNrZ3JvdW5kLWltYWdlYCBvciBhbnkgQ1NTIHByb3BlcnRpZXMgYW5kIHNwZWNpZnkgdGhlIG5hbWUgb2YgeW91ciBDU1MgY2xhc3MgaGVyZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgm9ucy1pY29u44Go5ZCM44GY44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBsYWJlbCBvZiB0aGUgdGFiIGl0ZW0uWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz5LiL44Gr6KGo56S644GV44KM44KL44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFkZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgYSBub3RpZmljYXRpb24gYmFkZ2Ugb24gdG9wIG9mIHRoZSB0YWIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44K444Gr6KGo56S644GZ44KL5YaF5a6544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIHRoZSB0YWIgdGhhdCBpcyBhY3RpdmUgYnkgZGVmYXVsdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbGFiZWwnKSB8fCB0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdiYWRnZScpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9nZXRQYWdlVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBfdGVtcGxhdGVMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNJbnB1dCA9IHRoaXMuX2lucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAncmFkaW8nO1xuICAgIGNvbnN0IGhhc0J1dHRvbiA9IHRoaXMuX2J1dHRvbjtcblxuICAgIHJldHVybiAhIShoYXNJbnB1dCAmJiBoYXNCdXR0b24pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlTG9hZGVkKCkpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgbGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBoYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICB0aGlzLl9idXR0b24uYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcy5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19idXR0b24nKSwgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKTtcbiAgfVxuXG4gIF91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB0aGlzLl9idXR0b247XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgaWYgKGJ1dHRvbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2ljb24nKSkge1xuICAgICAgYnV0dG9uLmluc2VydEJlZm9yZSh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19pY29uJyksIGJ1dHRvbi5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19sYWJlbCcpKSB7XG4gICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnRhYmJhcl9fbGFiZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYmJhcl9fYmFkZ2UnKSkge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2JhZGdlJykpO1xuICAgIH1cblxuICAgIGNvbnN0IGljb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgY29uc3QgYmFkZ2UgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYmFkZ2UnKTtcblxuICAgIGNvbnN0IGljb25FbGVtZW50ID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2ljb24nKS5jaGlsZHJlblswXTtcbiAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYmJhcl9fbGFiZWwnKTtcbiAgICBjb25zdCBiYWRnZUVsZW1lbnQgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYmJhcl9fYmFkZ2UnKTtcblxuICAgIGlmIChpY29uRWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBsYXN0ID0gaWNvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpY29uJyk7XG4gICAgICAgIGljb25FbGVtZW50LnNldEF0dHJpYnV0ZSgnaWNvbicsIGljb24pO1xuICAgICAgICAvLyBkaXJ0eSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9PbnNlblVJL09uc2VuVUkvaXNzdWVzLzE2NTRcbiAgICAgICAgaWNvbkVsZW1lbnQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdpY29uJywgbGFzdCwgaWNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpY29uRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYWJlbEVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYWRnZUVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgYmFkZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJhZGdlRWxlbWVudC50ZXh0Q29udGVudCA9IGJhZGdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFkZ2VFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICBnZXQgX2J1dHRvbigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2J1dHRvbicpO1xuICB9XG5cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICAgIGlmICh0YWJiYXIpIHtcbiAgICAgICAgdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLl9maW5kVGFiSW5kZXgoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlKCkge1xuICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICcnKTtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUtaWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZS1pY29uJyk7XG4gICAgICBjb25zdCBpY29uRWxlbWVudCA9IHRoaXMuX2J1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19pY29uJykuY2hpbGRyZW5bMF07XG4gICAgICBpY29uRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ljb24nLCBpY29uKTtcbiAgICB9XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnKTtcbiAgfVxuXG4gIHNldEluYWN0aXZlKCkge1xuICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhY3RpdmUnKTtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKTtcbiAgICAgIGNvbnN0IGljb25FbGVtZW50ID0gdGhpcy5fYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2ljb24nKS5jaGlsZHJlblswXTtcbiAgICAgIGljb25FbGVtZW50LnNldEF0dHJpYnV0ZSgnaWNvbicsIGljb24pO1xuICAgIH1cblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItaW5hY3RpdmVdLCBvbnMtdGFiLWluYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0Jyk7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1hY3RpdmVdLCBvbnMtdGFiLWFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfbG9hZFBhZ2VFbGVtZW50KHBhcmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZFBhZ2UgJiYgIXRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpLnBhZ2VzO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcbiAgICAgIGlmICghcGFnZXNbaW5kZXhdKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdQYWdlIHdhcyBub3QgcHJvdmlkZWQgdG8gPG9ucy10YWI+IGluZGV4ICcgKyBpbmRleCk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhwYWdlc1tpbmRleF0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbG9hZGluZ1BhZ2UpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmdQYWdlLnRoZW4ocGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICAgIHRoaXMuX2xvYWRpbmdQYWdlID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHsgcGFnZTogdGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBwYXJlbnQgfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkZWRQYWdlID0gcGFnZUVsZW1lbnQ7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ1BhZ2U7XG5cbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuX2xvYWRlZFBhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZFBhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuXG4gICAgcmV0dXJuIHRhYmJhci5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9sb2FkZWRQYWdlKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9lbnN1cmVFbGVtZW50UG9zaXRpb24oKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSArICcgJyA6ICcnO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBwcmVmaXggKyB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSAmJiAhdGhpcy5oYXNMb2FkZWQpIHtcbiAgICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbG9hZFBhZ2VFbGVtZW50KHRhYmJhci5fY29udGVudEVsZW1lbnQsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnYWN0aXZlJykpIHtcbiAgICAgICAgICB0YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuX2ZpbmRUYWJJbmRleCgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsIG9uUmVhZHkpO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMgPT09IGVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb25zLXRhYiBlbGVtZW50IGlzIG11c3QgYmUgY2hpbGQgb2Ygb25zLXRhYmJhciBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlTG9hZGVkKCkgJiYgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgIGNhc2UgJ2JhZGdlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuX3BhZ2UgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWInLCBUYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b29sYmFyLWJ1dHRvbic7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ3Rvb2xiYXItYnV0dG9uLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXItYnV0dG9uXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhciBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQSBidXR0b24gd2l0aCBhbiBvdXRsaW5lLlsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLjgoLjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1CdXR0b24gY29tcG9uZW50IGZvciBvbnMtdG9vbGJhciBhbmQgb25zLWJvdHRvbS10b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOBguOCi+OBhOOBr29ucy1ib3R0b20tdG9vbGJhcuOBq+ioree9ruOBp+OBjeOCi+ODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBhZGRpbmctYS10b29sYmFyXG4gKiAgIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBuYXZpZ2F0aW9uIGJhciBhdCB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWJhY2stYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBkaXNwbGF5cyBhIGJhY2sgYnV0dG9uIGluIHRoZSBuYXZpZ2F0aW9uIGJhci5bL2VuXVxuICogICBbamFdb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRvb2xiYXI+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIEJ1dHRvblxuICogICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIFRpdGxlXG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgPG9ucy1pY29uIGljb249XCJpb24tbmF2aWNvblwiIHNpemU9XCIyOHB4XCI+PC9vbnMtaWNvbj5cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy10b29sYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sYmFyQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXItYnV0dG9uJywgVG9vbGJhckJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3JhbmdlJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9faW5wdXQnOiAncmFuZ2UtLSpfX2lucHV0J1xufTtcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21pbicsXG4gICduYW1lJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYW5nZVxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNsaWRlclsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBSYW5nZSBpbnB1dCBjb21wb25lbnQuIFVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSBzbGlkZXIuXG4gKlxuICogICAgIFdvcmtzIHZlcnkgc2ltaWxhciB0byB0aGUgYDxpbnB1dCB0eXBlPVwicmFuZ2VcIj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geFpRb21NXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmFuZ2VcbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSB0ZXh0IGlucHV0cywgcmFkaW8gYnV0dG9ucyBhbmQgY2hlY2tib3hlcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJhbmdlIHZhbHVlPVwiMjBcIj48L29ucy1yYW5nZT5cbiAqIDxvbnMtcmFuZ2UgbW9kaWZpZXI9XCJtYXRlcmlhbFwiIHZhbHVlPVwiMTBcIj48L3JhbmdlPlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucmFuZ2VfX2lucHV0JykpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgncmFuZ2VfX2lucHV0Jyk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2lucHV0LnN0eWxlLmJhY2tncm91bmRTaXplID0gKDEwMCAqIHRoaXMuX3JhdGlvKSArICclIDJweCc7XG4gIH1cblxuICBfb25EcmFnc3RhcnQoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5nZXN0dXJlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2NsYXNzJywgJ21vZGlmaWVyJywgLi4uSU5QVVRfQVRUUklCVVRFU107XG4gIH1cblxuICBfdXBkYXRlRGlzYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICBNb2RpZmllclV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ2Rpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5yZW1vdmVNb2RpZmllcih0aGlzLCAnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XG4gICAgfVxuXG4gICAgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ21pbicgfHwgbmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ3N0YXJ0KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdzdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LnJhbmdlX19pbnB1dCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2lucHV0JywgJ2NoYW5nZSddO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhbmdlJywgUmFuZ2VFbGVtZW50KTtcbiIsImltcG9ydCAnLi9wb2x5ZmlsbHMnO1xuXG5pbXBvcnQgb25zIGZyb20gJy4vb25zL29ucyc7XG5cbmltcG9ydCBUZW1wbGF0ZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdGVtcGxhdGUnO1xuaW1wb3J0IElmRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pZic7XG5pbXBvcnQgQWxlcnREaWFsb2dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XG5pbXBvcnQgQmFja0J1dHRvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xuaW1wb3J0IEJvdHRvbVRvb2xiYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCBCdXR0b25FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWJ1dHRvbic7XG5pbXBvcnQgQ2Fyb3VzZWxJdGVtRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtJztcbmltcG9ydCBDYXJvdXNlbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtY2Fyb3VzZWwnO1xuaW1wb3J0IENvbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtY29sJztcbmltcG9ydCBEaWFsb2dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgRmFiRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1mYWInO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgSWNvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtaWNvbic7XG5pbXBvcnQgTGF6eVJlcGVhdEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0IExpc3RIZWFkZXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyJztcbmltcG9ydCBMaXN0SXRlbUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGlzdC1pdGVtJztcbmltcG9ydCBMaXN0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1saXN0JztcbmltcG9ydCBJbnB1dEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xuaW1wb3J0IE1vZGFsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1tb2RhbCc7XG5pbXBvcnQgTmF2aWdhdG9yRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0IFBhZ2VFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXBhZ2UnO1xuaW1wb3J0IFBvcG92ZXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xuaW1wb3J0IFByb2dyZXNzQmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXInO1xuaW1wb3J0IFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCBQdWxsSG9va0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCBSaXBwbGVFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXJpcHBsZSc7XG5pbXBvcnQgUm93RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1yb3cnO1xuaW1wb3J0IFNlbGVjdEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc2VsZWN0JztcbmltcG9ydCBTcGVlZERpYWxJdGVtRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0nO1xuaW1wb3J0IFNwZWVkRGlhbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XG5pbXBvcnQgU3BsaXR0ZXJDb250ZW50RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50JztcbmltcG9ydCBTcGxpdHRlck1hc2tFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2snO1xuaW1wb3J0IFNwbGl0dGVyU2lkZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XG5pbXBvcnQgU3BsaXR0ZXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyJztcbmltcG9ydCBTd2l0Y2hFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXN3aXRjaCc7XG5pbXBvcnQgVGFiRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10YWInO1xuaW1wb3J0IFRhYmJhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdGFiYmFyJztcbmltcG9ydCBUb29sYmFyQnV0dG9uRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbic7XG5pbXBvcnQgVG9vbGJhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdG9vbGJhcic7XG5pbXBvcnQgUmFuZ2VFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXJhbmdlJztcblxub25zLlRlbXBsYXRlRWxlbWVudCA9IFRlbXBsYXRlRWxlbWVudDtcbm9ucy5JZkVsZW1lbnQgPSBJZkVsZW1lbnQ7XG5vbnMuQWxlcnREaWFsb2dFbGVtZW50ID0gQWxlcnREaWFsb2dFbGVtZW50O1xub25zLkJhY2tCdXR0b25FbGVtZW50ID0gQmFja0J1dHRvbkVsZW1lbnQ7XG5vbnMuQm90dG9tVG9vbGJhckVsZW1lbnQgPSBCb3R0b21Ub29sYmFyRWxlbWVudDtcbm9ucy5CdXR0b25FbGVtZW50ID0gQnV0dG9uRWxlbWVudDtcbm9ucy5DYXJvdXNlbEl0ZW1FbGVtZW50ID0gQ2Fyb3VzZWxJdGVtRWxlbWVudDtcbm9ucy5DYXJvdXNlbEVsZW1lbnQgPSBDYXJvdXNlbEVsZW1lbnQ7XG5vbnMuQ29sRWxlbWVudCA9IENvbEVsZW1lbnQ7XG5vbnMuRGlhbG9nRWxlbWVudCA9IERpYWxvZ0VsZW1lbnQ7XG5vbnMuRmFiRWxlbWVudCA9IEZhYkVsZW1lbnQ7XG5vbnMuR2VzdHVyZURldGVjdG9yRWxlbWVudCA9IEdlc3R1cmVEZXRlY3RvckVsZW1lbnQ7XG5vbnMuSWNvbkVsZW1lbnQgPSBJY29uRWxlbWVudDtcbm9ucy5MYXp5UmVwZWF0RWxlbWVudCA9IExhenlSZXBlYXRFbGVtZW50O1xub25zLkxpc3RIZWFkZXJFbGVtZW50ID0gTGlzdEhlYWRlckVsZW1lbnQ7XG5vbnMuTGlzdEl0ZW1FbGVtZW50ID0gTGlzdEl0ZW1FbGVtZW50O1xub25zLkxpc3RFbGVtZW50ID0gTGlzdEVsZW1lbnQ7XG5vbnMuSW5wdXRFbGVtZW50ID0gSW5wdXRFbGVtZW50O1xub25zLk1vZGFsRWxlbWVudCA9IE1vZGFsRWxlbWVudDtcbm9ucy5OYXZpZ2F0b3JFbGVtZW50ID0gTmF2aWdhdG9yRWxlbWVudDtcbm9ucy5QYWdlRWxlbWVudCA9IFBhZ2VFbGVtZW50O1xub25zLlBvcG92ZXJFbGVtZW50ID0gUG9wb3ZlckVsZW1lbnQ7XG5vbnMuUHJvZ3Jlc3NCYXJFbGVtZW50ID0gUHJvZ3Jlc3NCYXJFbGVtZW50O1xub25zLlByb2dyZXNzQ2lyY3VsYXJFbGVtZW50ID0gUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQ7XG5vbnMuUHVsbEhvb2tFbGVtZW50ID0gUHVsbEhvb2tFbGVtZW50O1xub25zLlJpcHBsZUVsZW1lbnQgPSBSaXBwbGVFbGVtZW50O1xub25zLlJvd0VsZW1lbnQgPSBSb3dFbGVtZW50O1xub25zLlNlbGVjdEVsZW1lbnQgPSBTZWxlY3RFbGVtZW50O1xub25zLlNwZWVkRGlhbEl0ZW1FbGVtZW50ID0gU3BlZWREaWFsSXRlbUVsZW1lbnQ7XG5vbnMuU3BlZWREaWFsRWxlbWVudCA9IFNwZWVkRGlhbEVsZW1lbnQ7XG5vbnMuU3BsaXR0ZXJDb250ZW50RWxlbWVudCA9IFNwbGl0dGVyQ29udGVudEVsZW1lbnQ7XG5vbnMuU3BsaXR0ZXJNYXNrRWxlbWVudCA9IFNwbGl0dGVyTWFza0VsZW1lbnQ7XG5vbnMuU3BsaXR0ZXJTaWRlRWxlbWVudCA9IFNwbGl0dGVyU2lkZUVsZW1lbnQ7XG5vbnMuU3BsaXR0ZXJFbGVtZW50ID0gU3BsaXR0ZXJFbGVtZW50O1xub25zLlN3aXRjaEVsZW1lbnQgPSBTd2l0Y2hFbGVtZW50O1xub25zLlRhYkVsZW1lbnQgPSBUYWJFbGVtZW50O1xub25zLlRhYmJhckVsZW1lbnQgPSBUYWJiYXJFbGVtZW50O1xub25zLlRvb2xiYXJCdXR0b25FbGVtZW50ID0gVG9vbGJhckJ1dHRvbkVsZW1lbnQ7XG5vbnMuVG9vbGJhckVsZW1lbnQgPSBUb29sYmFyRWxlbWVudDtcbm9ucy5SYW5nZUVsZW1lbnQgPSBSYW5nZUVsZW1lbnQ7XG5cbi8vIGZhc3RjbGlja1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgb25zLmZhc3RDbGljayA9IEZhc3RDbGljay5hdHRhY2goZG9jdW1lbnQuYm9keSk7XG59LCBmYWxzZSk7XG5cbi8vIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcbiAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIod2luZG93LmRvY3VtZW50LmJvZHksICgpID0+IHtcbiAgICBuYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgfSk7XG4gIGRvY3VtZW50LmJvZHkuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBvbnMuR2VzdHVyZURldGVjdG9yKGRvY3VtZW50LmJvZHkpO1xufSwgZmFsc2UpO1xuXG4vLyBzZXR1cCBsb2FkaW5nIHBsYWNlaG9sZGVyXG5vbnMucmVhZHkoZnVuY3Rpb24oKSB7XG4gIG9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzKCk7XG59KTtcblxuLy8gdmlld3BvcnQuanNcbm5ldyBWaWV3cG9ydCgpLnNldHVwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiJdfQ==
